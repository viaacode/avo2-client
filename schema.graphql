# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
	query: query_root
	mutation: mutation_root
	subscription: subscription_root
}

"""
Reference table for lniking assignments and user tags.


columns and relationships of "app.assignment_assignment_tags"
"""
type app_assignment_assignment_tags {
	"An object relationship"
	assignment: app_assignments
	"An object relationship"
	assignment_tag: app_assignment_labels!
	assignment_tag_id: Int!
	assignment_uuid: uuid
	id: Int!
}

"aggregated selection of \"app.assignment_assignment_tags\""
type app_assignment_assignment_tags_aggregate {
	aggregate: app_assignment_assignment_tags_aggregate_fields
	nodes: [app_assignment_assignment_tags!]!
}

"aggregate fields of \"app.assignment_assignment_tags\""
type app_assignment_assignment_tags_aggregate_fields {
	avg: app_assignment_assignment_tags_avg_fields
	count(columns: [app_assignment_assignment_tags_select_column!], distinct: Boolean): Int
	max: app_assignment_assignment_tags_max_fields
	min: app_assignment_assignment_tags_min_fields
	stddev: app_assignment_assignment_tags_stddev_fields
	stddev_pop: app_assignment_assignment_tags_stddev_pop_fields
	stddev_samp: app_assignment_assignment_tags_stddev_samp_fields
	sum: app_assignment_assignment_tags_sum_fields
	var_pop: app_assignment_assignment_tags_var_pop_fields
	var_samp: app_assignment_assignment_tags_var_samp_fields
	variance: app_assignment_assignment_tags_variance_fields
}

"aggregate avg on columns"
type app_assignment_assignment_tags_avg_fields {
	assignment_tag_id: Float
	id: Float
}

"aggregate max on columns"
type app_assignment_assignment_tags_max_fields {
	assignment_tag_id: Int
	assignment_uuid: uuid
	id: Int
}

"aggregate min on columns"
type app_assignment_assignment_tags_min_fields {
	assignment_tag_id: Int
	assignment_uuid: uuid
	id: Int
}

"response of any mutation on the table \"app.assignment_assignment_tags\""
type app_assignment_assignment_tags_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_assignment_assignment_tags!]!
}

"aggregate stddev on columns"
type app_assignment_assignment_tags_stddev_fields {
	assignment_tag_id: Float
	id: Float
}

"aggregate stddev_pop on columns"
type app_assignment_assignment_tags_stddev_pop_fields {
	assignment_tag_id: Float
	id: Float
}

"aggregate stddev_samp on columns"
type app_assignment_assignment_tags_stddev_samp_fields {
	assignment_tag_id: Float
	id: Float
}

"aggregate sum on columns"
type app_assignment_assignment_tags_sum_fields {
	assignment_tag_id: Int
	id: Int
}

"aggregate var_pop on columns"
type app_assignment_assignment_tags_var_pop_fields {
	assignment_tag_id: Float
	id: Float
}

"aggregate var_samp on columns"
type app_assignment_assignment_tags_var_samp_fields {
	assignment_tag_id: Float
	id: Float
}

"aggregate variance on columns"
type app_assignment_assignment_tags_variance_fields {
	assignment_tag_id: Float
	id: Float
}

"columns and relationships of \"app.assignment_blocks_v2\""
type app_assignment_blocks_v2 {
	"An object relationship"
	assignment: app_assignments_v2!
	assignment_id: uuid!
	created_at: timestamptz!
	custom_description: String
	custom_title: String
	end_oc: Int
	fragment_id: String
	id: uuid!
	is_deleted: Boolean!
	original_description: String
	original_title: String
	position: Int!
	start_oc: Int
	thumbnail_path: String
	type: String!
	updated_at: timestamptz!
	use_custom_fields: Boolean!
}

"aggregated selection of \"app.assignment_blocks_v2\""
type app_assignment_blocks_v2_aggregate {
	aggregate: app_assignment_blocks_v2_aggregate_fields
	nodes: [app_assignment_blocks_v2!]!
}

"aggregate fields of \"app.assignment_blocks_v2\""
type app_assignment_blocks_v2_aggregate_fields {
	avg: app_assignment_blocks_v2_avg_fields
	count(columns: [app_assignment_blocks_v2_select_column!], distinct: Boolean): Int
	max: app_assignment_blocks_v2_max_fields
	min: app_assignment_blocks_v2_min_fields
	stddev: app_assignment_blocks_v2_stddev_fields
	stddev_pop: app_assignment_blocks_v2_stddev_pop_fields
	stddev_samp: app_assignment_blocks_v2_stddev_samp_fields
	sum: app_assignment_blocks_v2_sum_fields
	var_pop: app_assignment_blocks_v2_var_pop_fields
	var_samp: app_assignment_blocks_v2_var_samp_fields
	variance: app_assignment_blocks_v2_variance_fields
}

"aggregate avg on columns"
type app_assignment_blocks_v2_avg_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"aggregate max on columns"
type app_assignment_blocks_v2_max_fields {
	assignment_id: uuid
	created_at: timestamptz
	custom_description: String
	custom_title: String
	end_oc: Int
	fragment_id: String
	id: uuid
	original_description: String
	original_title: String
	position: Int
	start_oc: Int
	thumbnail_path: String
	type: String
	updated_at: timestamptz
}

"aggregate min on columns"
type app_assignment_blocks_v2_min_fields {
	assignment_id: uuid
	created_at: timestamptz
	custom_description: String
	custom_title: String
	end_oc: Int
	fragment_id: String
	id: uuid
	original_description: String
	original_title: String
	position: Int
	start_oc: Int
	thumbnail_path: String
	type: String
	updated_at: timestamptz
}

"response of any mutation on the table \"app.assignment_blocks_v2\""
type app_assignment_blocks_v2_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_assignment_blocks_v2!]!
}

"aggregate stddev on columns"
type app_assignment_blocks_v2_stddev_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"aggregate stddev_pop on columns"
type app_assignment_blocks_v2_stddev_pop_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"aggregate stddev_samp on columns"
type app_assignment_blocks_v2_stddev_samp_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"aggregate sum on columns"
type app_assignment_blocks_v2_sum_fields {
	end_oc: Int
	position: Int
	start_oc: Int
}

"aggregate var_pop on columns"
type app_assignment_blocks_v2_var_pop_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"aggregate var_samp on columns"
type app_assignment_blocks_v2_var_samp_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"aggregate variance on columns"
type app_assignment_blocks_v2_variance_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"""
Table for user tags of assignments with colors (enum) and labels.


columns and relationships of "app.assignment_labels"
"""
type app_assignment_labels {
	color_enum_value: lookup_enum_colors_enum!
	color_override: String
	"An object relationship"
	enum_color: lookup_enum_colors!
	id: Int!
	label: String
	owner_profile_id: uuid!
	"An object relationship"
	profile: users_profiles!
	"An array relationship"
	tags(
		"distinct select on columns"
		distinct_on: [app_assignment_assignment_tags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_assignment_tags_order_by!]
		"filter the rows returned"
		where: app_assignment_assignment_tags_bool_exp
	): [app_assignment_assignment_tags!]!
	"An aggregated array relationship"
	tags_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_assignment_tags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_assignment_tags_order_by!]
		"filter the rows returned"
		where: app_assignment_assignment_tags_bool_exp
	): app_assignment_assignment_tags_aggregate!
}

"aggregated selection of \"app.assignment_labels\""
type app_assignment_labels_aggregate {
	aggregate: app_assignment_labels_aggregate_fields
	nodes: [app_assignment_labels!]!
}

"aggregate fields of \"app.assignment_labels\""
type app_assignment_labels_aggregate_fields {
	avg: app_assignment_labels_avg_fields
	count(columns: [app_assignment_labels_select_column!], distinct: Boolean): Int
	max: app_assignment_labels_max_fields
	min: app_assignment_labels_min_fields
	stddev: app_assignment_labels_stddev_fields
	stddev_pop: app_assignment_labels_stddev_pop_fields
	stddev_samp: app_assignment_labels_stddev_samp_fields
	sum: app_assignment_labels_sum_fields
	var_pop: app_assignment_labels_var_pop_fields
	var_samp: app_assignment_labels_var_samp_fields
	variance: app_assignment_labels_variance_fields
}

"aggregate avg on columns"
type app_assignment_labels_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_assignment_labels_max_fields {
	color_override: String
	id: Int
	label: String
	owner_profile_id: uuid
}

"aggregate min on columns"
type app_assignment_labels_min_fields {
	color_override: String
	id: Int
	label: String
	owner_profile_id: uuid
}

"response of any mutation on the table \"app.assignment_labels\""
type app_assignment_labels_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_assignment_labels!]!
}

"aggregate stddev on columns"
type app_assignment_labels_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_assignment_labels_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_assignment_labels_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_assignment_labels_sum_fields {
	id: Int
}

"columns and relationships of \"app.assignment_labels_v2\""
type app_assignment_labels_v2 {
	color_enum_value: lookup_enum_colors_enum!
	color_override: String
	"An object relationship"
	enum_color: lookup_enum_colors!
	id: uuid!
	label: String
	owner_profile_id: uuid!
	"An object relationship"
	profile: users_profiles!
	type: String!
}

"aggregated selection of \"app.assignment_labels_v2\""
type app_assignment_labels_v2_aggregate {
	aggregate: app_assignment_labels_v2_aggregate_fields
	nodes: [app_assignment_labels_v2!]!
}

"aggregate fields of \"app.assignment_labels_v2\""
type app_assignment_labels_v2_aggregate_fields {
	count(columns: [app_assignment_labels_v2_select_column!], distinct: Boolean): Int
	max: app_assignment_labels_v2_max_fields
	min: app_assignment_labels_v2_min_fields
}

"aggregate max on columns"
type app_assignment_labels_v2_max_fields {
	color_override: String
	id: uuid
	label: String
	owner_profile_id: uuid
	type: String
}

"aggregate min on columns"
type app_assignment_labels_v2_min_fields {
	color_override: String
	id: uuid
	label: String
	owner_profile_id: uuid
	type: String
}

"response of any mutation on the table \"app.assignment_labels_v2\""
type app_assignment_labels_v2_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_assignment_labels_v2!]!
}

"aggregate var_pop on columns"
type app_assignment_labels_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_assignment_labels_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_assignment_labels_variance_fields {
	id: Float
}

"""
Pupil responses to teacher's assignments.


columns and relationships of "app.assignment_responses"
"""
type app_assignment_responses {
	"An object relationship"
	assignment: app_assignments
	assignment_uuid: uuid
	"An object relationship"
	collection: app_collections
	collection_uuid: uuid
	created_at: timestamptz!
	id: Int!
	is_archived: Boolean!
	"array van gebruikersprofielen"
	owner_profile_ids("JSON select path" path: String): jsonb!
	submitted_at: timestamptz
	updated_at: timestamptz
}

"aggregated selection of \"app.assignment_responses\""
type app_assignment_responses_aggregate {
	aggregate: app_assignment_responses_aggregate_fields
	nodes: [app_assignment_responses!]!
}

"aggregate fields of \"app.assignment_responses\""
type app_assignment_responses_aggregate_fields {
	avg: app_assignment_responses_avg_fields
	count(columns: [app_assignment_responses_select_column!], distinct: Boolean): Int
	max: app_assignment_responses_max_fields
	min: app_assignment_responses_min_fields
	stddev: app_assignment_responses_stddev_fields
	stddev_pop: app_assignment_responses_stddev_pop_fields
	stddev_samp: app_assignment_responses_stddev_samp_fields
	sum: app_assignment_responses_sum_fields
	var_pop: app_assignment_responses_var_pop_fields
	var_samp: app_assignment_responses_var_samp_fields
	variance: app_assignment_responses_variance_fields
}

"aggregate avg on columns"
type app_assignment_responses_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_assignment_responses_max_fields {
	assignment_uuid: uuid
	collection_uuid: uuid
	created_at: timestamptz
	id: Int
	submitted_at: timestamptz
	updated_at: timestamptz
}

"aggregate min on columns"
type app_assignment_responses_min_fields {
	assignment_uuid: uuid
	collection_uuid: uuid
	created_at: timestamptz
	id: Int
	submitted_at: timestamptz
	updated_at: timestamptz
}

"response of any mutation on the table \"app.assignment_responses\""
type app_assignment_responses_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_assignment_responses!]!
}

"aggregate stddev on columns"
type app_assignment_responses_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_assignment_responses_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_assignment_responses_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_assignment_responses_sum_fields {
	id: Int
}

"columns and relationships of \"app.assignment_responses_v2\""
type app_assignment_responses_v2 {
	"An object relationship"
	assignment: app_assignments_v2!
	assignment_id: uuid!
	collection_title: String
	created_at: timestamptz!
	id: uuid!
	"An object relationship"
	owner: users_summary_view
	owner_profile_id: uuid!
	"An object relationship"
	profile: users_profiles!
	"An array relationship"
	pupil_collection_blocks(
		"distinct select on columns"
		distinct_on: [app_pupil_collection_blocks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_pupil_collection_blocks_order_by!]
		"filter the rows returned"
		where: app_pupil_collection_blocks_bool_exp
	): [app_pupil_collection_blocks!]!
	"An aggregated array relationship"
	pupil_collection_blocks_aggregate(
		"distinct select on columns"
		distinct_on: [app_pupil_collection_blocks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_pupil_collection_blocks_order_by!]
		"filter the rows returned"
		where: app_pupil_collection_blocks_bool_exp
	): app_pupil_collection_blocks_aggregate!
	updated_at: timestamptz!
}

"aggregated selection of \"app.assignment_responses_v2\""
type app_assignment_responses_v2_aggregate {
	aggregate: app_assignment_responses_v2_aggregate_fields
	nodes: [app_assignment_responses_v2!]!
}

"aggregate fields of \"app.assignment_responses_v2\""
type app_assignment_responses_v2_aggregate_fields {
	count(columns: [app_assignment_responses_v2_select_column!], distinct: Boolean): Int
	max: app_assignment_responses_v2_max_fields
	min: app_assignment_responses_v2_min_fields
}

"aggregate max on columns"
type app_assignment_responses_v2_max_fields {
	assignment_id: uuid
	collection_title: String
	created_at: timestamptz
	id: uuid
	owner_profile_id: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type app_assignment_responses_v2_min_fields {
	assignment_id: uuid
	collection_title: String
	created_at: timestamptz
	id: uuid
	owner_profile_id: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"app.assignment_responses_v2\""
type app_assignment_responses_v2_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_assignment_responses_v2!]!
}

"aggregate var_pop on columns"
type app_assignment_responses_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_assignment_responses_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_assignment_responses_variance_fields {
	id: Float
}

"columns and relationships of \"app.assignment_v2_views\""
type app_assignment_v2_views {
	assignment_uuid: uuid!
	count: Int!
	created_at: timestamptz!
	id: uuid!
	updated_at: timestamptz!
}

"aggregated selection of \"app.assignment_v2_views\""
type app_assignment_v2_views_aggregate {
	aggregate: app_assignment_v2_views_aggregate_fields
	nodes: [app_assignment_v2_views!]!
}

"aggregate fields of \"app.assignment_v2_views\""
type app_assignment_v2_views_aggregate_fields {
	avg: app_assignment_v2_views_avg_fields
	count(columns: [app_assignment_v2_views_select_column!], distinct: Boolean): Int
	max: app_assignment_v2_views_max_fields
	min: app_assignment_v2_views_min_fields
	stddev: app_assignment_v2_views_stddev_fields
	stddev_pop: app_assignment_v2_views_stddev_pop_fields
	stddev_samp: app_assignment_v2_views_stddev_samp_fields
	sum: app_assignment_v2_views_sum_fields
	var_pop: app_assignment_v2_views_var_pop_fields
	var_samp: app_assignment_v2_views_var_samp_fields
	variance: app_assignment_v2_views_variance_fields
}

"aggregate avg on columns"
type app_assignment_v2_views_avg_fields {
	count: Float
}

"aggregate max on columns"
type app_assignment_v2_views_max_fields {
	assignment_uuid: uuid
	count: Int
	created_at: timestamptz
	id: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type app_assignment_v2_views_min_fields {
	assignment_uuid: uuid
	count: Int
	created_at: timestamptz
	id: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"app.assignment_v2_views\""
type app_assignment_v2_views_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_assignment_v2_views!]!
}

"aggregate stddev on columns"
type app_assignment_v2_views_stddev_fields {
	count: Float
}

"aggregate stddev_pop on columns"
type app_assignment_v2_views_stddev_pop_fields {
	count: Float
}

"aggregate stddev_samp on columns"
type app_assignment_v2_views_stddev_samp_fields {
	count: Float
}

"aggregate sum on columns"
type app_assignment_v2_views_sum_fields {
	count: Int
}

"aggregate var_pop on columns"
type app_assignment_v2_views_var_pop_fields {
	count: Float
}

"aggregate var_samp on columns"
type app_assignment_v2_views_var_samp_fields {
	count: Float
}

"aggregate variance on columns"
type app_assignment_v2_views_variance_fields {
	count: Float
}

"""
Table for assignments from teacher to student.


columns and relationships of "app.assignments"
"""
type app_assignments {
	answer_url: String
	assignment_type: String
	available_at: timestamptz
	class_room: String
	content_id: String!
	"Welke content wordt er gebruikt in de opdracht."
	content_label: lookup_enum_assignment_content_labels_enum!
	content_layout: Int!
	created_at: timestamptz!
	deadline_at: timestamptz
	description: String
	"An object relationship"
	enum_assignment_content_label: lookup_enum_assignment_content_labels!
	id: Int!
	is_archived: Boolean!
	is_collaborative: Boolean!
	is_deleted: Boolean!
	"An object relationship"
	owner: users_summary_view
	owner_profile_id: uuid!
	"An object relationship"
	profile: users_profiles!
	"An array relationship"
	responses(
		"distinct select on columns"
		distinct_on: [app_assignment_responses_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_responses_order_by!]
		"filter the rows returned"
		where: app_assignment_responses_bool_exp
	): [app_assignment_responses!]!
	"An aggregated array relationship"
	responses_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_responses_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_responses_order_by!]
		"filter the rows returned"
		where: app_assignment_responses_bool_exp
	): app_assignment_responses_aggregate!
	"An array relationship"
	tags(
		"distinct select on columns"
		distinct_on: [app_assignment_assignment_tags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_assignment_tags_order_by!]
		"filter the rows returned"
		where: app_assignment_assignment_tags_bool_exp
	): [app_assignment_assignment_tags!]!
	"An aggregated array relationship"
	tags_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_assignment_tags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_assignment_tags_order_by!]
		"filter the rows returned"
		where: app_assignment_assignment_tags_bool_exp
	): app_assignment_assignment_tags_aggregate!
	title: String
	updated_at: timestamptz!
	uuid: uuid!
}

"aggregated selection of \"app.assignments\""
type app_assignments_aggregate {
	aggregate: app_assignments_aggregate_fields
	nodes: [app_assignments!]!
}

"aggregate fields of \"app.assignments\""
type app_assignments_aggregate_fields {
	avg: app_assignments_avg_fields
	count(columns: [app_assignments_select_column!], distinct: Boolean): Int
	max: app_assignments_max_fields
	min: app_assignments_min_fields
	stddev: app_assignments_stddev_fields
	stddev_pop: app_assignments_stddev_pop_fields
	stddev_samp: app_assignments_stddev_samp_fields
	sum: app_assignments_sum_fields
	var_pop: app_assignments_var_pop_fields
	var_samp: app_assignments_var_samp_fields
	variance: app_assignments_variance_fields
}

"aggregate avg on columns"
type app_assignments_avg_fields {
	content_layout: Float
	id: Float
}

"aggregate max on columns"
type app_assignments_max_fields {
	answer_url: String
	assignment_type: String
	available_at: timestamptz
	class_room: String
	content_id: String
	content_layout: Int
	created_at: timestamptz
	deadline_at: timestamptz
	description: String
	id: Int
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
	uuid: uuid
}

"aggregate min on columns"
type app_assignments_min_fields {
	answer_url: String
	assignment_type: String
	available_at: timestamptz
	class_room: String
	content_id: String
	content_layout: Int
	created_at: timestamptz
	deadline_at: timestamptz
	description: String
	id: Int
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
	uuid: uuid
}

"response of any mutation on the table \"app.assignments\""
type app_assignments_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_assignments!]!
}

"aggregate stddev on columns"
type app_assignments_stddev_fields {
	content_layout: Float
	id: Float
}

"aggregate stddev_pop on columns"
type app_assignments_stddev_pop_fields {
	content_layout: Float
	id: Float
}

"aggregate stddev_samp on columns"
type app_assignments_stddev_samp_fields {
	content_layout: Float
	id: Float
}

"aggregate sum on columns"
type app_assignments_sum_fields {
	content_layout: Int
	id: Int
}

"columns and relationships of \"app.assignments_v2\""
type app_assignments_v2 {
	answer_url: String
	assignment_type: String
	available_at: timestamptz
	"An array relationship"
	blocks(
		"distinct select on columns"
		distinct_on: [app_assignment_blocks_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_blocks_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_blocks_v2_bool_exp
	): [app_assignment_blocks_v2!]!
	"An aggregated array relationship"
	blocks_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_blocks_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_blocks_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_blocks_v2_bool_exp
	): app_assignment_blocks_v2_aggregate!
	created_at: timestamptz!
	deadline_at: timestamptz
	description: String
	id: uuid!
	is_collaborative: Boolean!
	is_deleted: Boolean!
	"An array relationship"
	labels(
		"distinct select on columns"
		distinct_on: [app_assignments_v2_assignment_labels_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_v2_assignment_labels_v2_order_by!]
		"filter the rows returned"
		where: app_assignments_v2_assignment_labels_v2_bool_exp
	): [app_assignments_v2_assignment_labels_v2!]!
	"An aggregated array relationship"
	labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignments_v2_assignment_labels_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_v2_assignment_labels_v2_order_by!]
		"filter the rows returned"
		where: app_assignments_v2_assignment_labels_v2_bool_exp
	): app_assignments_v2_assignment_labels_v2_aggregate!
	"An object relationship"
	owner: users_summary_view
	owner_profile_id: uuid!
	"An object relationship"
	profile: users_profiles!
	"An array relationship"
	responses(
		"distinct select on columns"
		distinct_on: [app_assignment_responses_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_responses_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_responses_v2_bool_exp
	): [app_assignment_responses_v2!]!
	"An aggregated array relationship"
	responses_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_responses_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_responses_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_responses_v2_bool_exp
	): app_assignment_responses_v2_aggregate!
	title: String
	updated_at: timestamptz!
	"An object relationship"
	view_count: app_assignment_v2_views
}

"aggregated selection of \"app.assignments_v2\""
type app_assignments_v2_aggregate {
	aggregate: app_assignments_v2_aggregate_fields
	nodes: [app_assignments_v2!]!
}

"aggregate fields of \"app.assignments_v2\""
type app_assignments_v2_aggregate_fields {
	count(columns: [app_assignments_v2_select_column!], distinct: Boolean): Int
	max: app_assignments_v2_max_fields
	min: app_assignments_v2_min_fields
}

"columns and relationships of \"app.assignments_v2_assignment_labels_v2\""
type app_assignments_v2_assignment_labels_v2 {
	"An object relationship"
	assignment: app_assignments_v2!
	assignment_id: uuid!
	"An object relationship"
	assignment_label: app_assignment_labels_v2!
	assignment_label_id: uuid!
	id: Int!
}

"aggregated selection of \"app.assignments_v2_assignment_labels_v2\""
type app_assignments_v2_assignment_labels_v2_aggregate {
	aggregate: app_assignments_v2_assignment_labels_v2_aggregate_fields
	nodes: [app_assignments_v2_assignment_labels_v2!]!
}

"aggregate fields of \"app.assignments_v2_assignment_labels_v2\""
type app_assignments_v2_assignment_labels_v2_aggregate_fields {
	avg: app_assignments_v2_assignment_labels_v2_avg_fields
	count(columns: [app_assignments_v2_assignment_labels_v2_select_column!], distinct: Boolean): Int
	max: app_assignments_v2_assignment_labels_v2_max_fields
	min: app_assignments_v2_assignment_labels_v2_min_fields
	stddev: app_assignments_v2_assignment_labels_v2_stddev_fields
	stddev_pop: app_assignments_v2_assignment_labels_v2_stddev_pop_fields
	stddev_samp: app_assignments_v2_assignment_labels_v2_stddev_samp_fields
	sum: app_assignments_v2_assignment_labels_v2_sum_fields
	var_pop: app_assignments_v2_assignment_labels_v2_var_pop_fields
	var_samp: app_assignments_v2_assignment_labels_v2_var_samp_fields
	variance: app_assignments_v2_assignment_labels_v2_variance_fields
}

"aggregate avg on columns"
type app_assignments_v2_assignment_labels_v2_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_assignments_v2_assignment_labels_v2_max_fields {
	assignment_id: uuid
	assignment_label_id: uuid
	id: Int
}

"aggregate min on columns"
type app_assignments_v2_assignment_labels_v2_min_fields {
	assignment_id: uuid
	assignment_label_id: uuid
	id: Int
}

"response of any mutation on the table \"app.assignments_v2_assignment_labels_v2\""
type app_assignments_v2_assignment_labels_v2_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_assignments_v2_assignment_labels_v2!]!
}

"aggregate stddev on columns"
type app_assignments_v2_assignment_labels_v2_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_assignments_v2_assignment_labels_v2_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_assignments_v2_assignment_labels_v2_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_assignments_v2_assignment_labels_v2_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_assignments_v2_assignment_labels_v2_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_assignments_v2_assignment_labels_v2_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_assignments_v2_assignment_labels_v2_variance_fields {
	id: Float
}

"aggregate max on columns"
type app_assignments_v2_max_fields {
	answer_url: String
	assignment_type: String
	available_at: timestamptz
	created_at: timestamptz
	deadline_at: timestamptz
	description: String
	id: uuid
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
}

"aggregate min on columns"
type app_assignments_v2_min_fields {
	answer_url: String
	assignment_type: String
	available_at: timestamptz
	created_at: timestamptz
	deadline_at: timestamptz
	description: String
	id: uuid
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
}

"response of any mutation on the table \"app.assignments_v2\""
type app_assignments_v2_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_assignments_v2!]!
}

"aggregate var_pop on columns"
type app_assignments_var_pop_fields {
	content_layout: Float
	id: Float
}

"aggregate var_samp on columns"
type app_assignments_var_samp_fields {
	content_layout: Float
	id: Float
}

"aggregate variance on columns"
type app_assignments_variance_fields {
	content_layout: Float
	id: Float
}

"columns and relationships of \"app.collection_actualisation_overview\""
type app_collection_actualisation_overview {
	collection_id: uuid
	created_at: timestamptz
	is_public: Boolean
	"An array relationship"
	labels(
		"distinct select on columns"
		distinct_on: [app_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_labels_order_by!]
		"filter the rows returned"
		where: app_collection_labels_bool_exp
	): [app_collection_labels!]!
	"An aggregated array relationship"
	labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_labels_order_by!]
		"filter the rows returned"
		where: app_collection_labels_bool_exp
	): app_collection_labels_aggregate!
	"An object relationship"
	last_editor: shared_user_names
	lom_classification("JSON select path" path: String): jsonb
	lom_context("JSON select path" path: String): jsonb
	"An object relationship"
	manager: shared_user_names
	mgmt_created_at: timestamptz
	mgmt_current_status: String
	mgmt_last_eindcheck_date: timestamptz
	mgmt_manager_profile_id: uuid
	mgmt_status_expires_at: timestamptz
	mgmt_updated_at: timestamptz
	"An object relationship"
	owner: users_summary_view
	owner_profile_id: uuid
	title: String
	type_id: Int
	updated_at: timestamptz
	updated_by_profile_id: uuid
}

"aggregated selection of \"app.collection_actualisation_overview\""
type app_collection_actualisation_overview_aggregate {
	aggregate: app_collection_actualisation_overview_aggregate_fields
	nodes: [app_collection_actualisation_overview!]!
}

"aggregate fields of \"app.collection_actualisation_overview\""
type app_collection_actualisation_overview_aggregate_fields {
	avg: app_collection_actualisation_overview_avg_fields
	count(columns: [app_collection_actualisation_overview_select_column!], distinct: Boolean): Int
	max: app_collection_actualisation_overview_max_fields
	min: app_collection_actualisation_overview_min_fields
	stddev: app_collection_actualisation_overview_stddev_fields
	stddev_pop: app_collection_actualisation_overview_stddev_pop_fields
	stddev_samp: app_collection_actualisation_overview_stddev_samp_fields
	sum: app_collection_actualisation_overview_sum_fields
	var_pop: app_collection_actualisation_overview_var_pop_fields
	var_samp: app_collection_actualisation_overview_var_samp_fields
	variance: app_collection_actualisation_overview_variance_fields
}

"aggregate avg on columns"
type app_collection_actualisation_overview_avg_fields {
	type_id: Float
}

"aggregate max on columns"
type app_collection_actualisation_overview_max_fields {
	collection_id: uuid
	created_at: timestamptz
	mgmt_created_at: timestamptz
	mgmt_current_status: String
	mgmt_last_eindcheck_date: timestamptz
	mgmt_manager_profile_id: uuid
	mgmt_status_expires_at: timestamptz
	mgmt_updated_at: timestamptz
	owner_profile_id: uuid
	title: String
	type_id: Int
	updated_at: timestamptz
	updated_by_profile_id: uuid
}

"aggregate min on columns"
type app_collection_actualisation_overview_min_fields {
	collection_id: uuid
	created_at: timestamptz
	mgmt_created_at: timestamptz
	mgmt_current_status: String
	mgmt_last_eindcheck_date: timestamptz
	mgmt_manager_profile_id: uuid
	mgmt_status_expires_at: timestamptz
	mgmt_updated_at: timestamptz
	owner_profile_id: uuid
	title: String
	type_id: Int
	updated_at: timestamptz
	updated_by_profile_id: uuid
}

"aggregate stddev on columns"
type app_collection_actualisation_overview_stddev_fields {
	type_id: Float
}

"aggregate stddev_pop on columns"
type app_collection_actualisation_overview_stddev_pop_fields {
	type_id: Float
}

"aggregate stddev_samp on columns"
type app_collection_actualisation_overview_stddev_samp_fields {
	type_id: Float
}

"aggregate sum on columns"
type app_collection_actualisation_overview_sum_fields {
	type_id: Int
}

"aggregate var_pop on columns"
type app_collection_actualisation_overview_var_pop_fields {
	type_id: Float
}

"aggregate var_samp on columns"
type app_collection_actualisation_overview_var_samp_fields {
	type_id: Float
}

"aggregate variance on columns"
type app_collection_actualisation_overview_variance_fields {
	type_id: Float
}

"columns and relationships of \"app.collection_bookmarks\""
type app_collection_bookmarks {
	"An object relationship"
	bookmarkedCollection: app_collections
	collection_uuid: uuid!
	created_at: timestamptz!
	id: Int!
	"An object relationship"
	profile: users_profiles!
	profile_id: uuid!
	updated_at: timestamptz!
}

"aggregated selection of \"app.collection_bookmarks\""
type app_collection_bookmarks_aggregate {
	aggregate: app_collection_bookmarks_aggregate_fields
	nodes: [app_collection_bookmarks!]!
}

"aggregate fields of \"app.collection_bookmarks\""
type app_collection_bookmarks_aggregate_fields {
	avg: app_collection_bookmarks_avg_fields
	count(columns: [app_collection_bookmarks_select_column!], distinct: Boolean): Int
	max: app_collection_bookmarks_max_fields
	min: app_collection_bookmarks_min_fields
	stddev: app_collection_bookmarks_stddev_fields
	stddev_pop: app_collection_bookmarks_stddev_pop_fields
	stddev_samp: app_collection_bookmarks_stddev_samp_fields
	sum: app_collection_bookmarks_sum_fields
	var_pop: app_collection_bookmarks_var_pop_fields
	var_samp: app_collection_bookmarks_var_samp_fields
	variance: app_collection_bookmarks_variance_fields
}

"aggregate avg on columns"
type app_collection_bookmarks_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_collection_bookmarks_max_fields {
	collection_uuid: uuid
	created_at: timestamptz
	id: Int
	profile_id: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type app_collection_bookmarks_min_fields {
	collection_uuid: uuid
	created_at: timestamptz
	id: Int
	profile_id: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"app.collection_bookmarks\""
type app_collection_bookmarks_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_collection_bookmarks!]!
}

"aggregate stddev on columns"
type app_collection_bookmarks_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_collection_bookmarks_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_collection_bookmarks_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_collection_bookmarks_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_collection_bookmarks_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_collection_bookmarks_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_collection_bookmarks_variance_fields {
	id: Float
}

"columns and relationships of \"app.collection_counts\""
type app_collection_counts {
	bookmarks: bigint
	collection_uuid: uuid
	copies: bigint
	fragments: bigint
	in_assignment: bigint
	in_collection: bigint
	plays: Int
	quick_lane_links: bigint
	views: Int
}

"aggregated selection of \"app.collection_counts\""
type app_collection_counts_aggregate {
	aggregate: app_collection_counts_aggregate_fields
	nodes: [app_collection_counts!]!
}

"aggregate fields of \"app.collection_counts\""
type app_collection_counts_aggregate_fields {
	avg: app_collection_counts_avg_fields
	count(columns: [app_collection_counts_select_column!], distinct: Boolean): Int
	max: app_collection_counts_max_fields
	min: app_collection_counts_min_fields
	stddev: app_collection_counts_stddev_fields
	stddev_pop: app_collection_counts_stddev_pop_fields
	stddev_samp: app_collection_counts_stddev_samp_fields
	sum: app_collection_counts_sum_fields
	var_pop: app_collection_counts_var_pop_fields
	var_samp: app_collection_counts_var_samp_fields
	variance: app_collection_counts_variance_fields
}

"aggregate avg on columns"
type app_collection_counts_avg_fields {
	bookmarks: Float
	copies: Float
	fragments: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"aggregate max on columns"
type app_collection_counts_max_fields {
	bookmarks: bigint
	collection_uuid: uuid
	copies: bigint
	fragments: bigint
	in_assignment: bigint
	in_collection: bigint
	plays: Int
	quick_lane_links: bigint
	views: Int
}

"aggregate min on columns"
type app_collection_counts_min_fields {
	bookmarks: bigint
	collection_uuid: uuid
	copies: bigint
	fragments: bigint
	in_assignment: bigint
	in_collection: bigint
	plays: Int
	quick_lane_links: bigint
	views: Int
}

"aggregate stddev on columns"
type app_collection_counts_stddev_fields {
	bookmarks: Float
	copies: Float
	fragments: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"aggregate stddev_pop on columns"
type app_collection_counts_stddev_pop_fields {
	bookmarks: Float
	copies: Float
	fragments: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"aggregate stddev_samp on columns"
type app_collection_counts_stddev_samp_fields {
	bookmarks: Float
	copies: Float
	fragments: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"aggregate sum on columns"
type app_collection_counts_sum_fields {
	bookmarks: bigint
	copies: bigint
	fragments: bigint
	in_assignment: bigint
	in_collection: bigint
	plays: Int
	quick_lane_links: bigint
	views: Int
}

"aggregate var_pop on columns"
type app_collection_counts_var_pop_fields {
	bookmarks: Float
	copies: Float
	fragments: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"aggregate var_samp on columns"
type app_collection_counts_var_samp_fields {
	bookmarks: Float
	copies: Float
	fragments: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"aggregate variance on columns"
type app_collection_counts_variance_fields {
	bookmarks: Float
	copies: Float
	fragments: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"columns and relationships of \"app.collection_fragments\""
type app_collection_fragments {
	collection_id: String
	collection_uuid: uuid
	created_at: timestamptz!
	custom_description: String
	custom_title: String
	end_oc: Int
	external_id: String
	id: Int!
	is_copy_of: uuid
	is_deleted: Boolean!
	position: Int!
	start_oc: Int
	thumbnail_path: String
	"Soort fragment: tekst, media-item of andere collectie"
	type: String!
	updated_at: timestamptz!
	use_custom_fields: Boolean!
}

"aggregated selection of \"app.collection_fragments\""
type app_collection_fragments_aggregate {
	aggregate: app_collection_fragments_aggregate_fields
	nodes: [app_collection_fragments!]!
}

"aggregate fields of \"app.collection_fragments\""
type app_collection_fragments_aggregate_fields {
	avg: app_collection_fragments_avg_fields
	count(columns: [app_collection_fragments_select_column!], distinct: Boolean): Int
	max: app_collection_fragments_max_fields
	min: app_collection_fragments_min_fields
	stddev: app_collection_fragments_stddev_fields
	stddev_pop: app_collection_fragments_stddev_pop_fields
	stddev_samp: app_collection_fragments_stddev_samp_fields
	sum: app_collection_fragments_sum_fields
	var_pop: app_collection_fragments_var_pop_fields
	var_samp: app_collection_fragments_var_samp_fields
	variance: app_collection_fragments_variance_fields
}

"aggregate avg on columns"
type app_collection_fragments_avg_fields {
	end_oc: Float
	id: Float
	position: Float
	start_oc: Float
}

"aggregate max on columns"
type app_collection_fragments_max_fields {
	collection_id: String
	collection_uuid: uuid
	created_at: timestamptz
	custom_description: String
	custom_title: String
	end_oc: Int
	external_id: String
	id: Int
	is_copy_of: uuid
	position: Int
	start_oc: Int
	thumbnail_path: String
	type: String
	updated_at: timestamptz
}

"aggregate min on columns"
type app_collection_fragments_min_fields {
	collection_id: String
	collection_uuid: uuid
	created_at: timestamptz
	custom_description: String
	custom_title: String
	end_oc: Int
	external_id: String
	id: Int
	is_copy_of: uuid
	position: Int
	start_oc: Int
	thumbnail_path: String
	type: String
	updated_at: timestamptz
}

"response of any mutation on the table \"app.collection_fragments\""
type app_collection_fragments_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_collection_fragments!]!
}

"aggregate stddev on columns"
type app_collection_fragments_stddev_fields {
	end_oc: Float
	id: Float
	position: Float
	start_oc: Float
}

"aggregate stddev_pop on columns"
type app_collection_fragments_stddev_pop_fields {
	end_oc: Float
	id: Float
	position: Float
	start_oc: Float
}

"aggregate stddev_samp on columns"
type app_collection_fragments_stddev_samp_fields {
	end_oc: Float
	id: Float
	position: Float
	start_oc: Float
}

"aggregate sum on columns"
type app_collection_fragments_sum_fields {
	end_oc: Int
	id: Int
	position: Int
	start_oc: Int
}

"aggregate var_pop on columns"
type app_collection_fragments_var_pop_fields {
	end_oc: Float
	id: Float
	position: Float
	start_oc: Float
}

"aggregate var_samp on columns"
type app_collection_fragments_var_samp_fields {
	end_oc: Float
	id: Float
	position: Float
	start_oc: Float
}

"aggregate variance on columns"
type app_collection_fragments_variance_fields {
	end_oc: Float
	id: Float
	position: Float
	start_oc: Float
}

"columns and relationships of \"app.collection_labels\""
type app_collection_labels {
	"An object relationship"
	collection: app_collections!
	collection_uuid: uuid!
	created_at: timestamptz!
	id: Int!
	label: String!
	"An array relationship"
	label_enum(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_labels_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_labels_bool_exp
	): [lookup_enum_collection_labels!]!
	"An aggregated array relationship"
	label_enum_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_labels_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_labels_bool_exp
	): lookup_enum_collection_labels_aggregate!
	updated_at: timestamptz!
}

"aggregated selection of \"app.collection_labels\""
type app_collection_labels_aggregate {
	aggregate: app_collection_labels_aggregate_fields
	nodes: [app_collection_labels!]!
}

"aggregate fields of \"app.collection_labels\""
type app_collection_labels_aggregate_fields {
	avg: app_collection_labels_avg_fields
	count(columns: [app_collection_labels_select_column!], distinct: Boolean): Int
	max: app_collection_labels_max_fields
	min: app_collection_labels_min_fields
	stddev: app_collection_labels_stddev_fields
	stddev_pop: app_collection_labels_stddev_pop_fields
	stddev_samp: app_collection_labels_stddev_samp_fields
	sum: app_collection_labels_sum_fields
	var_pop: app_collection_labels_var_pop_fields
	var_samp: app_collection_labels_var_samp_fields
	variance: app_collection_labels_variance_fields
}

"aggregate avg on columns"
type app_collection_labels_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_collection_labels_max_fields {
	collection_uuid: uuid
	created_at: timestamptz
	id: Int
	label: String
	updated_at: timestamptz
}

"aggregate min on columns"
type app_collection_labels_min_fields {
	collection_uuid: uuid
	created_at: timestamptz
	id: Int
	label: String
	updated_at: timestamptz
}

"response of any mutation on the table \"app.collection_labels\""
type app_collection_labels_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_collection_labels!]!
}

"aggregate stddev on columns"
type app_collection_labels_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_collection_labels_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_collection_labels_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_collection_labels_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_collection_labels_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_collection_labels_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_collection_labels_variance_fields {
	id: Float
}

"columns and relationships of \"app.collection_management\""
type app_collection_management {
	"An array relationship"
	QC(
		"distinct select on columns"
		distinct_on: [app_collection_management_QC_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_management_QC_order_by!]
		"filter the rows returned"
		where: app_collection_management_QC_bool_exp
	): [app_collection_management_QC!]!
	"An aggregated array relationship"
	QC_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_management_QC_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_management_QC_order_by!]
		"filter the rows returned"
		where: app_collection_management_QC_bool_exp
	): app_collection_management_QC_aggregate!
	"An object relationship"
	collection: app_collections!
	collection_id: uuid!
	created_at: timestamptz!
	current_status: String
	id: Int!
	"An object relationship"
	manager: users_summary_view
	manager_profile_id: uuid
	note: String
	"An object relationship"
	status: lookup_enum_collection_management_status
	status_valid_until: timestamptz
	updated_at: timestamptz!
}

"columns and relationships of \"app.collection_management_QC\""
type app_collection_management_QC {
	"An object relationship"
	assignee: shared_user_names
	assignee_profile_id: uuid!
	"An object relationship"
	collection: app_collections!
	collection_id: uuid!
	comment: String
	created_at: timestamptz!
	id: Int!
	"An object relationship"
	label: lookup_enum_collection_management_qc_label!
	qc_label: lookup_enum_collection_management_qc_label_enum!
	qc_status: Boolean
	updated_at: timestamptz!
}

"aggregated selection of \"app.collection_management_QC\""
type app_collection_management_QC_aggregate {
	aggregate: app_collection_management_QC_aggregate_fields
	nodes: [app_collection_management_QC!]!
}

"aggregate fields of \"app.collection_management_QC\""
type app_collection_management_QC_aggregate_fields {
	avg: app_collection_management_QC_avg_fields
	count(columns: [app_collection_management_QC_select_column!], distinct: Boolean): Int
	max: app_collection_management_QC_max_fields
	min: app_collection_management_QC_min_fields
	stddev: app_collection_management_QC_stddev_fields
	stddev_pop: app_collection_management_QC_stddev_pop_fields
	stddev_samp: app_collection_management_QC_stddev_samp_fields
	sum: app_collection_management_QC_sum_fields
	var_pop: app_collection_management_QC_var_pop_fields
	var_samp: app_collection_management_QC_var_samp_fields
	variance: app_collection_management_QC_variance_fields
}

"aggregate avg on columns"
type app_collection_management_QC_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_collection_management_QC_max_fields {
	assignee_profile_id: uuid
	collection_id: uuid
	comment: String
	created_at: timestamptz
	id: Int
	updated_at: timestamptz
}

"aggregate min on columns"
type app_collection_management_QC_min_fields {
	assignee_profile_id: uuid
	collection_id: uuid
	comment: String
	created_at: timestamptz
	id: Int
	updated_at: timestamptz
}

"response of any mutation on the table \"app.collection_management_QC\""
type app_collection_management_QC_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_collection_management_QC!]!
}

"aggregate stddev on columns"
type app_collection_management_QC_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_collection_management_QC_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_collection_management_QC_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_collection_management_QC_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_collection_management_QC_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_collection_management_QC_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_collection_management_QC_variance_fields {
	id: Float
}

"aggregated selection of \"app.collection_management\""
type app_collection_management_aggregate {
	aggregate: app_collection_management_aggregate_fields
	nodes: [app_collection_management!]!
}

"aggregate fields of \"app.collection_management\""
type app_collection_management_aggregate_fields {
	avg: app_collection_management_avg_fields
	count(columns: [app_collection_management_select_column!], distinct: Boolean): Int
	max: app_collection_management_max_fields
	min: app_collection_management_min_fields
	stddev: app_collection_management_stddev_fields
	stddev_pop: app_collection_management_stddev_pop_fields
	stddev_samp: app_collection_management_stddev_samp_fields
	sum: app_collection_management_sum_fields
	var_pop: app_collection_management_var_pop_fields
	var_samp: app_collection_management_var_samp_fields
	variance: app_collection_management_variance_fields
}

"aggregate avg on columns"
type app_collection_management_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_collection_management_max_fields {
	collection_id: uuid
	created_at: timestamptz
	current_status: String
	id: Int
	manager_profile_id: uuid
	note: String
	status_valid_until: timestamptz
	updated_at: timestamptz
}

"aggregate min on columns"
type app_collection_management_min_fields {
	collection_id: uuid
	created_at: timestamptz
	current_status: String
	id: Int
	manager_profile_id: uuid
	note: String
	status_valid_until: timestamptz
	updated_at: timestamptz
}

"response of any mutation on the table \"app.collection_management\""
type app_collection_management_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_collection_management!]!
}

"aggregate stddev on columns"
type app_collection_management_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_collection_management_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_collection_management_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_collection_management_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_collection_management_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_collection_management_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_collection_management_variance_fields {
	id: Float
}

"columns and relationships of \"app.collection_marcom_klascement_view\""
type app_collection_marcom_klascement_view {
	collection_id: uuid
	count: bigint
}

"aggregated selection of \"app.collection_marcom_klascement_view\""
type app_collection_marcom_klascement_view_aggregate {
	aggregate: app_collection_marcom_klascement_view_aggregate_fields
	nodes: [app_collection_marcom_klascement_view!]!
}

"aggregate fields of \"app.collection_marcom_klascement_view\""
type app_collection_marcom_klascement_view_aggregate_fields {
	avg: app_collection_marcom_klascement_view_avg_fields
	count(columns: [app_collection_marcom_klascement_view_select_column!], distinct: Boolean): Int
	max: app_collection_marcom_klascement_view_max_fields
	min: app_collection_marcom_klascement_view_min_fields
	stddev: app_collection_marcom_klascement_view_stddev_fields
	stddev_pop: app_collection_marcom_klascement_view_stddev_pop_fields
	stddev_samp: app_collection_marcom_klascement_view_stddev_samp_fields
	sum: app_collection_marcom_klascement_view_sum_fields
	var_pop: app_collection_marcom_klascement_view_var_pop_fields
	var_samp: app_collection_marcom_klascement_view_var_samp_fields
	variance: app_collection_marcom_klascement_view_variance_fields
}

"aggregate avg on columns"
type app_collection_marcom_klascement_view_avg_fields {
	count: Float
}

"aggregate max on columns"
type app_collection_marcom_klascement_view_max_fields {
	collection_id: uuid
	count: bigint
}

"aggregate min on columns"
type app_collection_marcom_klascement_view_min_fields {
	collection_id: uuid
	count: bigint
}

"aggregate stddev on columns"
type app_collection_marcom_klascement_view_stddev_fields {
	count: Float
}

"aggregate stddev_pop on columns"
type app_collection_marcom_klascement_view_stddev_pop_fields {
	count: Float
}

"aggregate stddev_samp on columns"
type app_collection_marcom_klascement_view_stddev_samp_fields {
	count: Float
}

"aggregate sum on columns"
type app_collection_marcom_klascement_view_sum_fields {
	count: bigint
}

"aggregate var_pop on columns"
type app_collection_marcom_klascement_view_var_pop_fields {
	count: Float
}

"aggregate var_samp on columns"
type app_collection_marcom_klascement_view_var_samp_fields {
	count: Float
}

"aggregate variance on columns"
type app_collection_marcom_klascement_view_variance_fields {
	count: Float
}

"""
Waar en wanneer is een collectie (elders) gebruikt voor marketing en communicatiedoeleinden.


columns and relationships of "app.collection_marcom_log"
"""
type app_collection_marcom_log {
	channel_name: String
	channel_type: String
	"An object relationship"
	collection: app_collections!
	collection_id: uuid!
	created_at: timestamptz!
	external_link: String
	id: Int!
	"An object relationship"
	parent_collection: app_collections
	parent_collection_id: uuid
	publish_date: timestamptz
	updated_at: timestamptz!
}

"aggregated selection of \"app.collection_marcom_log\""
type app_collection_marcom_log_aggregate {
	aggregate: app_collection_marcom_log_aggregate_fields
	nodes: [app_collection_marcom_log!]!
}

"aggregate fields of \"app.collection_marcom_log\""
type app_collection_marcom_log_aggregate_fields {
	avg: app_collection_marcom_log_avg_fields
	count(columns: [app_collection_marcom_log_select_column!], distinct: Boolean): Int
	max: app_collection_marcom_log_max_fields
	min: app_collection_marcom_log_min_fields
	stddev: app_collection_marcom_log_stddev_fields
	stddev_pop: app_collection_marcom_log_stddev_pop_fields
	stddev_samp: app_collection_marcom_log_stddev_samp_fields
	sum: app_collection_marcom_log_sum_fields
	var_pop: app_collection_marcom_log_var_pop_fields
	var_samp: app_collection_marcom_log_var_samp_fields
	variance: app_collection_marcom_log_variance_fields
}

"aggregate avg on columns"
type app_collection_marcom_log_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_collection_marcom_log_max_fields {
	channel_name: String
	channel_type: String
	collection_id: uuid
	created_at: timestamptz
	external_link: String
	id: Int
	parent_collection_id: uuid
	publish_date: timestamptz
	updated_at: timestamptz
}

"aggregate min on columns"
type app_collection_marcom_log_min_fields {
	channel_name: String
	channel_type: String
	collection_id: uuid
	created_at: timestamptz
	external_link: String
	id: Int
	parent_collection_id: uuid
	publish_date: timestamptz
	updated_at: timestamptz
}

"response of any mutation on the table \"app.collection_marcom_log\""
type app_collection_marcom_log_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_collection_marcom_log!]!
}

"aggregate stddev on columns"
type app_collection_marcom_log_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_collection_marcom_log_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_collection_marcom_log_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_collection_marcom_log_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_collection_marcom_log_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_collection_marcom_log_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_collection_marcom_log_variance_fields {
	id: Float
}

"""
Elke collectie heeft een enkel opmerkingenveld.


columns and relationships of "app.collection_marcom_notes"
"""
type app_collection_marcom_notes {
	"An object relationship"
	collection: app_collections!
	collection_id: uuid!
	created_at: timestamptz!
	id: Int!
	note: String
	updated_at: timestamptz!
}

"aggregated selection of \"app.collection_marcom_notes\""
type app_collection_marcom_notes_aggregate {
	aggregate: app_collection_marcom_notes_aggregate_fields
	nodes: [app_collection_marcom_notes!]!
}

"aggregate fields of \"app.collection_marcom_notes\""
type app_collection_marcom_notes_aggregate_fields {
	avg: app_collection_marcom_notes_avg_fields
	count(columns: [app_collection_marcom_notes_select_column!], distinct: Boolean): Int
	max: app_collection_marcom_notes_max_fields
	min: app_collection_marcom_notes_min_fields
	stddev: app_collection_marcom_notes_stddev_fields
	stddev_pop: app_collection_marcom_notes_stddev_pop_fields
	stddev_samp: app_collection_marcom_notes_stddev_samp_fields
	sum: app_collection_marcom_notes_sum_fields
	var_pop: app_collection_marcom_notes_var_pop_fields
	var_samp: app_collection_marcom_notes_var_samp_fields
	variance: app_collection_marcom_notes_variance_fields
}

"aggregate avg on columns"
type app_collection_marcom_notes_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_collection_marcom_notes_max_fields {
	collection_id: uuid
	created_at: timestamptz
	id: Int
	note: String
	updated_at: timestamptz
}

"aggregate min on columns"
type app_collection_marcom_notes_min_fields {
	collection_id: uuid
	created_at: timestamptz
	id: Int
	note: String
	updated_at: timestamptz
}

"response of any mutation on the table \"app.collection_marcom_notes\""
type app_collection_marcom_notes_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_collection_marcom_notes!]!
}

"aggregate stddev on columns"
type app_collection_marcom_notes_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_collection_marcom_notes_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_collection_marcom_notes_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_collection_marcom_notes_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_collection_marcom_notes_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_collection_marcom_notes_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_collection_marcom_notes_variance_fields {
	id: Float
}

"columns and relationships of \"app.collection_marcom_overview\""
type app_collection_marcom_overview {
	channel_name: String
	channel_type: String
	collection_id: uuid
	created_at: timestamptz
	is_public: Boolean
	klascement: Boolean
	"An array relationship"
	labels(
		"distinct select on columns"
		distinct_on: [app_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_labels_order_by!]
		"filter the rows returned"
		where: app_collection_labels_bool_exp
	): [app_collection_labels!]!
	"An aggregated array relationship"
	labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_labels_order_by!]
		"filter the rows returned"
		where: app_collection_labels_bool_exp
	): app_collection_labels_aggregate!
	"An object relationship"
	last_editor: shared_user_names
	last_marcom_date: timestamptz
	lom_classification("JSON select path" path: String): jsonb
	lom_context("JSON select path" path: String): jsonb
	"An object relationship"
	owner: users_summary_view
	owner_profile_id: uuid
	parent_collection_id: uuid
	title: String
	type_id: Int
	updated_at: timestamptz
	updated_by_profile_id: uuid
}

"aggregated selection of \"app.collection_marcom_overview\""
type app_collection_marcom_overview_aggregate {
	aggregate: app_collection_marcom_overview_aggregate_fields
	nodes: [app_collection_marcom_overview!]!
}

"aggregate fields of \"app.collection_marcom_overview\""
type app_collection_marcom_overview_aggregate_fields {
	avg: app_collection_marcom_overview_avg_fields
	count(columns: [app_collection_marcom_overview_select_column!], distinct: Boolean): Int
	max: app_collection_marcom_overview_max_fields
	min: app_collection_marcom_overview_min_fields
	stddev: app_collection_marcom_overview_stddev_fields
	stddev_pop: app_collection_marcom_overview_stddev_pop_fields
	stddev_samp: app_collection_marcom_overview_stddev_samp_fields
	sum: app_collection_marcom_overview_sum_fields
	var_pop: app_collection_marcom_overview_var_pop_fields
	var_samp: app_collection_marcom_overview_var_samp_fields
	variance: app_collection_marcom_overview_variance_fields
}

"aggregate avg on columns"
type app_collection_marcom_overview_avg_fields {
	type_id: Float
}

"aggregate max on columns"
type app_collection_marcom_overview_max_fields {
	channel_name: String
	channel_type: String
	collection_id: uuid
	created_at: timestamptz
	last_marcom_date: timestamptz
	owner_profile_id: uuid
	parent_collection_id: uuid
	title: String
	type_id: Int
	updated_at: timestamptz
	updated_by_profile_id: uuid
}

"aggregate min on columns"
type app_collection_marcom_overview_min_fields {
	channel_name: String
	channel_type: String
	collection_id: uuid
	created_at: timestamptz
	last_marcom_date: timestamptz
	owner_profile_id: uuid
	parent_collection_id: uuid
	title: String
	type_id: Int
	updated_at: timestamptz
	updated_by_profile_id: uuid
}

"aggregate stddev on columns"
type app_collection_marcom_overview_stddev_fields {
	type_id: Float
}

"aggregate stddev_pop on columns"
type app_collection_marcom_overview_stddev_pop_fields {
	type_id: Float
}

"aggregate stddev_samp on columns"
type app_collection_marcom_overview_stddev_samp_fields {
	type_id: Float
}

"aggregate sum on columns"
type app_collection_marcom_overview_sum_fields {
	type_id: Int
}

"aggregate var_pop on columns"
type app_collection_marcom_overview_var_pop_fields {
	type_id: Float
}

"aggregate var_samp on columns"
type app_collection_marcom_overview_var_samp_fields {
	type_id: Float
}

"aggregate variance on columns"
type app_collection_marcom_overview_variance_fields {
	type_id: Float
}

"columns and relationships of \"app.collection_plays\""
type app_collection_plays {
	collection_uuid: uuid!
	count: Int
	created_at: timestamptz!
	id: Int!
	"An object relationship"
	playedCollection: app_collections
	updated_at: timestamptz!
}

"aggregated selection of \"app.collection_plays\""
type app_collection_plays_aggregate {
	aggregate: app_collection_plays_aggregate_fields
	nodes: [app_collection_plays!]!
}

"aggregate fields of \"app.collection_plays\""
type app_collection_plays_aggregate_fields {
	avg: app_collection_plays_avg_fields
	count(columns: [app_collection_plays_select_column!], distinct: Boolean): Int
	max: app_collection_plays_max_fields
	min: app_collection_plays_min_fields
	stddev: app_collection_plays_stddev_fields
	stddev_pop: app_collection_plays_stddev_pop_fields
	stddev_samp: app_collection_plays_stddev_samp_fields
	sum: app_collection_plays_sum_fields
	var_pop: app_collection_plays_var_pop_fields
	var_samp: app_collection_plays_var_samp_fields
	variance: app_collection_plays_variance_fields
}

"aggregate avg on columns"
type app_collection_plays_avg_fields {
	count: Float
	id: Float
}

"aggregate max on columns"
type app_collection_plays_max_fields {
	collection_uuid: uuid
	count: Int
	created_at: timestamptz
	id: Int
	updated_at: timestamptz
}

"aggregate min on columns"
type app_collection_plays_min_fields {
	collection_uuid: uuid
	count: Int
	created_at: timestamptz
	id: Int
	updated_at: timestamptz
}

"response of any mutation on the table \"app.collection_plays\""
type app_collection_plays_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_collection_plays!]!
}

"aggregate stddev on columns"
type app_collection_plays_stddev_fields {
	count: Float
	id: Float
}

"aggregate stddev_pop on columns"
type app_collection_plays_stddev_pop_fields {
	count: Float
	id: Float
}

"aggregate stddev_samp on columns"
type app_collection_plays_stddev_samp_fields {
	count: Float
	id: Float
}

"aggregate sum on columns"
type app_collection_plays_sum_fields {
	count: Int
	id: Int
}

"aggregate var_pop on columns"
type app_collection_plays_var_pop_fields {
	count: Float
	id: Float
}

"aggregate var_samp on columns"
type app_collection_plays_var_samp_fields {
	count: Float
	id: Float
}

"aggregate variance on columns"
type app_collection_plays_variance_fields {
	count: Float
	id: Float
}

"columns and relationships of \"app.collection_qc_overview\""
type app_collection_qc_overview {
	collection_id: uuid
	created_at: timestamptz
	is_public: Boolean
	"An array relationship"
	labels(
		"distinct select on columns"
		distinct_on: [app_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_labels_order_by!]
		"filter the rows returned"
		where: app_collection_labels_bool_exp
	): [app_collection_labels!]!
	"An aggregated array relationship"
	labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_labels_order_by!]
		"filter the rows returned"
		where: app_collection_labels_bool_exp
	): app_collection_labels_aggregate!
	"An object relationship"
	last_editor: shared_user_names
	lom_classification("JSON select path" path: String): jsonb
	lom_context("JSON select path" path: String): jsonb
	mgmt_eind_check_date: timestamptz
	mgmt_language_check: Boolean
	mgmt_quality_check: Boolean
	"An object relationship"
	owner: users_summary_view
	owner_profile_id: uuid
	title: String
	type_id: Int
	updated_at: timestamptz
	updated_by_profile_id: uuid
}

"aggregated selection of \"app.collection_qc_overview\""
type app_collection_qc_overview_aggregate {
	aggregate: app_collection_qc_overview_aggregate_fields
	nodes: [app_collection_qc_overview!]!
}

"aggregate fields of \"app.collection_qc_overview\""
type app_collection_qc_overview_aggregate_fields {
	avg: app_collection_qc_overview_avg_fields
	count(columns: [app_collection_qc_overview_select_column!], distinct: Boolean): Int
	max: app_collection_qc_overview_max_fields
	min: app_collection_qc_overview_min_fields
	stddev: app_collection_qc_overview_stddev_fields
	stddev_pop: app_collection_qc_overview_stddev_pop_fields
	stddev_samp: app_collection_qc_overview_stddev_samp_fields
	sum: app_collection_qc_overview_sum_fields
	var_pop: app_collection_qc_overview_var_pop_fields
	var_samp: app_collection_qc_overview_var_samp_fields
	variance: app_collection_qc_overview_variance_fields
}

"aggregate avg on columns"
type app_collection_qc_overview_avg_fields {
	type_id: Float
}

"aggregate max on columns"
type app_collection_qc_overview_max_fields {
	collection_id: uuid
	created_at: timestamptz
	mgmt_eind_check_date: timestamptz
	owner_profile_id: uuid
	title: String
	type_id: Int
	updated_at: timestamptz
	updated_by_profile_id: uuid
}

"aggregate min on columns"
type app_collection_qc_overview_min_fields {
	collection_id: uuid
	created_at: timestamptz
	mgmt_eind_check_date: timestamptz
	owner_profile_id: uuid
	title: String
	type_id: Int
	updated_at: timestamptz
	updated_by_profile_id: uuid
}

"aggregate stddev on columns"
type app_collection_qc_overview_stddev_fields {
	type_id: Float
}

"aggregate stddev_pop on columns"
type app_collection_qc_overview_stddev_pop_fields {
	type_id: Float
}

"aggregate stddev_samp on columns"
type app_collection_qc_overview_stddev_samp_fields {
	type_id: Float
}

"aggregate sum on columns"
type app_collection_qc_overview_sum_fields {
	type_id: Int
}

"aggregate var_pop on columns"
type app_collection_qc_overview_var_pop_fields {
	type_id: Float
}

"aggregate var_samp on columns"
type app_collection_qc_overview_var_samp_fields {
	type_id: Float
}

"aggregate variance on columns"
type app_collection_qc_overview_variance_fields {
	type_id: Float
}

"""
This table holds relationships between collections as a triple, e.g.: collection A is a copy of collection B.


columns and relationships of "app.collection_relations"
"""
type app_collection_relations {
	created_at: timestamptz
	"An object relationship"
	enum_relation_type: lookup_enum_relation_types!
	id: Int!
	object: uuid!
	"An object relationship"
	origin: app_collections
	predicate: lookup_enum_relation_types_enum!
	subject: uuid!
	updated_at: timestamptz
}

"aggregated selection of \"app.collection_relations\""
type app_collection_relations_aggregate {
	aggregate: app_collection_relations_aggregate_fields
	nodes: [app_collection_relations!]!
}

"aggregate fields of \"app.collection_relations\""
type app_collection_relations_aggregate_fields {
	avg: app_collection_relations_avg_fields
	count(columns: [app_collection_relations_select_column!], distinct: Boolean): Int
	max: app_collection_relations_max_fields
	min: app_collection_relations_min_fields
	stddev: app_collection_relations_stddev_fields
	stddev_pop: app_collection_relations_stddev_pop_fields
	stddev_samp: app_collection_relations_stddev_samp_fields
	sum: app_collection_relations_sum_fields
	var_pop: app_collection_relations_var_pop_fields
	var_samp: app_collection_relations_var_samp_fields
	variance: app_collection_relations_variance_fields
}

"aggregate avg on columns"
type app_collection_relations_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_collection_relations_max_fields {
	created_at: timestamptz
	id: Int
	object: uuid
	subject: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type app_collection_relations_min_fields {
	created_at: timestamptz
	id: Int
	object: uuid
	subject: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"app.collection_relations\""
type app_collection_relations_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_collection_relations!]!
}

"aggregate stddev on columns"
type app_collection_relations_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_collection_relations_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_collection_relations_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_collection_relations_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_collection_relations_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_collection_relations_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_collection_relations_variance_fields {
	id: Float
}

"columns and relationships of \"app.collection_relations_view\""
type app_collection_relations_view {
	object: uuid
	"An object relationship"
	object_meta: app_collections
	predicate: String
	subject: uuid
}

"aggregated selection of \"app.collection_relations_view\""
type app_collection_relations_view_aggregate {
	aggregate: app_collection_relations_view_aggregate_fields
	nodes: [app_collection_relations_view!]!
}

"aggregate fields of \"app.collection_relations_view\""
type app_collection_relations_view_aggregate_fields {
	count(columns: [app_collection_relations_view_select_column!], distinct: Boolean): Int
	max: app_collection_relations_view_max_fields
	min: app_collection_relations_view_min_fields
}

"aggregate max on columns"
type app_collection_relations_view_max_fields {
	object: uuid
	predicate: String
	subject: uuid
}

"aggregate min on columns"
type app_collection_relations_view_min_fields {
	object: uuid
	predicate: String
	subject: uuid
}

"columns and relationships of \"app.collection_views\""
type app_collection_views {
	collection_uuid: uuid!
	count: Int
	created_at: timestamptz!
	id: Int!
	updated_at: timestamptz!
	"An object relationship"
	viewedCollection: app_collections
}

"aggregated selection of \"app.collection_views\""
type app_collection_views_aggregate {
	aggregate: app_collection_views_aggregate_fields
	nodes: [app_collection_views!]!
}

"aggregate fields of \"app.collection_views\""
type app_collection_views_aggregate_fields {
	avg: app_collection_views_avg_fields
	count(columns: [app_collection_views_select_column!], distinct: Boolean): Int
	max: app_collection_views_max_fields
	min: app_collection_views_min_fields
	stddev: app_collection_views_stddev_fields
	stddev_pop: app_collection_views_stddev_pop_fields
	stddev_samp: app_collection_views_stddev_samp_fields
	sum: app_collection_views_sum_fields
	var_pop: app_collection_views_var_pop_fields
	var_samp: app_collection_views_var_samp_fields
	variance: app_collection_views_variance_fields
}

"aggregate avg on columns"
type app_collection_views_avg_fields {
	count: Float
	id: Float
}

"aggregate max on columns"
type app_collection_views_max_fields {
	collection_uuid: uuid
	count: Int
	created_at: timestamptz
	id: Int
	updated_at: timestamptz
}

"aggregate min on columns"
type app_collection_views_min_fields {
	collection_uuid: uuid
	count: Int
	created_at: timestamptz
	id: Int
	updated_at: timestamptz
}

"response of any mutation on the table \"app.collection_views\""
type app_collection_views_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_collection_views!]!
}

"aggregate stddev on columns"
type app_collection_views_stddev_fields {
	count: Float
	id: Float
}

"aggregate stddev_pop on columns"
type app_collection_views_stddev_pop_fields {
	count: Float
	id: Float
}

"aggregate stddev_samp on columns"
type app_collection_views_stddev_samp_fields {
	count: Float
	id: Float
}

"aggregate sum on columns"
type app_collection_views_sum_fields {
	count: Int
	id: Int
}

"aggregate var_pop on columns"
type app_collection_views_var_pop_fields {
	count: Float
	id: Float
}

"aggregate var_samp on columns"
type app_collection_views_var_samp_fields {
	count: Float
	id: Float
}

"aggregate variance on columns"
type app_collection_views_variance_fields {
	count: Float
	id: Float
}

"columns and relationships of \"app.collections\""
type app_collections {
	"An array relationship"
	QC(
		"distinct select on columns"
		distinct_on: [app_collection_management_QC_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_management_QC_order_by!]
		"filter the rows returned"
		where: app_collection_management_QC_bool_exp
	): [app_collection_management_QC!]!
	"An aggregated array relationship"
	QC_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_management_QC_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_management_QC_order_by!]
		"filter the rows returned"
		where: app_collection_management_QC_bool_exp
	): app_collection_management_QC_aggregate!
	author_external_uid: Int
	author_uid: uuid
	avo1_id: String
	briefing_id: String
	"An array relationship"
	collection_bookmarks(
		"distinct select on columns"
		distinct_on: [app_collection_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_bookmarks_order_by!]
		"filter the rows returned"
		where: app_collection_bookmarks_bool_exp
	): [app_collection_bookmarks!]!
	"An aggregated array relationship"
	collection_bookmarks_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_bookmarks_order_by!]
		"filter the rows returned"
		where: app_collection_bookmarks_bool_exp
	): app_collection_bookmarks_aggregate!
	collection_fragment_ids("JSON select path" path: String): jsonb
	"An array relationship"
	collection_fragments(
		"distinct select on columns"
		distinct_on: [app_collection_fragments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_fragments_order_by!]
		"filter the rows returned"
		where: app_collection_fragments_bool_exp
	): [app_collection_fragments!]!
	"An aggregated array relationship"
	collection_fragments_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_fragments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_fragments_order_by!]
		"filter the rows returned"
		where: app_collection_fragments_bool_exp
	): app_collection_fragments_aggregate!
	"An array relationship"
	collection_labels(
		"distinct select on columns"
		distinct_on: [app_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_labels_order_by!]
		"filter the rows returned"
		where: app_collection_labels_bool_exp
	): [app_collection_labels!]!
	"An aggregated array relationship"
	collection_labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_labels_order_by!]
		"filter the rows returned"
		where: app_collection_labels_bool_exp
	): app_collection_labels_aggregate!
	"An object relationship"
	counts: app_collection_counts
	created_at: timestamptz!
	depublish_at: timestamptz
	description: String
	description_long: String
	external_id: String
	"An object relationship"
	has_klascement: app_collection_marcom_klascement_view
	id: uuid!
	is_deleted: Boolean!
	is_managed: Boolean
	is_public: Boolean!
	"An object relationship"
	last_editor: users_summary_view
	lom_classification("JSON select path" path: String): jsonb
	lom_context("JSON select path" path: String): jsonb
	lom_intendedenduserrole("JSON select path" path: String): jsonb
	lom_keywords("JSON select path" path: String): jsonb
	lom_languages("JSON select path" path: String): jsonb
	lom_typicalagerange("JSON select path" path: String): jsonb
	"An object relationship"
	management: app_collection_management
	"An array relationship"
	marcom(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_log_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_log_bool_exp
	): [app_collection_marcom_log!]!
	"An aggregated array relationship"
	marcom_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_log_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_log_bool_exp
	): app_collection_marcom_log_aggregate!
	"An object relationship"
	marcom_note: app_collection_marcom_notes
	"An array relationship"
	marcom_notes(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_notes_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_notes_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_notes_bool_exp
	): [app_collection_marcom_notes!]!
	"An aggregated array relationship"
	marcom_notes_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_notes_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_notes_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_notes_bool_exp
	): app_collection_marcom_notes_aggregate!
	note: String
	"An object relationship"
	organisation: shared_organisations
	organisation_id: String
	"An object relationship"
	owner: users_summary_view
	"Het profiel van de eigenaar van de collectie."
	owner_profile_id: uuid
	"An array relationship"
	play_counts(
		"distinct select on columns"
		distinct_on: [app_collection_plays_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_plays_order_by!]
		"filter the rows returned"
		where: app_collection_plays_bool_exp
	): [app_collection_plays!]!
	"An aggregated array relationship"
	play_counts_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_plays_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_plays_order_by!]
		"filter the rows returned"
		where: app_collection_plays_bool_exp
	): app_collection_plays_aggregate!
	"An object relationship"
	profile: users_profiles
	publish_at: timestamptz
	published_at: timestamptz
	"An array relationship"
	relations(
		"distinct select on columns"
		distinct_on: [app_collection_relations_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_relations_view_order_by!]
		"filter the rows returned"
		where: app_collection_relations_view_bool_exp
	): [app_collection_relations_view!]!
	"An aggregated array relationship"
	relations_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_relations_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_relations_view_order_by!]
		"filter the rows returned"
		where: app_collection_relations_view_bool_exp
	): app_collection_relations_view_aggregate!
	seo_image_path: String
	thumbnail_path: String
	title: String!
	"An object relationship"
	type: shared_types!
	type_id: Int!
	updated_at: timestamptz!
	"An object relationship"
	updated_by: users_profiles
	updated_by_profile_id: uuid
	"An array relationship"
	usage_counts(
		"distinct select on columns"
		distinct_on: [app_usage_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_usage_counts_order_by!]
		"filter the rows returned"
		where: app_usage_counts_bool_exp
	): [app_usage_counts!]!
	"An aggregated array relationship"
	usage_counts_aggregate(
		"distinct select on columns"
		distinct_on: [app_usage_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_usage_counts_order_by!]
		"filter the rows returned"
		where: app_usage_counts_bool_exp
	): app_usage_counts_aggregate!
	"An array relationship"
	view_counts(
		"distinct select on columns"
		distinct_on: [app_collection_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_views_order_by!]
		"filter the rows returned"
		where: app_collection_views_bool_exp
	): [app_collection_views!]!
	"An aggregated array relationship"
	view_counts_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_views_order_by!]
		"filter the rows returned"
		where: app_collection_views_bool_exp
	): app_collection_views_aggregate!
}

"aggregated selection of \"app.collections\""
type app_collections_aggregate {
	aggregate: app_collections_aggregate_fields
	nodes: [app_collections!]!
}

"aggregate fields of \"app.collections\""
type app_collections_aggregate_fields {
	avg: app_collections_avg_fields
	count(columns: [app_collections_select_column!], distinct: Boolean): Int
	max: app_collections_max_fields
	min: app_collections_min_fields
	stddev: app_collections_stddev_fields
	stddev_pop: app_collections_stddev_pop_fields
	stddev_samp: app_collections_stddev_samp_fields
	sum: app_collections_sum_fields
	var_pop: app_collections_var_pop_fields
	var_samp: app_collections_var_samp_fields
	variance: app_collections_variance_fields
}

"aggregate avg on columns"
type app_collections_avg_fields {
	author_external_uid: Float
	type_id: Float
}

"aggregate max on columns"
type app_collections_max_fields {
	author_external_uid: Int
	author_uid: uuid
	avo1_id: String
	briefing_id: String
	created_at: timestamptz
	depublish_at: timestamptz
	description: String
	description_long: String
	external_id: String
	id: uuid
	note: String
	organisation_id: String
	owner_profile_id: uuid
	publish_at: timestamptz
	published_at: timestamptz
	seo_image_path: String
	thumbnail_path: String
	title: String
	type_id: Int
	updated_at: timestamptz
	updated_by_profile_id: uuid
}

"aggregate min on columns"
type app_collections_min_fields {
	author_external_uid: Int
	author_uid: uuid
	avo1_id: String
	briefing_id: String
	created_at: timestamptz
	depublish_at: timestamptz
	description: String
	description_long: String
	external_id: String
	id: uuid
	note: String
	organisation_id: String
	owner_profile_id: uuid
	publish_at: timestamptz
	published_at: timestamptz
	seo_image_path: String
	thumbnail_path: String
	title: String
	type_id: Int
	updated_at: timestamptz
	updated_by_profile_id: uuid
}

"response of any mutation on the table \"app.collections\""
type app_collections_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_collections!]!
}

"aggregate stddev on columns"
type app_collections_stddev_fields {
	author_external_uid: Float
	type_id: Float
}

"aggregate stddev_pop on columns"
type app_collections_stddev_pop_fields {
	author_external_uid: Float
	type_id: Float
}

"aggregate stddev_samp on columns"
type app_collections_stddev_samp_fields {
	author_external_uid: Float
	type_id: Float
}

"aggregate sum on columns"
type app_collections_sum_fields {
	author_external_uid: Int
	type_id: Int
}

"aggregate var_pop on columns"
type app_collections_var_pop_fields {
	author_external_uid: Float
	type_id: Float
}

"aggregate var_samp on columns"
type app_collections_var_samp_fields {
	author_external_uid: Float
	type_id: Float
}

"aggregate variance on columns"
type app_collections_variance_fields {
	author_external_uid: Float
	type_id: Float
}

"columns and relationships of \"app.content\""
type app_content {
	"An array relationship"
	contentBlockssBycontentId(
		"distinct select on columns"
		distinct_on: [app_content_blocks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_blocks_order_by!]
		"filter the rows returned"
		where: app_content_blocks_bool_exp
	): [app_content_blocks!]!
	"An aggregated array relationship"
	contentBlockssBycontentId_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_blocks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_blocks_order_by!]
		"filter the rows returned"
		where: app_content_blocks_bool_exp
	): app_content_blocks_aggregate!
	"An array relationship"
	content_content_labels(
		"distinct select on columns"
		distinct_on: [app_content_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_content_labels_order_by!]
		"filter the rows returned"
		where: app_content_content_labels_bool_exp
	): [app_content_content_labels!]!
	"An aggregated array relationship"
	content_content_labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_content_labels_order_by!]
		"filter the rows returned"
		where: app_content_content_labels_bool_exp
	): app_content_content_labels_aggregate!
	"An array relationship"
	content_nav_elements(
		"distinct select on columns"
		distinct_on: [app_content_nav_elements_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_nav_elements_order_by!]
		"filter the rows returned"
		where: app_content_nav_elements_bool_exp
	): [app_content_nav_elements!]!
	"An aggregated array relationship"
	content_nav_elements_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_nav_elements_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_nav_elements_order_by!]
		"filter the rows returned"
		where: app_content_nav_elements_bool_exp
	): app_content_nav_elements_aggregate!
	content_type: lookup_enum_content_types_enum!
	content_width: String!
	created_at: timestamptz!
	depublish_at: timestamptz
	description: String
	"An object relationship"
	enum_content_type: lookup_enum_content_types!
	header_path: String
	id: Int!
	is_deleted: Boolean!
	is_protected: Boolean!
	is_public: Boolean
	meta_description: String
	"An object relationship"
	owner: users_summary_view
	"slug van de pagina"
	path: String
	"An object relationship"
	profile: users_profiles
	publish_at: timestamptz
	published_at: timestamptz
	seo_description: String
	seo_image_path: String
	seo_keywords: String
	seo_title: String
	thumbnail_path: String
	title: String!
	"An object relationship"
	title_lower: app_content_lower_title
	updated_at: timestamptz
	"An object relationship"
	updated_by: users_summary_view
	updated_by_profile_id: uuid
	user_group_ids("JSON select path" path: String): jsonb
	user_profile_id: uuid
}

"aggregated selection of \"app.content\""
type app_content_aggregate {
	aggregate: app_content_aggregate_fields
	nodes: [app_content!]!
}

"aggregate fields of \"app.content\""
type app_content_aggregate_fields {
	avg: app_content_avg_fields
	count(columns: [app_content_select_column!], distinct: Boolean): Int
	max: app_content_max_fields
	min: app_content_min_fields
	stddev: app_content_stddev_fields
	stddev_pop: app_content_stddev_pop_fields
	stddev_samp: app_content_stddev_samp_fields
	sum: app_content_sum_fields
	var_pop: app_content_var_pop_fields
	var_samp: app_content_var_samp_fields
	variance: app_content_variance_fields
}

"columns and relationships of \"app.content_assets\""
type app_content_assets {
	content_asset_type_id: String!
	created_at: timestamptz
	description: String
	id: Int!
	label: String
	owner_id: String
	path: String!
	updated_at: timestamptz
}

"aggregated selection of \"app.content_assets\""
type app_content_assets_aggregate {
	aggregate: app_content_assets_aggregate_fields
	nodes: [app_content_assets!]!
}

"aggregate fields of \"app.content_assets\""
type app_content_assets_aggregate_fields {
	avg: app_content_assets_avg_fields
	count(columns: [app_content_assets_select_column!], distinct: Boolean): Int
	max: app_content_assets_max_fields
	min: app_content_assets_min_fields
	stddev: app_content_assets_stddev_fields
	stddev_pop: app_content_assets_stddev_pop_fields
	stddev_samp: app_content_assets_stddev_samp_fields
	sum: app_content_assets_sum_fields
	var_pop: app_content_assets_var_pop_fields
	var_samp: app_content_assets_var_samp_fields
	variance: app_content_assets_variance_fields
}

"aggregate avg on columns"
type app_content_assets_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_content_assets_max_fields {
	content_asset_type_id: String
	created_at: timestamptz
	description: String
	id: Int
	label: String
	owner_id: String
	path: String
	updated_at: timestamptz
}

"aggregate min on columns"
type app_content_assets_min_fields {
	content_asset_type_id: String
	created_at: timestamptz
	description: String
	id: Int
	label: String
	owner_id: String
	path: String
	updated_at: timestamptz
}

"response of any mutation on the table \"app.content_assets\""
type app_content_assets_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_content_assets!]!
}

"aggregate stddev on columns"
type app_content_assets_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_content_assets_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_content_assets_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_content_assets_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_content_assets_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_content_assets_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_content_assets_variance_fields {
	id: Float
}

"aggregate avg on columns"
type app_content_avg_fields {
	id: Float
}

"columns and relationships of \"app.content_blocks\""
type app_content_blocks {
	"An object relationship"
	contentBycontentId: app_content!
	content_block_type: lookup_enum_content_block_types_enum!
	content_id: Int!
	created_at: timestamptz!
	"An object relationship"
	enum_content_block_type: lookup_enum_content_block_types!
	id: Int!
	position: Int!
	updated_at: timestamptz!
	variables("JSON select path" path: String): jsonb
}

"aggregated selection of \"app.content_blocks\""
type app_content_blocks_aggregate {
	aggregate: app_content_blocks_aggregate_fields
	nodes: [app_content_blocks!]!
}

"aggregate fields of \"app.content_blocks\""
type app_content_blocks_aggregate_fields {
	avg: app_content_blocks_avg_fields
	count(columns: [app_content_blocks_select_column!], distinct: Boolean): Int
	max: app_content_blocks_max_fields
	min: app_content_blocks_min_fields
	stddev: app_content_blocks_stddev_fields
	stddev_pop: app_content_blocks_stddev_pop_fields
	stddev_samp: app_content_blocks_stddev_samp_fields
	sum: app_content_blocks_sum_fields
	var_pop: app_content_blocks_var_pop_fields
	var_samp: app_content_blocks_var_samp_fields
	variance: app_content_blocks_variance_fields
}

"aggregate avg on columns"
type app_content_blocks_avg_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate max on columns"
type app_content_blocks_max_fields {
	content_id: Int
	created_at: timestamptz
	id: Int
	position: Int
	updated_at: timestamptz
}

"aggregate min on columns"
type app_content_blocks_min_fields {
	content_id: Int
	created_at: timestamptz
	id: Int
	position: Int
	updated_at: timestamptz
}

"response of any mutation on the table \"app.content_blocks\""
type app_content_blocks_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_content_blocks!]!
}

"aggregate stddev on columns"
type app_content_blocks_stddev_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate stddev_pop on columns"
type app_content_blocks_stddev_pop_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate stddev_samp on columns"
type app_content_blocks_stddev_samp_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate sum on columns"
type app_content_blocks_sum_fields {
	content_id: Int
	id: Int
	position: Int
}

"aggregate var_pop on columns"
type app_content_blocks_var_pop_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate var_samp on columns"
type app_content_blocks_var_samp_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate variance on columns"
type app_content_blocks_variance_fields {
	content_id: Float
	id: Float
	position: Float
}

"columns and relationships of \"app.content_content_labels\""
type app_content_content_labels {
	"An object relationship"
	content: app_content!
	content_id: Int!
	"An object relationship"
	content_label: app_content_labels!
	created_at: timestamptz!
	id: Int!
	label_id: Int!
	updated_at: timestamptz!
}

"aggregated selection of \"app.content_content_labels\""
type app_content_content_labels_aggregate {
	aggregate: app_content_content_labels_aggregate_fields
	nodes: [app_content_content_labels!]!
}

"aggregate fields of \"app.content_content_labels\""
type app_content_content_labels_aggregate_fields {
	avg: app_content_content_labels_avg_fields
	count(columns: [app_content_content_labels_select_column!], distinct: Boolean): Int
	max: app_content_content_labels_max_fields
	min: app_content_content_labels_min_fields
	stddev: app_content_content_labels_stddev_fields
	stddev_pop: app_content_content_labels_stddev_pop_fields
	stddev_samp: app_content_content_labels_stddev_samp_fields
	sum: app_content_content_labels_sum_fields
	var_pop: app_content_content_labels_var_pop_fields
	var_samp: app_content_content_labels_var_samp_fields
	variance: app_content_content_labels_variance_fields
}

"aggregate avg on columns"
type app_content_content_labels_avg_fields {
	content_id: Float
	id: Float
	label_id: Float
}

"aggregate max on columns"
type app_content_content_labels_max_fields {
	content_id: Int
	created_at: timestamptz
	id: Int
	label_id: Int
	updated_at: timestamptz
}

"aggregate min on columns"
type app_content_content_labels_min_fields {
	content_id: Int
	created_at: timestamptz
	id: Int
	label_id: Int
	updated_at: timestamptz
}

"response of any mutation on the table \"app.content_content_labels\""
type app_content_content_labels_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_content_content_labels!]!
}

"aggregate stddev on columns"
type app_content_content_labels_stddev_fields {
	content_id: Float
	id: Float
	label_id: Float
}

"aggregate stddev_pop on columns"
type app_content_content_labels_stddev_pop_fields {
	content_id: Float
	id: Float
	label_id: Float
}

"aggregate stddev_samp on columns"
type app_content_content_labels_stddev_samp_fields {
	content_id: Float
	id: Float
	label_id: Float
}

"aggregate sum on columns"
type app_content_content_labels_sum_fields {
	content_id: Int
	id: Int
	label_id: Int
}

"aggregate var_pop on columns"
type app_content_content_labels_var_pop_fields {
	content_id: Float
	id: Float
	label_id: Float
}

"aggregate var_samp on columns"
type app_content_content_labels_var_samp_fields {
	content_id: Float
	id: Float
	label_id: Float
}

"aggregate variance on columns"
type app_content_content_labels_variance_fields {
	content_id: Float
	id: Float
	label_id: Float
}

"columns and relationships of \"app.content_labels\""
type app_content_labels {
	"An array relationship"
	content_content_labels(
		"distinct select on columns"
		distinct_on: [app_content_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_content_labels_order_by!]
		"filter the rows returned"
		where: app_content_content_labels_bool_exp
	): [app_content_content_labels!]!
	"An aggregated array relationship"
	content_content_labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_content_labels_order_by!]
		"filter the rows returned"
		where: app_content_content_labels_bool_exp
	): app_content_content_labels_aggregate!
	content_type: String!
	created_at: timestamptz!
	"An object relationship"
	enum_content_type: lookup_enum_content_types
	id: Int!
	label: String!
	link_to("JSON select path" path: String): jsonb
	updated_at: timestamptz!
}

"aggregated selection of \"app.content_labels\""
type app_content_labels_aggregate {
	aggregate: app_content_labels_aggregate_fields
	nodes: [app_content_labels!]!
}

"aggregate fields of \"app.content_labels\""
type app_content_labels_aggregate_fields {
	avg: app_content_labels_avg_fields
	count(columns: [app_content_labels_select_column!], distinct: Boolean): Int
	max: app_content_labels_max_fields
	min: app_content_labels_min_fields
	stddev: app_content_labels_stddev_fields
	stddev_pop: app_content_labels_stddev_pop_fields
	stddev_samp: app_content_labels_stddev_samp_fields
	sum: app_content_labels_sum_fields
	var_pop: app_content_labels_var_pop_fields
	var_samp: app_content_labels_var_samp_fields
	variance: app_content_labels_variance_fields
}

"aggregate avg on columns"
type app_content_labels_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_content_labels_max_fields {
	content_type: String
	created_at: timestamptz
	id: Int
	label: String
	updated_at: timestamptz
}

"aggregate min on columns"
type app_content_labels_min_fields {
	content_type: String
	created_at: timestamptz
	id: Int
	label: String
	updated_at: timestamptz
}

"response of any mutation on the table \"app.content_labels\""
type app_content_labels_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_content_labels!]!
}

"aggregate stddev on columns"
type app_content_labels_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_content_labels_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_content_labels_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_content_labels_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_content_labels_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_content_labels_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_content_labels_variance_fields {
	id: Float
}

"columns and relationships of \"app.content_lower_title\""
type app_content_lower_title {
	id: Int
	title_lower: String
}

"aggregated selection of \"app.content_lower_title\""
type app_content_lower_title_aggregate {
	aggregate: app_content_lower_title_aggregate_fields
	nodes: [app_content_lower_title!]!
}

"aggregate fields of \"app.content_lower_title\""
type app_content_lower_title_aggregate_fields {
	avg: app_content_lower_title_avg_fields
	count(columns: [app_content_lower_title_select_column!], distinct: Boolean): Int
	max: app_content_lower_title_max_fields
	min: app_content_lower_title_min_fields
	stddev: app_content_lower_title_stddev_fields
	stddev_pop: app_content_lower_title_stddev_pop_fields
	stddev_samp: app_content_lower_title_stddev_samp_fields
	sum: app_content_lower_title_sum_fields
	var_pop: app_content_lower_title_var_pop_fields
	var_samp: app_content_lower_title_var_samp_fields
	variance: app_content_lower_title_variance_fields
}

"aggregate avg on columns"
type app_content_lower_title_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_content_lower_title_max_fields {
	id: Int
	title_lower: String
}

"aggregate min on columns"
type app_content_lower_title_min_fields {
	id: Int
	title_lower: String
}

"response of any mutation on the table \"app.content_lower_title\""
type app_content_lower_title_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_content_lower_title!]!
}

"aggregate stddev on columns"
type app_content_lower_title_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_content_lower_title_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_content_lower_title_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_content_lower_title_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_content_lower_title_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_content_lower_title_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_content_lower_title_variance_fields {
	id: Float
}

"aggregate max on columns"
type app_content_max_fields {
	content_width: String
	created_at: timestamptz
	depublish_at: timestamptz
	description: String
	header_path: String
	id: Int
	meta_description: String
	path: String
	publish_at: timestamptz
	published_at: timestamptz
	seo_description: String
	seo_image_path: String
	seo_keywords: String
	seo_title: String
	thumbnail_path: String
	title: String
	updated_at: timestamptz
	updated_by_profile_id: uuid
	user_profile_id: uuid
}

"aggregate min on columns"
type app_content_min_fields {
	content_width: String
	created_at: timestamptz
	depublish_at: timestamptz
	description: String
	header_path: String
	id: Int
	meta_description: String
	path: String
	publish_at: timestamptz
	published_at: timestamptz
	seo_description: String
	seo_image_path: String
	seo_keywords: String
	seo_title: String
	thumbnail_path: String
	title: String
	updated_at: timestamptz
	updated_by_profile_id: uuid
	user_profile_id: uuid
}

"response of any mutation on the table \"app.content\""
type app_content_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_content!]!
}

"""
Beheer van de navigatiemenu-elementen.


columns and relationships of "app.content_nav_elements"
"""
type app_content_nav_elements {
	"An object relationship"
	content: app_content
	"id van de gelinkte content block pagina"
	content_id: Int
	content_path: String!
	content_type: String!
	created_at: timestamptz!
	"beschijving van het navigatie item. enkel zichtbaar voor beheerers"
	description: String
	icon_name: String!
	id: Int!
	label: String!
	"open in new tab of in zelfde tab"
	link_target: String
	"In welk navigatiemenu verschijnt dit, vb. navigatiemenu linksboven, of footermenu."
	placement: String!
	"volgorde van de links in de navigatie balk 0, 1, 2, 3"
	position: Int!
	tooltip: String
	updated_at: timestamptz!
	user_group_ids("JSON select path" path: String): jsonb
}

"aggregated selection of \"app.content_nav_elements\""
type app_content_nav_elements_aggregate {
	aggregate: app_content_nav_elements_aggregate_fields
	nodes: [app_content_nav_elements!]!
}

"aggregate fields of \"app.content_nav_elements\""
type app_content_nav_elements_aggregate_fields {
	avg: app_content_nav_elements_avg_fields
	count(columns: [app_content_nav_elements_select_column!], distinct: Boolean): Int
	max: app_content_nav_elements_max_fields
	min: app_content_nav_elements_min_fields
	stddev: app_content_nav_elements_stddev_fields
	stddev_pop: app_content_nav_elements_stddev_pop_fields
	stddev_samp: app_content_nav_elements_stddev_samp_fields
	sum: app_content_nav_elements_sum_fields
	var_pop: app_content_nav_elements_var_pop_fields
	var_samp: app_content_nav_elements_var_samp_fields
	variance: app_content_nav_elements_variance_fields
}

"aggregate avg on columns"
type app_content_nav_elements_avg_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate max on columns"
type app_content_nav_elements_max_fields {
	content_id: Int
	content_path: String
	content_type: String
	created_at: timestamptz
	description: String
	icon_name: String
	id: Int
	label: String
	link_target: String
	placement: String
	position: Int
	tooltip: String
	updated_at: timestamptz
}

"aggregate min on columns"
type app_content_nav_elements_min_fields {
	content_id: Int
	content_path: String
	content_type: String
	created_at: timestamptz
	description: String
	icon_name: String
	id: Int
	label: String
	link_target: String
	placement: String
	position: Int
	tooltip: String
	updated_at: timestamptz
}

"response of any mutation on the table \"app.content_nav_elements\""
type app_content_nav_elements_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_content_nav_elements!]!
}

"aggregate stddev on columns"
type app_content_nav_elements_stddev_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate stddev_pop on columns"
type app_content_nav_elements_stddev_pop_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate stddev_samp on columns"
type app_content_nav_elements_stddev_samp_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate sum on columns"
type app_content_nav_elements_sum_fields {
	content_id: Int
	id: Int
	position: Int
}

"aggregate var_pop on columns"
type app_content_nav_elements_var_pop_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate var_samp on columns"
type app_content_nav_elements_var_samp_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate variance on columns"
type app_content_nav_elements_variance_fields {
	content_id: Float
	id: Float
	position: Float
}

"aggregate stddev on columns"
type app_content_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_content_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_content_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_content_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_content_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_content_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_content_variance_fields {
	id: Float
}

"columns and relationships of \"app.interactive_tour\""
type app_interactive_tour {
	created_at: timestamp!
	id: Int!
	name: String
	page: String!
	steps("JSON select path" path: String): jsonb
	updated_at: timestamp!
}

"aggregated selection of \"app.interactive_tour\""
type app_interactive_tour_aggregate {
	aggregate: app_interactive_tour_aggregate_fields
	nodes: [app_interactive_tour!]!
}

"aggregate fields of \"app.interactive_tour\""
type app_interactive_tour_aggregate_fields {
	avg: app_interactive_tour_avg_fields
	count(columns: [app_interactive_tour_select_column!], distinct: Boolean): Int
	max: app_interactive_tour_max_fields
	min: app_interactive_tour_min_fields
	stddev: app_interactive_tour_stddev_fields
	stddev_pop: app_interactive_tour_stddev_pop_fields
	stddev_samp: app_interactive_tour_stddev_samp_fields
	sum: app_interactive_tour_sum_fields
	var_pop: app_interactive_tour_var_pop_fields
	var_samp: app_interactive_tour_var_samp_fields
	variance: app_interactive_tour_variance_fields
}

"aggregate avg on columns"
type app_interactive_tour_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_interactive_tour_max_fields {
	created_at: timestamp
	id: Int
	name: String
	page: String
	updated_at: timestamp
}

"aggregate min on columns"
type app_interactive_tour_min_fields {
	created_at: timestamp
	id: Int
	name: String
	page: String
	updated_at: timestamp
}

"response of any mutation on the table \"app.interactive_tour\""
type app_interactive_tour_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_interactive_tour!]!
}

"aggregate stddev on columns"
type app_interactive_tour_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_interactive_tour_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_interactive_tour_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_interactive_tour_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_interactive_tour_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_interactive_tour_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_interactive_tour_variance_fields {
	id: Float
}

"columns and relationships of \"app.item_bookmarks\""
type app_item_bookmarks {
	"An object relationship"
	bookmarkedItem: app_item_meta
	created_at: timestamptz!
	id: Int!
	item_id: uuid!
	"An object relationship"
	profile: users_profiles!
	profile_id: uuid!
	updated_at: timestamptz!
}

"aggregated selection of \"app.item_bookmarks\""
type app_item_bookmarks_aggregate {
	aggregate: app_item_bookmarks_aggregate_fields
	nodes: [app_item_bookmarks!]!
}

"aggregate fields of \"app.item_bookmarks\""
type app_item_bookmarks_aggregate_fields {
	avg: app_item_bookmarks_avg_fields
	count(columns: [app_item_bookmarks_select_column!], distinct: Boolean): Int
	max: app_item_bookmarks_max_fields
	min: app_item_bookmarks_min_fields
	stddev: app_item_bookmarks_stddev_fields
	stddev_pop: app_item_bookmarks_stddev_pop_fields
	stddev_samp: app_item_bookmarks_stddev_samp_fields
	sum: app_item_bookmarks_sum_fields
	var_pop: app_item_bookmarks_var_pop_fields
	var_samp: app_item_bookmarks_var_samp_fields
	variance: app_item_bookmarks_variance_fields
}

"aggregate avg on columns"
type app_item_bookmarks_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_item_bookmarks_max_fields {
	created_at: timestamptz
	id: Int
	item_id: uuid
	profile_id: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type app_item_bookmarks_min_fields {
	created_at: timestamptz
	id: Int
	item_id: uuid
	profile_id: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"app.item_bookmarks\""
type app_item_bookmarks_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_item_bookmarks!]!
}

"aggregate stddev on columns"
type app_item_bookmarks_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_item_bookmarks_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_item_bookmarks_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_item_bookmarks_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_item_bookmarks_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_item_bookmarks_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_item_bookmarks_variance_fields {
	id: Float
}

"""
Tabel voor collateral bij items zoals ondertiteling. Brondata uit shared.collateral.


columns and relationships of "app.item_collateral"
"""
type app_item_collateral {
	created_at: timestamptz!
	description: String
	external_id: String!
	format: String
	item_external_id: String!
	path: String
	updated_at: timestamptz!
}

"aggregated selection of \"app.item_collateral\""
type app_item_collateral_aggregate {
	aggregate: app_item_collateral_aggregate_fields
	nodes: [app_item_collateral!]!
}

"aggregate fields of \"app.item_collateral\""
type app_item_collateral_aggregate_fields {
	count(columns: [app_item_collateral_select_column!], distinct: Boolean): Int
	max: app_item_collateral_max_fields
	min: app_item_collateral_min_fields
}

"aggregate max on columns"
type app_item_collateral_max_fields {
	created_at: timestamptz
	description: String
	external_id: String
	format: String
	item_external_id: String
	path: String
	updated_at: timestamptz
}

"aggregate min on columns"
type app_item_collateral_min_fields {
	created_at: timestamptz
	description: String
	external_id: String
	format: String
	item_external_id: String
	path: String
	updated_at: timestamptz
}

"response of any mutation on the table \"app.item_collateral\""
type app_item_collateral_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_item_collateral!]!
}

"columns and relationships of \"app.item_counts\""
type app_item_counts {
	bookmarks: bigint
	in_assignment: bigint
	in_collection: bigint
	item_uuid: uuid
	plays: Int
	quick_lane_links: bigint
	views: Int
}

"aggregated selection of \"app.item_counts\""
type app_item_counts_aggregate {
	aggregate: app_item_counts_aggregate_fields
	nodes: [app_item_counts!]!
}

"aggregate fields of \"app.item_counts\""
type app_item_counts_aggregate_fields {
	avg: app_item_counts_avg_fields
	count(columns: [app_item_counts_select_column!], distinct: Boolean): Int
	max: app_item_counts_max_fields
	min: app_item_counts_min_fields
	stddev: app_item_counts_stddev_fields
	stddev_pop: app_item_counts_stddev_pop_fields
	stddev_samp: app_item_counts_stddev_samp_fields
	sum: app_item_counts_sum_fields
	var_pop: app_item_counts_var_pop_fields
	var_samp: app_item_counts_var_samp_fields
	variance: app_item_counts_variance_fields
}

"aggregate avg on columns"
type app_item_counts_avg_fields {
	bookmarks: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"aggregate max on columns"
type app_item_counts_max_fields {
	bookmarks: bigint
	in_assignment: bigint
	in_collection: bigint
	item_uuid: uuid
	plays: Int
	quick_lane_links: bigint
	views: Int
}

"aggregate min on columns"
type app_item_counts_min_fields {
	bookmarks: bigint
	in_assignment: bigint
	in_collection: bigint
	item_uuid: uuid
	plays: Int
	quick_lane_links: bigint
	views: Int
}

"aggregate stddev on columns"
type app_item_counts_stddev_fields {
	bookmarks: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"aggregate stddev_pop on columns"
type app_item_counts_stddev_pop_fields {
	bookmarks: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"aggregate stddev_samp on columns"
type app_item_counts_stddev_samp_fields {
	bookmarks: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"aggregate sum on columns"
type app_item_counts_sum_fields {
	bookmarks: bigint
	in_assignment: bigint
	in_collection: bigint
	plays: Int
	quick_lane_links: bigint
	views: Int
}

"aggregate var_pop on columns"
type app_item_counts_var_pop_fields {
	bookmarks: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"aggregate var_samp on columns"
type app_item_counts_var_samp_fields {
	bookmarks: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"aggregate variance on columns"
type app_item_counts_variance_fields {
	bookmarks: Float
	in_assignment: Float
	in_collection: Float
	plays: Float
	quick_lane_links: Float
	views: Float
}

"columns and relationships of \"app.item_meta\""
type app_item_meta {
	archived_at: timestamptz
	avo1_id: String
	browse_path: String!
	created_at: timestamptz
	depublish_at: timestamptz
	depublish_reason: String
	description: String
	duration: time
	expiry_date: timestamptz
	external_id: bpchar!
	id: Int!
	is_deleted: Boolean
	is_orphaned: Boolean
	is_published: Boolean
	issued: date
	issued_edtf: String
	"An object relationship"
	item: shared_items
	"An array relationship"
	item_collaterals(
		"distinct select on columns"
		distinct_on: [app_item_collateral_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_collateral_order_by!]
		"filter the rows returned"
		where: app_item_collateral_bool_exp
	): [app_item_collateral!]!
	"An aggregated array relationship"
	item_collaterals_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_collateral_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_collateral_order_by!]
		"filter the rows returned"
		where: app_item_collateral_bool_exp
	): app_item_collateral_aggregate!
	"An object relationship"
	item_counts: app_item_counts
	lom_classification("JSON select path" path: String): jsonb
	lom_context("JSON select path" path: String): jsonb
	lom_intendedenduserrole("JSON select path" path: String): jsonb
	lom_keywords("JSON select path" path: String): jsonb
	lom_languages("JSON select path" path: String): jsonb
	lom_thema("JSON select path" path: String): jsonb
	lom_typicalagerange("JSON select path" path: String): jsonb
	note: String
	org_id: bpchar
	"An object relationship"
	organisation: shared_organisations
	original_pid: String
	"An array relationship"
	play_counts(
		"distinct select on columns"
		distinct_on: [app_item_plays_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_plays_order_by!]
		"filter the rows returned"
		where: app_item_plays_bool_exp
	): [app_item_plays!]!
	"An aggregated array relationship"
	play_counts_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_plays_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_plays_order_by!]
		"filter the rows returned"
		where: app_item_plays_bool_exp
	): app_item_plays_aggregate!
	publish_at: timestamptz
	published_at: timestamptz!
	"An object relationship"
	reference_id: migrate_reference_ids
	"An array relationship"
	relations(
		"distinct select on columns"
		distinct_on: [app_item_relations_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_relations_view_order_by!]
		"filter the rows returned"
		where: app_item_relations_view_bool_exp
	): [app_item_relations_view!]!
	"An aggregated array relationship"
	relations_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_relations_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_relations_view_order_by!]
		"filter the rows returned"
		where: app_item_relations_view_bool_exp
	): app_item_relations_view_aggregate!
	seo_image_path: String
	series: String
	thumbnail_path: String!
	title: String!
	"An object relationship"
	type: shared_types
	type_id: Int!
	uid: uuid!
	updated_at: timestamptz
	"An array relationship"
	view_counts(
		"distinct select on columns"
		distinct_on: [app_item_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_views_order_by!]
		"filter the rows returned"
		where: app_item_views_bool_exp
	): [app_item_views!]!
	"An aggregated array relationship"
	view_counts_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_views_order_by!]
		"filter the rows returned"
		where: app_item_views_bool_exp
	): app_item_views_aggregate!
}

"aggregated selection of \"app.item_meta\""
type app_item_meta_aggregate {
	aggregate: app_item_meta_aggregate_fields
	nodes: [app_item_meta!]!
}

"aggregate fields of \"app.item_meta\""
type app_item_meta_aggregate_fields {
	avg: app_item_meta_avg_fields
	count(columns: [app_item_meta_select_column!], distinct: Boolean): Int
	max: app_item_meta_max_fields
	min: app_item_meta_min_fields
	stddev: app_item_meta_stddev_fields
	stddev_pop: app_item_meta_stddev_pop_fields
	stddev_samp: app_item_meta_stddev_samp_fields
	sum: app_item_meta_sum_fields
	var_pop: app_item_meta_var_pop_fields
	var_samp: app_item_meta_var_samp_fields
	variance: app_item_meta_variance_fields
}

"aggregate avg on columns"
type app_item_meta_avg_fields {
	id: Float
	type_id: Float
}

"aggregate max on columns"
type app_item_meta_max_fields {
	archived_at: timestamptz
	avo1_id: String
	browse_path: String
	created_at: timestamptz
	depublish_at: timestamptz
	depublish_reason: String
	description: String
	expiry_date: timestamptz
	id: Int
	issued: date
	issued_edtf: String
	note: String
	original_pid: String
	publish_at: timestamptz
	published_at: timestamptz
	seo_image_path: String
	series: String
	thumbnail_path: String
	title: String
	type_id: Int
	uid: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type app_item_meta_min_fields {
	archived_at: timestamptz
	avo1_id: String
	browse_path: String
	created_at: timestamptz
	depublish_at: timestamptz
	depublish_reason: String
	description: String
	expiry_date: timestamptz
	id: Int
	issued: date
	issued_edtf: String
	note: String
	original_pid: String
	publish_at: timestamptz
	published_at: timestamptz
	seo_image_path: String
	series: String
	thumbnail_path: String
	title: String
	type_id: Int
	uid: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"app.item_meta\""
type app_item_meta_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_item_meta!]!
}

"aggregate stddev on columns"
type app_item_meta_stddev_fields {
	id: Float
	type_id: Float
}

"aggregate stddev_pop on columns"
type app_item_meta_stddev_pop_fields {
	id: Float
	type_id: Float
}

"aggregate stddev_samp on columns"
type app_item_meta_stddev_samp_fields {
	id: Float
	type_id: Float
}

"aggregate sum on columns"
type app_item_meta_sum_fields {
	id: Int
	type_id: Int
}

"aggregate var_pop on columns"
type app_item_meta_var_pop_fields {
	id: Float
	type_id: Float
}

"aggregate var_samp on columns"
type app_item_meta_var_samp_fields {
	id: Float
	type_id: Float
}

"aggregate variance on columns"
type app_item_meta_variance_fields {
	id: Float
	type_id: Float
}

"columns and relationships of \"app.item_plays\""
type app_item_plays {
	count: Int
	created_at: timestamptz!
	id: Int!
	item_id: uuid
	"An object relationship"
	playedItem: app_item_meta
	updated_at: timestamptz!
}

"aggregated selection of \"app.item_plays\""
type app_item_plays_aggregate {
	aggregate: app_item_plays_aggregate_fields
	nodes: [app_item_plays!]!
}

"aggregate fields of \"app.item_plays\""
type app_item_plays_aggregate_fields {
	avg: app_item_plays_avg_fields
	count(columns: [app_item_plays_select_column!], distinct: Boolean): Int
	max: app_item_plays_max_fields
	min: app_item_plays_min_fields
	stddev: app_item_plays_stddev_fields
	stddev_pop: app_item_plays_stddev_pop_fields
	stddev_samp: app_item_plays_stddev_samp_fields
	sum: app_item_plays_sum_fields
	var_pop: app_item_plays_var_pop_fields
	var_samp: app_item_plays_var_samp_fields
	variance: app_item_plays_variance_fields
}

"aggregate avg on columns"
type app_item_plays_avg_fields {
	count: Float
	id: Float
}

"aggregate max on columns"
type app_item_plays_max_fields {
	count: Int
	created_at: timestamptz
	id: Int
	item_id: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type app_item_plays_min_fields {
	count: Int
	created_at: timestamptz
	id: Int
	item_id: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"app.item_plays\""
type app_item_plays_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_item_plays!]!
}

"aggregate stddev on columns"
type app_item_plays_stddev_fields {
	count: Float
	id: Float
}

"aggregate stddev_pop on columns"
type app_item_plays_stddev_pop_fields {
	count: Float
	id: Float
}

"aggregate stddev_samp on columns"
type app_item_plays_stddev_samp_fields {
	count: Float
	id: Float
}

"aggregate sum on columns"
type app_item_plays_sum_fields {
	count: Int
	id: Int
}

"aggregate var_pop on columns"
type app_item_plays_var_pop_fields {
	count: Float
	id: Float
}

"aggregate var_samp on columns"
type app_item_plays_var_samp_fields {
	count: Float
	id: Float
}

"aggregate variance on columns"
type app_item_plays_variance_fields {
	count: Float
	id: Float
}

"""
This table holds relationships between items as a triple, e.g.: item A is replaced by item B.


columns and relationships of "app.item_relations"
"""
type app_item_relations {
	created_at: timestamptz
	"An object relationship"
	enum_relation_type: lookup_enum_relation_types!
	id: Int!
	object: uuid!
	predicate: lookup_enum_relation_types_enum!
	subject: uuid!
	updated_at: timestamptz
}

"aggregated selection of \"app.item_relations\""
type app_item_relations_aggregate {
	aggregate: app_item_relations_aggregate_fields
	nodes: [app_item_relations!]!
}

"aggregate fields of \"app.item_relations\""
type app_item_relations_aggregate_fields {
	avg: app_item_relations_avg_fields
	count(columns: [app_item_relations_select_column!], distinct: Boolean): Int
	max: app_item_relations_max_fields
	min: app_item_relations_min_fields
	stddev: app_item_relations_stddev_fields
	stddev_pop: app_item_relations_stddev_pop_fields
	stddev_samp: app_item_relations_stddev_samp_fields
	sum: app_item_relations_sum_fields
	var_pop: app_item_relations_var_pop_fields
	var_samp: app_item_relations_var_samp_fields
	variance: app_item_relations_variance_fields
}

"aggregate avg on columns"
type app_item_relations_avg_fields {
	id: Float
}

"aggregate max on columns"
type app_item_relations_max_fields {
	created_at: timestamptz
	id: Int
	object: uuid
	subject: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type app_item_relations_min_fields {
	created_at: timestamptz
	id: Int
	object: uuid
	subject: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"app.item_relations\""
type app_item_relations_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_item_relations!]!
}

"aggregate stddev on columns"
type app_item_relations_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type app_item_relations_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type app_item_relations_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type app_item_relations_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type app_item_relations_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type app_item_relations_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type app_item_relations_variance_fields {
	id: Float
}

"columns and relationships of \"app.item_relations_view\""
type app_item_relations_view {
	created_at: timestamptz
	object: uuid
	predicate: String
	subject: uuid
	updated_at: timestamptz
}

"aggregated selection of \"app.item_relations_view\""
type app_item_relations_view_aggregate {
	aggregate: app_item_relations_view_aggregate_fields
	nodes: [app_item_relations_view!]!
}

"aggregate fields of \"app.item_relations_view\""
type app_item_relations_view_aggregate_fields {
	count(columns: [app_item_relations_view_select_column!], distinct: Boolean): Int
	max: app_item_relations_view_max_fields
	min: app_item_relations_view_min_fields
}

"aggregate max on columns"
type app_item_relations_view_max_fields {
	created_at: timestamptz
	object: uuid
	predicate: String
	subject: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type app_item_relations_view_min_fields {
	created_at: timestamptz
	object: uuid
	predicate: String
	subject: uuid
	updated_at: timestamptz
}

"""
keep track of item popularity


columns and relationships of "app.item_score"
"""
type app_item_score {
	created_at: timestamptz!
	id: Int!
	item_id: uuid!
	"An object relationship"
	item_metum: app_item_meta!
	score: Int
	updated_at: timestamptz!
}

"aggregated selection of \"app.item_score\""
type app_item_score_aggregate {
	aggregate: app_item_score_aggregate_fields
	nodes: [app_item_score!]!
}

"aggregate fields of \"app.item_score\""
type app_item_score_aggregate_fields {
	avg: app_item_score_avg_fields
	count(columns: [app_item_score_select_column!], distinct: Boolean): Int
	max: app_item_score_max_fields
	min: app_item_score_min_fields
	stddev: app_item_score_stddev_fields
	stddev_pop: app_item_score_stddev_pop_fields
	stddev_samp: app_item_score_stddev_samp_fields
	sum: app_item_score_sum_fields
	var_pop: app_item_score_var_pop_fields
	var_samp: app_item_score_var_samp_fields
	variance: app_item_score_variance_fields
}

"aggregate avg on columns"
type app_item_score_avg_fields {
	id: Float
	score: Float
}

"aggregate max on columns"
type app_item_score_max_fields {
	created_at: timestamptz
	id: Int
	item_id: uuid
	score: Int
	updated_at: timestamptz
}

"aggregate min on columns"
type app_item_score_min_fields {
	created_at: timestamptz
	id: Int
	item_id: uuid
	score: Int
	updated_at: timestamptz
}

"response of any mutation on the table \"app.item_score\""
type app_item_score_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_item_score!]!
}

"aggregate stddev on columns"
type app_item_score_stddev_fields {
	id: Float
	score: Float
}

"aggregate stddev_pop on columns"
type app_item_score_stddev_pop_fields {
	id: Float
	score: Float
}

"aggregate stddev_samp on columns"
type app_item_score_stddev_samp_fields {
	id: Float
	score: Float
}

"aggregate sum on columns"
type app_item_score_sum_fields {
	id: Int
	score: Int
}

"aggregate var_pop on columns"
type app_item_score_var_pop_fields {
	id: Float
	score: Float
}

"aggregate var_samp on columns"
type app_item_score_var_samp_fields {
	id: Float
	score: Float
}

"aggregate variance on columns"
type app_item_score_variance_fields {
	id: Float
	score: Float
}

"columns and relationships of \"app.item_views\""
type app_item_views {
	count: Int
	created_at: timestamptz!
	id: Int!
	item_id: uuid
	updated_at: timestamptz!
	"An object relationship"
	viewedItem: app_item_meta
}

"aggregated selection of \"app.item_views\""
type app_item_views_aggregate {
	aggregate: app_item_views_aggregate_fields
	nodes: [app_item_views!]!
}

"aggregate fields of \"app.item_views\""
type app_item_views_aggregate_fields {
	avg: app_item_views_avg_fields
	count(columns: [app_item_views_select_column!], distinct: Boolean): Int
	max: app_item_views_max_fields
	min: app_item_views_min_fields
	stddev: app_item_views_stddev_fields
	stddev_pop: app_item_views_stddev_pop_fields
	stddev_samp: app_item_views_stddev_samp_fields
	sum: app_item_views_sum_fields
	var_pop: app_item_views_var_pop_fields
	var_samp: app_item_views_var_samp_fields
	variance: app_item_views_variance_fields
}

"aggregate avg on columns"
type app_item_views_avg_fields {
	count: Float
	id: Float
}

"aggregate max on columns"
type app_item_views_max_fields {
	count: Int
	created_at: timestamptz
	id: Int
	item_id: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type app_item_views_min_fields {
	count: Int
	created_at: timestamptz
	id: Int
	item_id: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"app.item_views\""
type app_item_views_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_item_views!]!
}

"aggregate stddev on columns"
type app_item_views_stddev_fields {
	count: Float
	id: Float
}

"aggregate stddev_pop on columns"
type app_item_views_stddev_pop_fields {
	count: Float
	id: Float
}

"aggregate stddev_samp on columns"
type app_item_views_stddev_samp_fields {
	count: Float
	id: Float
}

"aggregate sum on columns"
type app_item_views_sum_fields {
	count: Int
	id: Int
}

"aggregate var_pop on columns"
type app_item_views_var_pop_fields {
	count: Float
	id: Float
}

"aggregate var_samp on columns"
type app_item_views_var_samp_fields {
	count: Float
	id: Float
}

"aggregate variance on columns"
type app_item_views_variance_fields {
	count: Float
	id: Float
}

"columns and relationships of \"app.pupil_collection_blocks\""
type app_pupil_collection_blocks {
	assignment_response_id: uuid!
	"An object relationship"
	assignment_responses_v2: app_assignment_responses_v2!
	created_at: timestamptz!
	custom_description: String
	custom_title: String
	end_oc: Int
	fragment_id: String
	id: uuid!
	is_deleted: Boolean!
	position: Int!
	start_oc: Int
	thumbnail_path: String
	type: String!
	updated_at: timestamptz!
	use_custom_fields: Boolean!
}

"aggregated selection of \"app.pupil_collection_blocks\""
type app_pupil_collection_blocks_aggregate {
	aggregate: app_pupil_collection_blocks_aggregate_fields
	nodes: [app_pupil_collection_blocks!]!
}

"aggregate fields of \"app.pupil_collection_blocks\""
type app_pupil_collection_blocks_aggregate_fields {
	avg: app_pupil_collection_blocks_avg_fields
	count(columns: [app_pupil_collection_blocks_select_column!], distinct: Boolean): Int
	max: app_pupil_collection_blocks_max_fields
	min: app_pupil_collection_blocks_min_fields
	stddev: app_pupil_collection_blocks_stddev_fields
	stddev_pop: app_pupil_collection_blocks_stddev_pop_fields
	stddev_samp: app_pupil_collection_blocks_stddev_samp_fields
	sum: app_pupil_collection_blocks_sum_fields
	var_pop: app_pupil_collection_blocks_var_pop_fields
	var_samp: app_pupil_collection_blocks_var_samp_fields
	variance: app_pupil_collection_blocks_variance_fields
}

"aggregate avg on columns"
type app_pupil_collection_blocks_avg_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"aggregate max on columns"
type app_pupil_collection_blocks_max_fields {
	assignment_response_id: uuid
	created_at: timestamptz
	custom_description: String
	custom_title: String
	end_oc: Int
	fragment_id: String
	id: uuid
	position: Int
	start_oc: Int
	thumbnail_path: String
	type: String
	updated_at: timestamptz
}

"aggregate min on columns"
type app_pupil_collection_blocks_min_fields {
	assignment_response_id: uuid
	created_at: timestamptz
	custom_description: String
	custom_title: String
	end_oc: Int
	fragment_id: String
	id: uuid
	position: Int
	start_oc: Int
	thumbnail_path: String
	type: String
	updated_at: timestamptz
}

"response of any mutation on the table \"app.pupil_collection_blocks\""
type app_pupil_collection_blocks_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_pupil_collection_blocks!]!
}

"aggregate stddev on columns"
type app_pupil_collection_blocks_stddev_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"aggregate stddev_pop on columns"
type app_pupil_collection_blocks_stddev_pop_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"aggregate stddev_samp on columns"
type app_pupil_collection_blocks_stddev_samp_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"aggregate sum on columns"
type app_pupil_collection_blocks_sum_fields {
	end_oc: Int
	position: Int
	start_oc: Int
}

"aggregate var_pop on columns"
type app_pupil_collection_blocks_var_pop_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"aggregate var_samp on columns"
type app_pupil_collection_blocks_var_samp_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"aggregate variance on columns"
type app_pupil_collection_blocks_variance_fields {
	end_oc: Float
	position: Float
	start_oc: Float
}

"""
Quick lane shared URL's


columns and relationships of "app.quick_lanes"
"""
type app_quick_lanes {
	content_id: uuid!
	content_label: String!
	created_at: timestamptz!
	id: uuid!
	"An object relationship"
	owner: users_profiles!
	owner_profile_id: uuid!
	title: String!
	updated_at: timestamptz!
	view_mode: String!
}

"aggregated selection of \"app.quick_lanes\""
type app_quick_lanes_aggregate {
	aggregate: app_quick_lanes_aggregate_fields
	nodes: [app_quick_lanes!]!
}

"aggregate fields of \"app.quick_lanes\""
type app_quick_lanes_aggregate_fields {
	count(columns: [app_quick_lanes_select_column!], distinct: Boolean): Int
	max: app_quick_lanes_max_fields
	min: app_quick_lanes_min_fields
}

"aggregate max on columns"
type app_quick_lanes_max_fields {
	content_id: uuid
	content_label: String
	created_at: timestamptz
	id: uuid
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
	view_mode: String
}

"aggregate min on columns"
type app_quick_lanes_min_fields {
	content_id: uuid
	content_label: String
	created_at: timestamptz
	id: uuid
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
	view_mode: String
}

"response of any mutation on the table \"app.quick_lanes\""
type app_quick_lanes_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_quick_lanes!]!
}

"columns and relationships of \"app.quick_lanes_overview\""
type app_quick_lanes_overview {
	company_id: String
	company_name: String
	content_id: uuid
	content_label: String
	created_at: timestamptz
	id: uuid
	owner_first_name: String
	owner_full_name: String
	owner_last_name: String
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
	view_mode: String
}

"aggregated selection of \"app.quick_lanes_overview\""
type app_quick_lanes_overview_aggregate {
	aggregate: app_quick_lanes_overview_aggregate_fields
	nodes: [app_quick_lanes_overview!]!
}

"aggregate fields of \"app.quick_lanes_overview\""
type app_quick_lanes_overview_aggregate_fields {
	count(columns: [app_quick_lanes_overview_select_column!], distinct: Boolean): Int
	max: app_quick_lanes_overview_max_fields
	min: app_quick_lanes_overview_min_fields
}

"aggregate max on columns"
type app_quick_lanes_overview_max_fields {
	company_id: String
	company_name: String
	content_id: uuid
	content_label: String
	created_at: timestamptz
	id: uuid
	owner_first_name: String
	owner_full_name: String
	owner_last_name: String
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
	view_mode: String
}

"aggregate min on columns"
type app_quick_lanes_overview_min_fields {
	company_id: String
	company_name: String
	content_id: uuid
	content_label: String
	created_at: timestamptz
	id: uuid
	owner_first_name: String
	owner_full_name: String
	owner_last_name: String
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
	view_mode: String
}

"""
Table for users' bookmarked (saved) searches.


columns and relationships of "app.search_bookmarks"
"""
type app_search_bookmarks {
	created_at: timestamptz
	id: uuid!
	label: String!
	profile_owner_id: uuid!
	search_params("JSON select path" path: String): jsonb
	updated_at: timestamptz
}

"aggregated selection of \"app.search_bookmarks\""
type app_search_bookmarks_aggregate {
	aggregate: app_search_bookmarks_aggregate_fields
	nodes: [app_search_bookmarks!]!
}

"aggregate fields of \"app.search_bookmarks\""
type app_search_bookmarks_aggregate_fields {
	count(columns: [app_search_bookmarks_select_column!], distinct: Boolean): Int
	max: app_search_bookmarks_max_fields
	min: app_search_bookmarks_min_fields
}

"aggregate max on columns"
type app_search_bookmarks_max_fields {
	created_at: timestamptz
	id: uuid
	label: String
	profile_owner_id: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type app_search_bookmarks_min_fields {
	created_at: timestamptz
	id: uuid
	label: String
	profile_owner_id: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"app.search_bookmarks\""
type app_search_bookmarks_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_search_bookmarks!]!
}

"""
Aanpasbare variabelen die niet systeemvariabelen zijn, zoals translations, tooltips.


columns and relationships of "app.site_variables"
"""
type app_site_variables {
	created_at: timestamptz
	name: String!
	updated_at: timestamptz
	value("JSON select path" path: String): jsonb!
}

"aggregated selection of \"app.site_variables\""
type app_site_variables_aggregate {
	aggregate: app_site_variables_aggregate_fields
	nodes: [app_site_variables!]!
}

"aggregate fields of \"app.site_variables\""
type app_site_variables_aggregate_fields {
	count(columns: [app_site_variables_select_column!], distinct: Boolean): Int
	max: app_site_variables_max_fields
	min: app_site_variables_min_fields
}

"aggregate max on columns"
type app_site_variables_max_fields {
	created_at: timestamptz
	name: String
	updated_at: timestamptz
}

"aggregate min on columns"
type app_site_variables_min_fields {
	created_at: timestamptz
	name: String
	updated_at: timestamptz
}

"response of any mutation on the table \"app.site_variables\""
type app_site_variables_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [app_site_variables!]!
}

"columns and relationships of \"app.usage_counts\""
type app_usage_counts {
	count: bigint
	id: uuid
	type: String
	usage: String
}

"aggregated selection of \"app.usage_counts\""
type app_usage_counts_aggregate {
	aggregate: app_usage_counts_aggregate_fields
	nodes: [app_usage_counts!]!
}

"aggregate fields of \"app.usage_counts\""
type app_usage_counts_aggregate_fields {
	avg: app_usage_counts_avg_fields
	count(columns: [app_usage_counts_select_column!], distinct: Boolean): Int
	max: app_usage_counts_max_fields
	min: app_usage_counts_min_fields
	stddev: app_usage_counts_stddev_fields
	stddev_pop: app_usage_counts_stddev_pop_fields
	stddev_samp: app_usage_counts_stddev_samp_fields
	sum: app_usage_counts_sum_fields
	var_pop: app_usage_counts_var_pop_fields
	var_samp: app_usage_counts_var_samp_fields
	variance: app_usage_counts_variance_fields
}

"aggregate avg on columns"
type app_usage_counts_avg_fields {
	count: Float
}

"aggregate max on columns"
type app_usage_counts_max_fields {
	count: bigint
	id: uuid
	type: String
	usage: String
}

"aggregate min on columns"
type app_usage_counts_min_fields {
	count: bigint
	id: uuid
	type: String
	usage: String
}

"aggregate stddev on columns"
type app_usage_counts_stddev_fields {
	count: Float
}

"aggregate stddev_pop on columns"
type app_usage_counts_stddev_pop_fields {
	count: Float
}

"aggregate stddev_samp on columns"
type app_usage_counts_stddev_samp_fields {
	count: Float
}

"aggregate sum on columns"
type app_usage_counts_sum_fields {
	count: bigint
}

"aggregate var_pop on columns"
type app_usage_counts_var_pop_fields {
	count: Float
}

"aggregate var_samp on columns"
type app_usage_counts_var_samp_fields {
	count: Float
}

"aggregate variance on columns"
type app_usage_counts_variance_fields {
	count: Float
}

"""
Table for indicating type of content used in assignment.


columns and relationships of "lookup.enum_assignment_content_labels"
"""
type lookup_enum_assignment_content_labels {
	label: String!
	value: String!
}

"aggregated selection of \"lookup.enum_assignment_content_labels\""
type lookup_enum_assignment_content_labels_aggregate {
	aggregate: lookup_enum_assignment_content_labels_aggregate_fields
	nodes: [lookup_enum_assignment_content_labels!]!
}

"aggregate fields of \"lookup.enum_assignment_content_labels\""
type lookup_enum_assignment_content_labels_aggregate_fields {
	count(columns: [lookup_enum_assignment_content_labels_select_column!], distinct: Boolean): Int
	max: lookup_enum_assignment_content_labels_max_fields
	min: lookup_enum_assignment_content_labels_min_fields
}

"aggregate max on columns"
type lookup_enum_assignment_content_labels_max_fields {
	label: String
	value: String
}

"aggregate min on columns"
type lookup_enum_assignment_content_labels_min_fields {
	label: String
	value: String
}

"response of any mutation on the table \"lookup.enum_assignment_content_labels\""
type lookup_enum_assignment_content_labels_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_assignment_content_labels!]!
}

"""
Enum table for assignment types.


columns and relationships of "lookup.enum_assignment_types"
"""
type lookup_enum_assignment_types {
	label: String!
	value: String!
}

"aggregated selection of \"lookup.enum_assignment_types\""
type lookup_enum_assignment_types_aggregate {
	aggregate: lookup_enum_assignment_types_aggregate_fields
	nodes: [lookup_enum_assignment_types!]!
}

"aggregate fields of \"lookup.enum_assignment_types\""
type lookup_enum_assignment_types_aggregate_fields {
	count(columns: [lookup_enum_assignment_types_select_column!], distinct: Boolean): Int
	max: lookup_enum_assignment_types_max_fields
	min: lookup_enum_assignment_types_min_fields
}

"aggregate max on columns"
type lookup_enum_assignment_types_max_fields {
	label: String
	value: String
}

"aggregate min on columns"
type lookup_enum_assignment_types_min_fields {
	label: String
	value: String
}

"response of any mutation on the table \"lookup.enum_assignment_types\""
type lookup_enum_assignment_types_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_assignment_types!]!
}

"columns and relationships of \"lookup.enum_collection_labels\""
type lookup_enum_collection_labels {
	description: String
	value: String!
}

"aggregated selection of \"lookup.enum_collection_labels\""
type lookup_enum_collection_labels_aggregate {
	aggregate: lookup_enum_collection_labels_aggregate_fields
	nodes: [lookup_enum_collection_labels!]!
}

"aggregate fields of \"lookup.enum_collection_labels\""
type lookup_enum_collection_labels_aggregate_fields {
	count(columns: [lookup_enum_collection_labels_select_column!], distinct: Boolean): Int
	max: lookup_enum_collection_labels_max_fields
	min: lookup_enum_collection_labels_min_fields
}

"aggregate max on columns"
type lookup_enum_collection_labels_max_fields {
	description: String
	value: String
}

"aggregate min on columns"
type lookup_enum_collection_labels_min_fields {
	description: String
	value: String
}

"response of any mutation on the table \"lookup.enum_collection_labels\""
type lookup_enum_collection_labels_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_collection_labels!]!
}

"""
QC, soorten kwaliteitschecks bij de actualisatie en redactie van collecties en bundels.


columns and relationships of "lookup.enum_collection_management_qc_label"
"""
type lookup_enum_collection_management_qc_label {
	description: String
	value: String!
}

"aggregated selection of \"lookup.enum_collection_management_qc_label\""
type lookup_enum_collection_management_qc_label_aggregate {
	aggregate: lookup_enum_collection_management_qc_label_aggregate_fields
	nodes: [lookup_enum_collection_management_qc_label!]!
}

"aggregate fields of \"lookup.enum_collection_management_qc_label\""
type lookup_enum_collection_management_qc_label_aggregate_fields {
	count(
		columns: [lookup_enum_collection_management_qc_label_select_column!]
		distinct: Boolean
	): Int
	max: lookup_enum_collection_management_qc_label_max_fields
	min: lookup_enum_collection_management_qc_label_min_fields
}

"aggregate max on columns"
type lookup_enum_collection_management_qc_label_max_fields {
	description: String
	value: String
}

"aggregate min on columns"
type lookup_enum_collection_management_qc_label_min_fields {
	description: String
	value: String
}

"response of any mutation on the table \"lookup.enum_collection_management_qc_label\""
type lookup_enum_collection_management_qc_label_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_collection_management_qc_label!]!
}

"""
De huidige redactionele status van beheerde collecties.


columns and relationships of "lookup.enum_collection_management_status"
"""
type lookup_enum_collection_management_status {
	description: String
	value: String!
}

"aggregated selection of \"lookup.enum_collection_management_status\""
type lookup_enum_collection_management_status_aggregate {
	aggregate: lookup_enum_collection_management_status_aggregate_fields
	nodes: [lookup_enum_collection_management_status!]!
}

"aggregate fields of \"lookup.enum_collection_management_status\""
type lookup_enum_collection_management_status_aggregate_fields {
	count(
		columns: [lookup_enum_collection_management_status_select_column!]
		distinct: Boolean
	): Int
	max: lookup_enum_collection_management_status_max_fields
	min: lookup_enum_collection_management_status_min_fields
}

"aggregate max on columns"
type lookup_enum_collection_management_status_max_fields {
	description: String
	value: String
}

"aggregate min on columns"
type lookup_enum_collection_management_status_min_fields {
	description: String
	value: String
}

"response of any mutation on the table \"lookup.enum_collection_management_status\""
type lookup_enum_collection_management_status_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_collection_management_status!]!
}

"""
Secondary UI colors.


columns and relationships of "lookup.enum_colors"
"""
type lookup_enum_colors {
	label: String!
	value: String!
}

"aggregated selection of \"lookup.enum_colors\""
type lookup_enum_colors_aggregate {
	aggregate: lookup_enum_colors_aggregate_fields
	nodes: [lookup_enum_colors!]!
}

"aggregate fields of \"lookup.enum_colors\""
type lookup_enum_colors_aggregate_fields {
	count(columns: [lookup_enum_colors_select_column!], distinct: Boolean): Int
	max: lookup_enum_colors_max_fields
	min: lookup_enum_colors_min_fields
}

"aggregate max on columns"
type lookup_enum_colors_max_fields {
	label: String
	value: String
}

"aggregate min on columns"
type lookup_enum_colors_min_fields {
	label: String
	value: String
}

"response of any mutation on the table \"lookup.enum_colors\""
type lookup_enum_colors_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_colors!]!
}

"""
Graphql enum types for content block types


columns and relationships of "lookup.enum_content_block_types"
"""
type lookup_enum_content_block_types {
	description: String
	value: String!
}

"aggregated selection of \"lookup.enum_content_block_types\""
type lookup_enum_content_block_types_aggregate {
	aggregate: lookup_enum_content_block_types_aggregate_fields
	nodes: [lookup_enum_content_block_types!]!
}

"aggregate fields of \"lookup.enum_content_block_types\""
type lookup_enum_content_block_types_aggregate_fields {
	count(columns: [lookup_enum_content_block_types_select_column!], distinct: Boolean): Int
	max: lookup_enum_content_block_types_max_fields
	min: lookup_enum_content_block_types_min_fields
}

"aggregate max on columns"
type lookup_enum_content_block_types_max_fields {
	description: String
	value: String
}

"aggregate min on columns"
type lookup_enum_content_block_types_min_fields {
	description: String
	value: String
}

"response of any mutation on the table \"lookup.enum_content_block_types\""
type lookup_enum_content_block_types_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_content_block_types!]!
}

"""
GraphQL enum type for content types, e.g. pages, news, projects.


columns and relationships of "lookup.enum_content_types"
"""
type lookup_enum_content_types {
	description: String
	value: String!
}

"aggregated selection of \"lookup.enum_content_types\""
type lookup_enum_content_types_aggregate {
	aggregate: lookup_enum_content_types_aggregate_fields
	nodes: [lookup_enum_content_types!]!
}

"aggregate fields of \"lookup.enum_content_types\""
type lookup_enum_content_types_aggregate_fields {
	count(columns: [lookup_enum_content_types_select_column!], distinct: Boolean): Int
	max: lookup_enum_content_types_max_fields
	min: lookup_enum_content_types_min_fields
}

"aggregate max on columns"
type lookup_enum_content_types_max_fields {
	description: String
	value: String
}

"aggregate min on columns"
type lookup_enum_content_types_min_fields {
	description: String
	value: String
}

"response of any mutation on the table \"lookup.enum_content_types\""
type lookup_enum_content_types_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_content_types!]!
}

"""
GraphQL enum type for input types used in content


columns and relationships of "lookup.enum_input_types"
"""
type lookup_enum_input_types {
	description: String
	value: String!
}

"aggregated selection of \"lookup.enum_input_types\""
type lookup_enum_input_types_aggregate {
	aggregate: lookup_enum_input_types_aggregate_fields
	nodes: [lookup_enum_input_types!]!
}

"aggregate fields of \"lookup.enum_input_types\""
type lookup_enum_input_types_aggregate_fields {
	count(columns: [lookup_enum_input_types_select_column!], distinct: Boolean): Int
	max: lookup_enum_input_types_max_fields
	min: lookup_enum_input_types_min_fields
}

"aggregate max on columns"
type lookup_enum_input_types_max_fields {
	description: String
	value: String
}

"aggregate min on columns"
type lookup_enum_input_types_min_fields {
	description: String
	value: String
}

"response of any mutation on the table \"lookup.enum_input_types\""
type lookup_enum_input_types_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_input_types!]!
}

"columns and relationships of \"lookup.enum_lom_classification\""
type lookup_enum_lom_classification {
	description: String!
	value: String!
}

"aggregated selection of \"lookup.enum_lom_classification\""
type lookup_enum_lom_classification_aggregate {
	aggregate: lookup_enum_lom_classification_aggregate_fields
	nodes: [lookup_enum_lom_classification!]!
}

"aggregate fields of \"lookup.enum_lom_classification\""
type lookup_enum_lom_classification_aggregate_fields {
	count(columns: [lookup_enum_lom_classification_select_column!], distinct: Boolean): Int
	max: lookup_enum_lom_classification_max_fields
	min: lookup_enum_lom_classification_min_fields
}

"aggregate max on columns"
type lookup_enum_lom_classification_max_fields {
	description: String
	value: String
}

"aggregate min on columns"
type lookup_enum_lom_classification_min_fields {
	description: String
	value: String
}

"response of any mutation on the table \"lookup.enum_lom_classification\""
type lookup_enum_lom_classification_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_lom_classification!]!
}

"columns and relationships of \"lookup.enum_lom_context\""
type lookup_enum_lom_context {
	description: String
	value: String!
}

"aggregated selection of \"lookup.enum_lom_context\""
type lookup_enum_lom_context_aggregate {
	aggregate: lookup_enum_lom_context_aggregate_fields
	nodes: [lookup_enum_lom_context!]!
}

"aggregate fields of \"lookup.enum_lom_context\""
type lookup_enum_lom_context_aggregate_fields {
	count(columns: [lookup_enum_lom_context_select_column!], distinct: Boolean): Int
	max: lookup_enum_lom_context_max_fields
	min: lookup_enum_lom_context_min_fields
}

"aggregate max on columns"
type lookup_enum_lom_context_max_fields {
	description: String
	value: String
}

"aggregate min on columns"
type lookup_enum_lom_context_min_fields {
	description: String
	value: String
}

"response of any mutation on the table \"lookup.enum_lom_context\""
type lookup_enum_lom_context_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_lom_context!]!
}

"""
Enum table voor users.profile_flags.keys


columns and relationships of "lookup.enum_profile_flags"
"""
type lookup_enum_profile_flags {
	description: String
	value: String!
}

"aggregated selection of \"lookup.enum_profile_flags\""
type lookup_enum_profile_flags_aggregate {
	aggregate: lookup_enum_profile_flags_aggregate_fields
	nodes: [lookup_enum_profile_flags!]!
}

"aggregate fields of \"lookup.enum_profile_flags\""
type lookup_enum_profile_flags_aggregate_fields {
	count(columns: [lookup_enum_profile_flags_select_column!], distinct: Boolean): Int
	max: lookup_enum_profile_flags_max_fields
	min: lookup_enum_profile_flags_min_fields
}

"aggregate max on columns"
type lookup_enum_profile_flags_max_fields {
	description: String
	value: String
}

"aggregate min on columns"
type lookup_enum_profile_flags_min_fields {
	description: String
	value: String
}

"response of any mutation on the table \"lookup.enum_profile_flags\""
type lookup_enum_profile_flags_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_profile_flags!]!
}

"""
Enum waarden voor users.profile_preferences.key


columns and relationships of "lookup.enum_profile_preferences_keys"
"""
type lookup_enum_profile_preferences_keys {
	description: String
	value: String!
}

"aggregated selection of \"lookup.enum_profile_preferences_keys\""
type lookup_enum_profile_preferences_keys_aggregate {
	aggregate: lookup_enum_profile_preferences_keys_aggregate_fields
	nodes: [lookup_enum_profile_preferences_keys!]!
}

"aggregate fields of \"lookup.enum_profile_preferences_keys\""
type lookup_enum_profile_preferences_keys_aggregate_fields {
	count(columns: [lookup_enum_profile_preferences_keys_select_column!], distinct: Boolean): Int
	max: lookup_enum_profile_preferences_keys_max_fields
	min: lookup_enum_profile_preferences_keys_min_fields
}

"aggregate max on columns"
type lookup_enum_profile_preferences_keys_max_fields {
	description: String
	value: String
}

"aggregate min on columns"
type lookup_enum_profile_preferences_keys_min_fields {
	description: String
	value: String
}

"response of any mutation on the table \"lookup.enum_profile_preferences_keys\""
type lookup_enum_profile_preferences_keys_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_profile_preferences_keys!]!
}

"""
Enum values for item and collection relations.


columns and relationships of "lookup.enum_relation_types"
"""
type lookup_enum_relation_types {
	description: String!
	value: String!
}

"aggregated selection of \"lookup.enum_relation_types\""
type lookup_enum_relation_types_aggregate {
	aggregate: lookup_enum_relation_types_aggregate_fields
	nodes: [lookup_enum_relation_types!]!
}

"aggregate fields of \"lookup.enum_relation_types\""
type lookup_enum_relation_types_aggregate_fields {
	count(columns: [lookup_enum_relation_types_select_column!], distinct: Boolean): Int
	max: lookup_enum_relation_types_max_fields
	min: lookup_enum_relation_types_min_fields
}

"aggregate max on columns"
type lookup_enum_relation_types_max_fields {
	description: String
	value: String
}

"aggregate min on columns"
type lookup_enum_relation_types_min_fields {
	description: String
	value: String
}

"response of any mutation on the table \"lookup.enum_relation_types\""
type lookup_enum_relation_types_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_relation_types!]!
}

"""
Enum table for bookmarked searches types.


columns and relationships of "lookup.enum_search_bookmark_types"
"""
type lookup_enum_search_bookmark_types {
	label: String!
	value: String!
}

"aggregated selection of \"lookup.enum_search_bookmark_types\""
type lookup_enum_search_bookmark_types_aggregate {
	aggregate: lookup_enum_search_bookmark_types_aggregate_fields
	nodes: [lookup_enum_search_bookmark_types!]!
}

"aggregate fields of \"lookup.enum_search_bookmark_types\""
type lookup_enum_search_bookmark_types_aggregate_fields {
	count(columns: [lookup_enum_search_bookmark_types_select_column!], distinct: Boolean): Int
	max: lookup_enum_search_bookmark_types_max_fields
	min: lookup_enum_search_bookmark_types_min_fields
}

"aggregate max on columns"
type lookup_enum_search_bookmark_types_max_fields {
	label: String
	value: String
}

"aggregate min on columns"
type lookup_enum_search_bookmark_types_min_fields {
	label: String
	value: String
}

"response of any mutation on the table \"lookup.enum_search_bookmark_types\""
type lookup_enum_search_bookmark_types_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_enum_search_bookmark_types!]!
}

"columns and relationships of \"lookup.thesaurus\""
type lookup_thesaurus {
	id: String!
	label: String!
	scheme: String
}

"aggregated selection of \"lookup.thesaurus\""
type lookup_thesaurus_aggregate {
	aggregate: lookup_thesaurus_aggregate_fields
	nodes: [lookup_thesaurus!]!
}

"aggregate fields of \"lookup.thesaurus\""
type lookup_thesaurus_aggregate_fields {
	count(columns: [lookup_thesaurus_select_column!], distinct: Boolean): Int
	max: lookup_thesaurus_max_fields
	min: lookup_thesaurus_min_fields
}

"aggregate max on columns"
type lookup_thesaurus_max_fields {
	id: String
	label: String
	scheme: String
}

"aggregate min on columns"
type lookup_thesaurus_min_fields {
	id: String
	label: String
	scheme: String
}

"response of any mutation on the table \"lookup.thesaurus\""
type lookup_thesaurus_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [lookup_thesaurus!]!
}

"""
Table met de oorspronkelijke datum van toevoeging op avo1.


columns and relationships of "migrate.original_publishdate"
"""
type migrate_original_publishdate {
	created_at: timestamptz
	external_id: String!
	mediamosa_id: String!
}

"aggregated selection of \"migrate.original_publishdate\""
type migrate_original_publishdate_aggregate {
	aggregate: migrate_original_publishdate_aggregate_fields
	nodes: [migrate_original_publishdate!]!
}

"aggregate fields of \"migrate.original_publishdate\""
type migrate_original_publishdate_aggregate_fields {
	count(columns: [migrate_original_publishdate_select_column!], distinct: Boolean): Int
	max: migrate_original_publishdate_max_fields
	min: migrate_original_publishdate_min_fields
}

"aggregate max on columns"
type migrate_original_publishdate_max_fields {
	created_at: timestamptz
	external_id: String
	mediamosa_id: String
}

"aggregate min on columns"
type migrate_original_publishdate_min_fields {
	created_at: timestamptz
	external_id: String
	mediamosa_id: String
}

"response of any mutation on the table \"migrate.original_publishdate\""
type migrate_original_publishdate_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [migrate_original_publishdate!]!
}

"columns and relationships of \"migrate.reference_ids\""
type migrate_reference_ids {
	created_at: timestamptz
	external_id: String!
	id: Int!
	mediamosa_id: String!
	type_label: String!
}

"aggregated selection of \"migrate.reference_ids\""
type migrate_reference_ids_aggregate {
	aggregate: migrate_reference_ids_aggregate_fields
	nodes: [migrate_reference_ids!]!
}

"aggregate fields of \"migrate.reference_ids\""
type migrate_reference_ids_aggregate_fields {
	avg: migrate_reference_ids_avg_fields
	count(columns: [migrate_reference_ids_select_column!], distinct: Boolean): Int
	max: migrate_reference_ids_max_fields
	min: migrate_reference_ids_min_fields
	stddev: migrate_reference_ids_stddev_fields
	stddev_pop: migrate_reference_ids_stddev_pop_fields
	stddev_samp: migrate_reference_ids_stddev_samp_fields
	sum: migrate_reference_ids_sum_fields
	var_pop: migrate_reference_ids_var_pop_fields
	var_samp: migrate_reference_ids_var_samp_fields
	variance: migrate_reference_ids_variance_fields
}

"aggregate avg on columns"
type migrate_reference_ids_avg_fields {
	id: Float
}

"aggregate max on columns"
type migrate_reference_ids_max_fields {
	created_at: timestamptz
	external_id: String
	id: Int
	mediamosa_id: String
	type_label: String
}

"aggregate min on columns"
type migrate_reference_ids_min_fields {
	created_at: timestamptz
	external_id: String
	id: Int
	mediamosa_id: String
	type_label: String
}

"response of any mutation on the table \"migrate.reference_ids\""
type migrate_reference_ids_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [migrate_reference_ids!]!
}

"aggregate stddev on columns"
type migrate_reference_ids_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type migrate_reference_ids_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type migrate_reference_ids_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type migrate_reference_ids_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type migrate_reference_ids_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type migrate_reference_ids_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type migrate_reference_ids_variance_fields {
	id: Float
}

"mutation root"
type mutation_root {
	"delete data from the table: \"app.assignment_assignment_tags\""
	delete_app_assignment_assignment_tags(
		"filter the rows which have to be deleted"
		where: app_assignment_assignment_tags_bool_exp!
	): app_assignment_assignment_tags_mutation_response
	"delete single row from the table: \"app.assignment_assignment_tags\""
	delete_app_assignment_assignment_tags_by_pk(id: Int!): app_assignment_assignment_tags
	"delete data from the table: \"app.assignment_blocks_v2\""
	delete_app_assignment_blocks_v2(
		"filter the rows which have to be deleted"
		where: app_assignment_blocks_v2_bool_exp!
	): app_assignment_blocks_v2_mutation_response
	"delete single row from the table: \"app.assignment_blocks_v2\""
	delete_app_assignment_blocks_v2_by_pk(id: uuid!): app_assignment_blocks_v2
	"delete data from the table: \"app.assignment_labels\""
	delete_app_assignment_labels(
		"filter the rows which have to be deleted"
		where: app_assignment_labels_bool_exp!
	): app_assignment_labels_mutation_response
	"delete single row from the table: \"app.assignment_labels\""
	delete_app_assignment_labels_by_pk(id: Int!): app_assignment_labels
	"delete data from the table: \"app.assignment_labels_v2\""
	delete_app_assignment_labels_v2(
		"filter the rows which have to be deleted"
		where: app_assignment_labels_v2_bool_exp!
	): app_assignment_labels_v2_mutation_response
	"delete single row from the table: \"app.assignment_labels_v2\""
	delete_app_assignment_labels_v2_by_pk(id: uuid!): app_assignment_labels_v2
	"delete data from the table: \"app.assignment_responses\""
	delete_app_assignment_responses(
		"filter the rows which have to be deleted"
		where: app_assignment_responses_bool_exp!
	): app_assignment_responses_mutation_response
	"delete single row from the table: \"app.assignment_responses\""
	delete_app_assignment_responses_by_pk(id: Int!): app_assignment_responses
	"delete data from the table: \"app.assignment_responses_v2\""
	delete_app_assignment_responses_v2(
		"filter the rows which have to be deleted"
		where: app_assignment_responses_v2_bool_exp!
	): app_assignment_responses_v2_mutation_response
	"delete single row from the table: \"app.assignment_responses_v2\""
	delete_app_assignment_responses_v2_by_pk(id: uuid!): app_assignment_responses_v2
	"delete data from the table: \"app.assignment_v2_views\""
	delete_app_assignment_v2_views(
		"filter the rows which have to be deleted"
		where: app_assignment_v2_views_bool_exp!
	): app_assignment_v2_views_mutation_response
	"delete single row from the table: \"app.assignment_v2_views\""
	delete_app_assignment_v2_views_by_pk(id: uuid!): app_assignment_v2_views
	"delete data from the table: \"app.assignments\""
	delete_app_assignments(
		"filter the rows which have to be deleted"
		where: app_assignments_bool_exp!
	): app_assignments_mutation_response
	"delete single row from the table: \"app.assignments\""
	delete_app_assignments_by_pk(uuid: uuid!): app_assignments
	"delete data from the table: \"app.assignments_v2\""
	delete_app_assignments_v2(
		"filter the rows which have to be deleted"
		where: app_assignments_v2_bool_exp!
	): app_assignments_v2_mutation_response
	"delete data from the table: \"app.assignments_v2_assignment_labels_v2\""
	delete_app_assignments_v2_assignment_labels_v2(
		"filter the rows which have to be deleted"
		where: app_assignments_v2_assignment_labels_v2_bool_exp!
	): app_assignments_v2_assignment_labels_v2_mutation_response
	"delete single row from the table: \"app.assignments_v2_assignment_labels_v2\""
	delete_app_assignments_v2_assignment_labels_v2_by_pk(
		id: Int!
	): app_assignments_v2_assignment_labels_v2
	"delete single row from the table: \"app.assignments_v2\""
	delete_app_assignments_v2_by_pk(id: uuid!): app_assignments_v2
	"delete data from the table: \"app.collection_bookmarks\""
	delete_app_collection_bookmarks(
		"filter the rows which have to be deleted"
		where: app_collection_bookmarks_bool_exp!
	): app_collection_bookmarks_mutation_response
	"delete single row from the table: \"app.collection_bookmarks\""
	delete_app_collection_bookmarks_by_pk(id: Int!): app_collection_bookmarks
	"delete data from the table: \"app.collection_fragments\""
	delete_app_collection_fragments(
		"filter the rows which have to be deleted"
		where: app_collection_fragments_bool_exp!
	): app_collection_fragments_mutation_response
	"delete single row from the table: \"app.collection_fragments\""
	delete_app_collection_fragments_by_pk(id: Int!): app_collection_fragments
	"delete data from the table: \"app.collection_labels\""
	delete_app_collection_labels(
		"filter the rows which have to be deleted"
		where: app_collection_labels_bool_exp!
	): app_collection_labels_mutation_response
	"delete single row from the table: \"app.collection_labels\""
	delete_app_collection_labels_by_pk(id: Int!): app_collection_labels
	"delete data from the table: \"app.collection_management\""
	delete_app_collection_management(
		"filter the rows which have to be deleted"
		where: app_collection_management_bool_exp!
	): app_collection_management_mutation_response
	"delete data from the table: \"app.collection_management_QC\""
	delete_app_collection_management_QC(
		"filter the rows which have to be deleted"
		where: app_collection_management_QC_bool_exp!
	): app_collection_management_QC_mutation_response
	"delete single row from the table: \"app.collection_management_QC\""
	delete_app_collection_management_QC_by_pk(id: Int!): app_collection_management_QC
	"delete single row from the table: \"app.collection_management\""
	delete_app_collection_management_by_pk(id: Int!): app_collection_management
	"delete data from the table: \"app.collection_marcom_log\""
	delete_app_collection_marcom_log(
		"filter the rows which have to be deleted"
		where: app_collection_marcom_log_bool_exp!
	): app_collection_marcom_log_mutation_response
	"delete single row from the table: \"app.collection_marcom_log\""
	delete_app_collection_marcom_log_by_pk(id: Int!): app_collection_marcom_log
	"delete data from the table: \"app.collection_marcom_notes\""
	delete_app_collection_marcom_notes(
		"filter the rows which have to be deleted"
		where: app_collection_marcom_notes_bool_exp!
	): app_collection_marcom_notes_mutation_response
	"delete single row from the table: \"app.collection_marcom_notes\""
	delete_app_collection_marcom_notes_by_pk(collection_id: uuid!): app_collection_marcom_notes
	"delete data from the table: \"app.collection_plays\""
	delete_app_collection_plays(
		"filter the rows which have to be deleted"
		where: app_collection_plays_bool_exp!
	): app_collection_plays_mutation_response
	"delete single row from the table: \"app.collection_plays\""
	delete_app_collection_plays_by_pk(id: Int!): app_collection_plays
	"delete data from the table: \"app.collection_relations\""
	delete_app_collection_relations(
		"filter the rows which have to be deleted"
		where: app_collection_relations_bool_exp!
	): app_collection_relations_mutation_response
	"delete single row from the table: \"app.collection_relations\""
	delete_app_collection_relations_by_pk(id: Int!): app_collection_relations
	"delete data from the table: \"app.collection_views\""
	delete_app_collection_views(
		"filter the rows which have to be deleted"
		where: app_collection_views_bool_exp!
	): app_collection_views_mutation_response
	"delete single row from the table: \"app.collection_views\""
	delete_app_collection_views_by_pk(id: Int!): app_collection_views
	"delete data from the table: \"app.collections\""
	delete_app_collections(
		"filter the rows which have to be deleted"
		where: app_collections_bool_exp!
	): app_collections_mutation_response
	"delete single row from the table: \"app.collections\""
	delete_app_collections_by_pk(id: uuid!): app_collections
	"delete data from the table: \"app.content\""
	delete_app_content(
		"filter the rows which have to be deleted"
		where: app_content_bool_exp!
	): app_content_mutation_response
	"delete data from the table: \"app.content_assets\""
	delete_app_content_assets(
		"filter the rows which have to be deleted"
		where: app_content_assets_bool_exp!
	): app_content_assets_mutation_response
	"delete single row from the table: \"app.content_assets\""
	delete_app_content_assets_by_pk(id: Int!): app_content_assets
	"delete data from the table: \"app.content_blocks\""
	delete_app_content_blocks(
		"filter the rows which have to be deleted"
		where: app_content_blocks_bool_exp!
	): app_content_blocks_mutation_response
	"delete single row from the table: \"app.content_blocks\""
	delete_app_content_blocks_by_pk(id: Int!): app_content_blocks
	"delete single row from the table: \"app.content\""
	delete_app_content_by_pk(id: Int!): app_content
	"delete data from the table: \"app.content_content_labels\""
	delete_app_content_content_labels(
		"filter the rows which have to be deleted"
		where: app_content_content_labels_bool_exp!
	): app_content_content_labels_mutation_response
	"delete single row from the table: \"app.content_content_labels\""
	delete_app_content_content_labels_by_pk(id: Int!): app_content_content_labels
	"delete data from the table: \"app.content_labels\""
	delete_app_content_labels(
		"filter the rows which have to be deleted"
		where: app_content_labels_bool_exp!
	): app_content_labels_mutation_response
	"delete single row from the table: \"app.content_labels\""
	delete_app_content_labels_by_pk(id: Int!): app_content_labels
	"delete data from the table: \"app.content_lower_title\""
	delete_app_content_lower_title(
		"filter the rows which have to be deleted"
		where: app_content_lower_title_bool_exp!
	): app_content_lower_title_mutation_response
	"delete data from the table: \"app.content_nav_elements\""
	delete_app_content_nav_elements(
		"filter the rows which have to be deleted"
		where: app_content_nav_elements_bool_exp!
	): app_content_nav_elements_mutation_response
	"delete single row from the table: \"app.content_nav_elements\""
	delete_app_content_nav_elements_by_pk(id: Int!): app_content_nav_elements
	"delete data from the table: \"app.interactive_tour\""
	delete_app_interactive_tour(
		"filter the rows which have to be deleted"
		where: app_interactive_tour_bool_exp!
	): app_interactive_tour_mutation_response
	"delete single row from the table: \"app.interactive_tour\""
	delete_app_interactive_tour_by_pk(id: Int!): app_interactive_tour
	"delete data from the table: \"app.item_bookmarks\""
	delete_app_item_bookmarks(
		"filter the rows which have to be deleted"
		where: app_item_bookmarks_bool_exp!
	): app_item_bookmarks_mutation_response
	"delete single row from the table: \"app.item_bookmarks\""
	delete_app_item_bookmarks_by_pk(id: Int!): app_item_bookmarks
	"delete data from the table: \"app.item_collateral\""
	delete_app_item_collateral(
		"filter the rows which have to be deleted"
		where: app_item_collateral_bool_exp!
	): app_item_collateral_mutation_response
	"delete single row from the table: \"app.item_collateral\""
	delete_app_item_collateral_by_pk(external_id: String!): app_item_collateral
	"delete data from the table: \"app.item_meta\""
	delete_app_item_meta(
		"filter the rows which have to be deleted"
		where: app_item_meta_bool_exp!
	): app_item_meta_mutation_response
	"delete single row from the table: \"app.item_meta\""
	delete_app_item_meta_by_pk(id: Int!): app_item_meta
	"delete data from the table: \"app.item_plays\""
	delete_app_item_plays(
		"filter the rows which have to be deleted"
		where: app_item_plays_bool_exp!
	): app_item_plays_mutation_response
	"delete single row from the table: \"app.item_plays\""
	delete_app_item_plays_by_pk(id: Int!): app_item_plays
	"delete data from the table: \"app.item_relations\""
	delete_app_item_relations(
		"filter the rows which have to be deleted"
		where: app_item_relations_bool_exp!
	): app_item_relations_mutation_response
	"delete single row from the table: \"app.item_relations\""
	delete_app_item_relations_by_pk(id: Int!): app_item_relations
	"delete data from the table: \"app.item_score\""
	delete_app_item_score(
		"filter the rows which have to be deleted"
		where: app_item_score_bool_exp!
	): app_item_score_mutation_response
	"delete single row from the table: \"app.item_score\""
	delete_app_item_score_by_pk(id: Int!): app_item_score
	"delete data from the table: \"app.item_views\""
	delete_app_item_views(
		"filter the rows which have to be deleted"
		where: app_item_views_bool_exp!
	): app_item_views_mutation_response
	"delete single row from the table: \"app.item_views\""
	delete_app_item_views_by_pk(id: Int!): app_item_views
	"delete data from the table: \"app.pupil_collection_blocks\""
	delete_app_pupil_collection_blocks(
		"filter the rows which have to be deleted"
		where: app_pupil_collection_blocks_bool_exp!
	): app_pupil_collection_blocks_mutation_response
	"delete single row from the table: \"app.pupil_collection_blocks\""
	delete_app_pupil_collection_blocks_by_pk(id: uuid!): app_pupil_collection_blocks
	"delete data from the table: \"app.quick_lanes\""
	delete_app_quick_lanes(
		"filter the rows which have to be deleted"
		where: app_quick_lanes_bool_exp!
	): app_quick_lanes_mutation_response
	"delete single row from the table: \"app.quick_lanes\""
	delete_app_quick_lanes_by_pk(id: uuid!): app_quick_lanes
	"delete data from the table: \"app.search_bookmarks\""
	delete_app_search_bookmarks(
		"filter the rows which have to be deleted"
		where: app_search_bookmarks_bool_exp!
	): app_search_bookmarks_mutation_response
	"delete single row from the table: \"app.search_bookmarks\""
	delete_app_search_bookmarks_by_pk(id: uuid!): app_search_bookmarks
	"delete data from the table: \"app.site_variables\""
	delete_app_site_variables(
		"filter the rows which have to be deleted"
		where: app_site_variables_bool_exp!
	): app_site_variables_mutation_response
	"delete single row from the table: \"app.site_variables\""
	delete_app_site_variables_by_pk(name: String!): app_site_variables
	"delete data from the table: \"lookup.enum_assignment_content_labels\""
	delete_lookup_enum_assignment_content_labels(
		"filter the rows which have to be deleted"
		where: lookup_enum_assignment_content_labels_bool_exp!
	): lookup_enum_assignment_content_labels_mutation_response
	"delete single row from the table: \"lookup.enum_assignment_content_labels\""
	delete_lookup_enum_assignment_content_labels_by_pk(
		value: String!
	): lookup_enum_assignment_content_labels
	"delete data from the table: \"lookup.enum_assignment_types\""
	delete_lookup_enum_assignment_types(
		"filter the rows which have to be deleted"
		where: lookup_enum_assignment_types_bool_exp!
	): lookup_enum_assignment_types_mutation_response
	"delete single row from the table: \"lookup.enum_assignment_types\""
	delete_lookup_enum_assignment_types_by_pk(value: String!): lookup_enum_assignment_types
	"delete data from the table: \"lookup.enum_collection_labels\""
	delete_lookup_enum_collection_labels(
		"filter the rows which have to be deleted"
		where: lookup_enum_collection_labels_bool_exp!
	): lookup_enum_collection_labels_mutation_response
	"delete single row from the table: \"lookup.enum_collection_labels\""
	delete_lookup_enum_collection_labels_by_pk(value: String!): lookup_enum_collection_labels
	"delete data from the table: \"lookup.enum_collection_management_qc_label\""
	delete_lookup_enum_collection_management_qc_label(
		"filter the rows which have to be deleted"
		where: lookup_enum_collection_management_qc_label_bool_exp!
	): lookup_enum_collection_management_qc_label_mutation_response
	"delete single row from the table: \"lookup.enum_collection_management_qc_label\""
	delete_lookup_enum_collection_management_qc_label_by_pk(
		value: String!
	): lookup_enum_collection_management_qc_label
	"delete data from the table: \"lookup.enum_collection_management_status\""
	delete_lookup_enum_collection_management_status(
		"filter the rows which have to be deleted"
		where: lookup_enum_collection_management_status_bool_exp!
	): lookup_enum_collection_management_status_mutation_response
	"delete single row from the table: \"lookup.enum_collection_management_status\""
	delete_lookup_enum_collection_management_status_by_pk(
		value: String!
	): lookup_enum_collection_management_status
	"delete data from the table: \"lookup.enum_colors\""
	delete_lookup_enum_colors(
		"filter the rows which have to be deleted"
		where: lookup_enum_colors_bool_exp!
	): lookup_enum_colors_mutation_response
	"delete single row from the table: \"lookup.enum_colors\""
	delete_lookup_enum_colors_by_pk(value: String!): lookup_enum_colors
	"delete data from the table: \"lookup.enum_content_block_types\""
	delete_lookup_enum_content_block_types(
		"filter the rows which have to be deleted"
		where: lookup_enum_content_block_types_bool_exp!
	): lookup_enum_content_block_types_mutation_response
	"delete single row from the table: \"lookup.enum_content_block_types\""
	delete_lookup_enum_content_block_types_by_pk(value: String!): lookup_enum_content_block_types
	"delete data from the table: \"lookup.enum_content_types\""
	delete_lookup_enum_content_types(
		"filter the rows which have to be deleted"
		where: lookup_enum_content_types_bool_exp!
	): lookup_enum_content_types_mutation_response
	"delete single row from the table: \"lookup.enum_content_types\""
	delete_lookup_enum_content_types_by_pk(value: String!): lookup_enum_content_types
	"delete data from the table: \"lookup.enum_input_types\""
	delete_lookup_enum_input_types(
		"filter the rows which have to be deleted"
		where: lookup_enum_input_types_bool_exp!
	): lookup_enum_input_types_mutation_response
	"delete single row from the table: \"lookup.enum_input_types\""
	delete_lookup_enum_input_types_by_pk(value: String!): lookup_enum_input_types
	"delete data from the table: \"lookup.enum_lom_classification\""
	delete_lookup_enum_lom_classification(
		"filter the rows which have to be deleted"
		where: lookup_enum_lom_classification_bool_exp!
	): lookup_enum_lom_classification_mutation_response
	"delete single row from the table: \"lookup.enum_lom_classification\""
	delete_lookup_enum_lom_classification_by_pk(value: String!): lookup_enum_lom_classification
	"delete data from the table: \"lookup.enum_lom_context\""
	delete_lookup_enum_lom_context(
		"filter the rows which have to be deleted"
		where: lookup_enum_lom_context_bool_exp!
	): lookup_enum_lom_context_mutation_response
	"delete single row from the table: \"lookup.enum_lom_context\""
	delete_lookup_enum_lom_context_by_pk(value: String!): lookup_enum_lom_context
	"delete data from the table: \"lookup.enum_profile_flags\""
	delete_lookup_enum_profile_flags(
		"filter the rows which have to be deleted"
		where: lookup_enum_profile_flags_bool_exp!
	): lookup_enum_profile_flags_mutation_response
	"delete single row from the table: \"lookup.enum_profile_flags\""
	delete_lookup_enum_profile_flags_by_pk(value: String!): lookup_enum_profile_flags
	"delete data from the table: \"lookup.enum_profile_preferences_keys\""
	delete_lookup_enum_profile_preferences_keys(
		"filter the rows which have to be deleted"
		where: lookup_enum_profile_preferences_keys_bool_exp!
	): lookup_enum_profile_preferences_keys_mutation_response
	"delete single row from the table: \"lookup.enum_profile_preferences_keys\""
	delete_lookup_enum_profile_preferences_keys_by_pk(
		value: String!
	): lookup_enum_profile_preferences_keys
	"delete data from the table: \"lookup.enum_relation_types\""
	delete_lookup_enum_relation_types(
		"filter the rows which have to be deleted"
		where: lookup_enum_relation_types_bool_exp!
	): lookup_enum_relation_types_mutation_response
	"delete single row from the table: \"lookup.enum_relation_types\""
	delete_lookup_enum_relation_types_by_pk(value: String!): lookup_enum_relation_types
	"delete data from the table: \"lookup.enum_search_bookmark_types\""
	delete_lookup_enum_search_bookmark_types(
		"filter the rows which have to be deleted"
		where: lookup_enum_search_bookmark_types_bool_exp!
	): lookup_enum_search_bookmark_types_mutation_response
	"delete single row from the table: \"lookup.enum_search_bookmark_types\""
	delete_lookup_enum_search_bookmark_types_by_pk(
		value: String!
	): lookup_enum_search_bookmark_types
	"delete data from the table: \"lookup.thesaurus\""
	delete_lookup_thesaurus(
		"filter the rows which have to be deleted"
		where: lookup_thesaurus_bool_exp!
	): lookup_thesaurus_mutation_response
	"delete single row from the table: \"lookup.thesaurus\""
	delete_lookup_thesaurus_by_pk(id: String!): lookup_thesaurus
	"delete data from the table: \"migrate.original_publishdate\""
	delete_migrate_original_publishdate(
		"filter the rows which have to be deleted"
		where: migrate_original_publishdate_bool_exp!
	): migrate_original_publishdate_mutation_response
	"delete single row from the table: \"migrate.original_publishdate\""
	delete_migrate_original_publishdate_by_pk(mediamosa_id: String!): migrate_original_publishdate
	"delete data from the table: \"migrate.reference_ids\""
	delete_migrate_reference_ids(
		"filter the rows which have to be deleted"
		where: migrate_reference_ids_bool_exp!
	): migrate_reference_ids_mutation_response
	"delete single row from the table: \"migrate.reference_ids\""
	delete_migrate_reference_ids_by_pk(id: Int!): migrate_reference_ids
	"delete data from the table: \"shared.collateral\""
	delete_shared_collateral(
		"filter the rows which have to be deleted"
		where: shared_collateral_bool_exp!
	): shared_collateral_mutation_response
	"delete single row from the table: \"shared.collateral\""
	delete_shared_collateral_by_pk(id: Int!): shared_collateral
	"delete data from the table: \"shared.items\""
	delete_shared_items(
		"filter the rows which have to be deleted"
		where: shared_items_bool_exp!
	): shared_items_mutation_response
	"delete single row from the table: \"shared.items\""
	delete_shared_items_by_pk(id: Int!): shared_items
	"delete data from the table: \"shared.ldap_organizations\""
	delete_shared_ldap_organizations(
		"filter the rows which have to be deleted"
		where: shared_ldap_organizations_bool_exp!
	): shared_ldap_organizations_mutation_response
	"delete single row from the table: \"shared.ldap_organizations\""
	delete_shared_ldap_organizations_by_pk(id: Int!): shared_ldap_organizations
	"delete data from the table: \"shared.organisations\""
	delete_shared_organisations(
		"filter the rows which have to be deleted"
		where: shared_organisations_bool_exp!
	): shared_organisations_mutation_response
	"delete single row from the table: \"shared.organisations\""
	delete_shared_organisations_by_pk(or_id: String!): shared_organisations
	"delete data from the table: \"shared.types\""
	delete_shared_types(
		"filter the rows which have to be deleted"
		where: shared_types_bool_exp!
	): shared_types_mutation_response
	"delete single row from the table: \"shared.types\""
	delete_shared_types_by_pk(id: Int!): shared_types
	"delete data from the table: \"shared.user_roles\""
	delete_shared_user_roles(
		"filter the rows which have to be deleted"
		where: shared_user_roles_bool_exp!
	): shared_user_roles_mutation_response
	"delete single row from the table: \"shared.user_roles\""
	delete_shared_user_roles_by_pk(id: Int!): shared_user_roles
	"delete data from the table: \"shared.user_temp_access\""
	delete_shared_user_temp_access(
		"filter the rows which have to be deleted"
		where: shared_user_temp_access_bool_exp!
	): shared_user_temp_access_mutation_response
	"delete single row from the table: \"shared.user_temp_access\""
	delete_shared_user_temp_access_by_pk(user_id: uuid!): shared_user_temp_access
	"delete data from the table: \"shared.users\""
	delete_shared_users(
		"filter the rows which have to be deleted"
		where: shared_users_bool_exp!
	): shared_users_mutation_response
	"delete single row from the table: \"shared.users\""
	delete_shared_users_by_pk(uid: uuid!): shared_users
	"delete data from the table: \"users.audit_log\""
	delete_users_audit_log(
		"filter the rows which have to be deleted"
		where: users_audit_log_bool_exp!
	): users_audit_log_mutation_response
	"delete single row from the table: \"users.audit_log\""
	delete_users_audit_log_by_pk(id: Int!): users_audit_log
	"delete data from the table: \"users.email_preferences\""
	delete_users_email_preferences(
		"filter the rows which have to be deleted"
		where: users_email_preferences_bool_exp!
	): users_email_preferences_mutation_response
	"delete single row from the table: \"users.email_preferences\""
	delete_users_email_preferences_by_pk(id: uuid!): users_email_preferences
	"delete data from the table: \"users.group_user_permission_groups\""
	delete_users_group_user_permission_groups(
		"filter the rows which have to be deleted"
		where: users_group_user_permission_groups_bool_exp!
	): users_group_user_permission_groups_mutation_response
	"delete single row from the table: \"users.group_user_permission_groups\""
	delete_users_group_user_permission_groups_by_pk(id: Int!): users_group_user_permission_groups
	"delete data from the table: \"users.groups\""
	delete_users_groups(
		"filter the rows which have to be deleted"
		where: users_groups_bool_exp!
	): users_groups_mutation_response
	"delete single row from the table: \"users.groups\""
	delete_users_groups_by_pk(id: Int!): users_groups
	"delete data from the table: \"users.idp_map\""
	delete_users_idp_map(
		"filter the rows which have to be deleted"
		where: users_idp_map_bool_exp!
	): users_idp_map_mutation_response
	"delete single row from the table: \"users.idp_map\""
	delete_users_idp_map_by_pk(id: Int!): users_idp_map
	"delete data from the table: \"users.idps\""
	delete_users_idps(
		"filter the rows which have to be deleted"
		where: users_idps_bool_exp!
	): users_idps_mutation_response
	"delete single row from the table: \"users.idps\""
	delete_users_idps_by_pk(value: String!): users_idps
	"delete data from the table: \"users.notifications\""
	delete_users_notifications(
		"filter the rows which have to be deleted"
		where: users_notifications_bool_exp!
	): users_notifications_mutation_response
	"delete single row from the table: \"users.notifications\""
	delete_users_notifications_by_pk(id: uuid!): users_notifications
	"delete data from the table: \"users.permission_group_user_permissions\""
	delete_users_permission_group_user_permissions(
		"filter the rows which have to be deleted"
		where: users_permission_group_user_permissions_bool_exp!
	): users_permission_group_user_permissions_mutation_response
	"delete single row from the table: \"users.permission_group_user_permissions\""
	delete_users_permission_group_user_permissions_by_pk(
		id: Int!
	): users_permission_group_user_permissions
	"delete data from the table: \"users.permission_groups\""
	delete_users_permission_groups(
		"filter the rows which have to be deleted"
		where: users_permission_groups_bool_exp!
	): users_permission_groups_mutation_response
	"delete single row from the table: \"users.permission_groups\""
	delete_users_permission_groups_by_pk(id: Int!): users_permission_groups
	"delete data from the table: \"users.permission_matrix_view\""
	delete_users_permission_matrix_view(
		"filter the rows which have to be deleted"
		where: users_permission_matrix_view_bool_exp!
	): users_permission_matrix_view_mutation_response
	"delete data from the table: \"users.permissions\""
	delete_users_permissions(
		"filter the rows which have to be deleted"
		where: users_permissions_bool_exp!
	): users_permissions_mutation_response
	"delete single row from the table: \"users.permissions\""
	delete_users_permissions_by_pk(id: Int!): users_permissions
	"delete data from the table: \"users.profile_classifications\""
	delete_users_profile_classifications(
		"filter the rows which have to be deleted"
		where: users_profile_classifications_bool_exp!
	): users_profile_classifications_mutation_response
	"delete single row from the table: \"users.profile_classifications\""
	delete_users_profile_classifications_by_pk(id: uuid!): users_profile_classifications
	"delete data from the table: \"users.profile_contexts\""
	delete_users_profile_contexts(
		"filter the rows which have to be deleted"
		where: users_profile_contexts_bool_exp!
	): users_profile_contexts_mutation_response
	"delete single row from the table: \"users.profile_contexts\""
	delete_users_profile_contexts_by_pk(id: uuid!): users_profile_contexts
	"delete data from the table: \"users.profile_flags\""
	delete_users_profile_flags(
		"filter the rows which have to be deleted"
		where: users_profile_flags_bool_exp!
	): users_profile_flags_mutation_response
	"delete single row from the table: \"users.profile_flags\""
	delete_users_profile_flags_by_pk(id: Int!): users_profile_flags
	"delete data from the table: \"users.profile_organizations\""
	delete_users_profile_organizations(
		"filter the rows which have to be deleted"
		where: users_profile_organizations_bool_exp!
	): users_profile_organizations_mutation_response
	"delete single row from the table: \"users.profile_organizations\""
	delete_users_profile_organizations_by_pk(id: uuid!): users_profile_organizations
	"delete data from the table: \"users.profile_preferences\""
	delete_users_profile_preferences(
		"filter the rows which have to be deleted"
		where: users_profile_preferences_bool_exp!
	): users_profile_preferences_mutation_response
	"delete single row from the table: \"users.profile_preferences\""
	delete_users_profile_preferences_by_pk(id: Int!): users_profile_preferences
	"delete data from the table: \"users.profile_user_groups\""
	delete_users_profile_user_groups(
		"filter the rows which have to be deleted"
		where: users_profile_user_groups_bool_exp!
	): users_profile_user_groups_mutation_response
	"delete single row from the table: \"users.profile_user_groups\""
	delete_users_profile_user_groups_by_pk(id: Int!): users_profile_user_groups
	"delete data from the table: \"users.profiles\""
	delete_users_profiles(
		"filter the rows which have to be deleted"
		where: users_profiles_bool_exp!
	): users_profiles_mutation_response
	"delete single row from the table: \"users.profiles\""
	delete_users_profiles_by_pk(
		"Een gebruiker kan een of meer profielen hebben"
		id: uuid!
	): users_profiles
	"insert data into the table: \"app.assignment_assignment_tags\""
	insert_app_assignment_assignment_tags(
		"the rows to be inserted"
		objects: [app_assignment_assignment_tags_insert_input!]!
		"on conflict condition"
		on_conflict: app_assignment_assignment_tags_on_conflict
	): app_assignment_assignment_tags_mutation_response
	"insert a single row into the table: \"app.assignment_assignment_tags\""
	insert_app_assignment_assignment_tags_one(
		"the row to be inserted"
		object: app_assignment_assignment_tags_insert_input!
		"on conflict condition"
		on_conflict: app_assignment_assignment_tags_on_conflict
	): app_assignment_assignment_tags
	"insert data into the table: \"app.assignment_blocks_v2\""
	insert_app_assignment_blocks_v2(
		"the rows to be inserted"
		objects: [app_assignment_blocks_v2_insert_input!]!
		"on conflict condition"
		on_conflict: app_assignment_blocks_v2_on_conflict
	): app_assignment_blocks_v2_mutation_response
	"insert a single row into the table: \"app.assignment_blocks_v2\""
	insert_app_assignment_blocks_v2_one(
		"the row to be inserted"
		object: app_assignment_blocks_v2_insert_input!
		"on conflict condition"
		on_conflict: app_assignment_blocks_v2_on_conflict
	): app_assignment_blocks_v2
	"insert data into the table: \"app.assignment_labels\""
	insert_app_assignment_labels(
		"the rows to be inserted"
		objects: [app_assignment_labels_insert_input!]!
		"on conflict condition"
		on_conflict: app_assignment_labels_on_conflict
	): app_assignment_labels_mutation_response
	"insert a single row into the table: \"app.assignment_labels\""
	insert_app_assignment_labels_one(
		"the row to be inserted"
		object: app_assignment_labels_insert_input!
		"on conflict condition"
		on_conflict: app_assignment_labels_on_conflict
	): app_assignment_labels
	"insert data into the table: \"app.assignment_labels_v2\""
	insert_app_assignment_labels_v2(
		"the rows to be inserted"
		objects: [app_assignment_labels_v2_insert_input!]!
		"on conflict condition"
		on_conflict: app_assignment_labels_v2_on_conflict
	): app_assignment_labels_v2_mutation_response
	"insert a single row into the table: \"app.assignment_labels_v2\""
	insert_app_assignment_labels_v2_one(
		"the row to be inserted"
		object: app_assignment_labels_v2_insert_input!
		"on conflict condition"
		on_conflict: app_assignment_labels_v2_on_conflict
	): app_assignment_labels_v2
	"insert data into the table: \"app.assignment_responses\""
	insert_app_assignment_responses(
		"the rows to be inserted"
		objects: [app_assignment_responses_insert_input!]!
		"on conflict condition"
		on_conflict: app_assignment_responses_on_conflict
	): app_assignment_responses_mutation_response
	"insert a single row into the table: \"app.assignment_responses\""
	insert_app_assignment_responses_one(
		"the row to be inserted"
		object: app_assignment_responses_insert_input!
		"on conflict condition"
		on_conflict: app_assignment_responses_on_conflict
	): app_assignment_responses
	"insert data into the table: \"app.assignment_responses_v2\""
	insert_app_assignment_responses_v2(
		"the rows to be inserted"
		objects: [app_assignment_responses_v2_insert_input!]!
		"on conflict condition"
		on_conflict: app_assignment_responses_v2_on_conflict
	): app_assignment_responses_v2_mutation_response
	"insert a single row into the table: \"app.assignment_responses_v2\""
	insert_app_assignment_responses_v2_one(
		"the row to be inserted"
		object: app_assignment_responses_v2_insert_input!
		"on conflict condition"
		on_conflict: app_assignment_responses_v2_on_conflict
	): app_assignment_responses_v2
	"insert data into the table: \"app.assignment_v2_views\""
	insert_app_assignment_v2_views(
		"the rows to be inserted"
		objects: [app_assignment_v2_views_insert_input!]!
		"on conflict condition"
		on_conflict: app_assignment_v2_views_on_conflict
	): app_assignment_v2_views_mutation_response
	"insert a single row into the table: \"app.assignment_v2_views\""
	insert_app_assignment_v2_views_one(
		"the row to be inserted"
		object: app_assignment_v2_views_insert_input!
		"on conflict condition"
		on_conflict: app_assignment_v2_views_on_conflict
	): app_assignment_v2_views
	"insert data into the table: \"app.assignments\""
	insert_app_assignments(
		"the rows to be inserted"
		objects: [app_assignments_insert_input!]!
		"on conflict condition"
		on_conflict: app_assignments_on_conflict
	): app_assignments_mutation_response
	"insert a single row into the table: \"app.assignments\""
	insert_app_assignments_one(
		"the row to be inserted"
		object: app_assignments_insert_input!
		"on conflict condition"
		on_conflict: app_assignments_on_conflict
	): app_assignments
	"insert data into the table: \"app.assignments_v2\""
	insert_app_assignments_v2(
		"the rows to be inserted"
		objects: [app_assignments_v2_insert_input!]!
		"on conflict condition"
		on_conflict: app_assignments_v2_on_conflict
	): app_assignments_v2_mutation_response
	"insert data into the table: \"app.assignments_v2_assignment_labels_v2\""
	insert_app_assignments_v2_assignment_labels_v2(
		"the rows to be inserted"
		objects: [app_assignments_v2_assignment_labels_v2_insert_input!]!
		"on conflict condition"
		on_conflict: app_assignments_v2_assignment_labels_v2_on_conflict
	): app_assignments_v2_assignment_labels_v2_mutation_response
	"insert a single row into the table: \"app.assignments_v2_assignment_labels_v2\""
	insert_app_assignments_v2_assignment_labels_v2_one(
		"the row to be inserted"
		object: app_assignments_v2_assignment_labels_v2_insert_input!
		"on conflict condition"
		on_conflict: app_assignments_v2_assignment_labels_v2_on_conflict
	): app_assignments_v2_assignment_labels_v2
	"insert a single row into the table: \"app.assignments_v2\""
	insert_app_assignments_v2_one(
		"the row to be inserted"
		object: app_assignments_v2_insert_input!
		"on conflict condition"
		on_conflict: app_assignments_v2_on_conflict
	): app_assignments_v2
	"insert data into the table: \"app.collection_bookmarks\""
	insert_app_collection_bookmarks(
		"the rows to be inserted"
		objects: [app_collection_bookmarks_insert_input!]!
		"on conflict condition"
		on_conflict: app_collection_bookmarks_on_conflict
	): app_collection_bookmarks_mutation_response
	"insert a single row into the table: \"app.collection_bookmarks\""
	insert_app_collection_bookmarks_one(
		"the row to be inserted"
		object: app_collection_bookmarks_insert_input!
		"on conflict condition"
		on_conflict: app_collection_bookmarks_on_conflict
	): app_collection_bookmarks
	"insert data into the table: \"app.collection_fragments\""
	insert_app_collection_fragments(
		"the rows to be inserted"
		objects: [app_collection_fragments_insert_input!]!
		"on conflict condition"
		on_conflict: app_collection_fragments_on_conflict
	): app_collection_fragments_mutation_response
	"insert a single row into the table: \"app.collection_fragments\""
	insert_app_collection_fragments_one(
		"the row to be inserted"
		object: app_collection_fragments_insert_input!
		"on conflict condition"
		on_conflict: app_collection_fragments_on_conflict
	): app_collection_fragments
	"insert data into the table: \"app.collection_labels\""
	insert_app_collection_labels(
		"the rows to be inserted"
		objects: [app_collection_labels_insert_input!]!
		"on conflict condition"
		on_conflict: app_collection_labels_on_conflict
	): app_collection_labels_mutation_response
	"insert a single row into the table: \"app.collection_labels\""
	insert_app_collection_labels_one(
		"the row to be inserted"
		object: app_collection_labels_insert_input!
		"on conflict condition"
		on_conflict: app_collection_labels_on_conflict
	): app_collection_labels
	"insert data into the table: \"app.collection_management\""
	insert_app_collection_management(
		"the rows to be inserted"
		objects: [app_collection_management_insert_input!]!
		"on conflict condition"
		on_conflict: app_collection_management_on_conflict
	): app_collection_management_mutation_response
	"insert data into the table: \"app.collection_management_QC\""
	insert_app_collection_management_QC(
		"the rows to be inserted"
		objects: [app_collection_management_QC_insert_input!]!
		"on conflict condition"
		on_conflict: app_collection_management_QC_on_conflict
	): app_collection_management_QC_mutation_response
	"insert a single row into the table: \"app.collection_management_QC\""
	insert_app_collection_management_QC_one(
		"the row to be inserted"
		object: app_collection_management_QC_insert_input!
		"on conflict condition"
		on_conflict: app_collection_management_QC_on_conflict
	): app_collection_management_QC
	"insert a single row into the table: \"app.collection_management\""
	insert_app_collection_management_one(
		"the row to be inserted"
		object: app_collection_management_insert_input!
		"on conflict condition"
		on_conflict: app_collection_management_on_conflict
	): app_collection_management
	"insert data into the table: \"app.collection_marcom_log\""
	insert_app_collection_marcom_log(
		"the rows to be inserted"
		objects: [app_collection_marcom_log_insert_input!]!
		"on conflict condition"
		on_conflict: app_collection_marcom_log_on_conflict
	): app_collection_marcom_log_mutation_response
	"insert a single row into the table: \"app.collection_marcom_log\""
	insert_app_collection_marcom_log_one(
		"the row to be inserted"
		object: app_collection_marcom_log_insert_input!
		"on conflict condition"
		on_conflict: app_collection_marcom_log_on_conflict
	): app_collection_marcom_log
	"insert data into the table: \"app.collection_marcom_notes\""
	insert_app_collection_marcom_notes(
		"the rows to be inserted"
		objects: [app_collection_marcom_notes_insert_input!]!
		"on conflict condition"
		on_conflict: app_collection_marcom_notes_on_conflict
	): app_collection_marcom_notes_mutation_response
	"insert a single row into the table: \"app.collection_marcom_notes\""
	insert_app_collection_marcom_notes_one(
		"the row to be inserted"
		object: app_collection_marcom_notes_insert_input!
		"on conflict condition"
		on_conflict: app_collection_marcom_notes_on_conflict
	): app_collection_marcom_notes
	"insert data into the table: \"app.collection_plays\""
	insert_app_collection_plays(
		"the rows to be inserted"
		objects: [app_collection_plays_insert_input!]!
		"on conflict condition"
		on_conflict: app_collection_plays_on_conflict
	): app_collection_plays_mutation_response
	"insert a single row into the table: \"app.collection_plays\""
	insert_app_collection_plays_one(
		"the row to be inserted"
		object: app_collection_plays_insert_input!
		"on conflict condition"
		on_conflict: app_collection_plays_on_conflict
	): app_collection_plays
	"insert data into the table: \"app.collection_relations\""
	insert_app_collection_relations(
		"the rows to be inserted"
		objects: [app_collection_relations_insert_input!]!
		"on conflict condition"
		on_conflict: app_collection_relations_on_conflict
	): app_collection_relations_mutation_response
	"insert a single row into the table: \"app.collection_relations\""
	insert_app_collection_relations_one(
		"the row to be inserted"
		object: app_collection_relations_insert_input!
		"on conflict condition"
		on_conflict: app_collection_relations_on_conflict
	): app_collection_relations
	"insert data into the table: \"app.collection_views\""
	insert_app_collection_views(
		"the rows to be inserted"
		objects: [app_collection_views_insert_input!]!
		"on conflict condition"
		on_conflict: app_collection_views_on_conflict
	): app_collection_views_mutation_response
	"insert a single row into the table: \"app.collection_views\""
	insert_app_collection_views_one(
		"the row to be inserted"
		object: app_collection_views_insert_input!
		"on conflict condition"
		on_conflict: app_collection_views_on_conflict
	): app_collection_views
	"insert data into the table: \"app.collections\""
	insert_app_collections(
		"the rows to be inserted"
		objects: [app_collections_insert_input!]!
		"on conflict condition"
		on_conflict: app_collections_on_conflict
	): app_collections_mutation_response
	"insert a single row into the table: \"app.collections\""
	insert_app_collections_one(
		"the row to be inserted"
		object: app_collections_insert_input!
		"on conflict condition"
		on_conflict: app_collections_on_conflict
	): app_collections
	"insert data into the table: \"app.content\""
	insert_app_content(
		"the rows to be inserted"
		objects: [app_content_insert_input!]!
		"on conflict condition"
		on_conflict: app_content_on_conflict
	): app_content_mutation_response
	"insert data into the table: \"app.content_assets\""
	insert_app_content_assets(
		"the rows to be inserted"
		objects: [app_content_assets_insert_input!]!
		"on conflict condition"
		on_conflict: app_content_assets_on_conflict
	): app_content_assets_mutation_response
	"insert a single row into the table: \"app.content_assets\""
	insert_app_content_assets_one(
		"the row to be inserted"
		object: app_content_assets_insert_input!
		"on conflict condition"
		on_conflict: app_content_assets_on_conflict
	): app_content_assets
	"insert data into the table: \"app.content_blocks\""
	insert_app_content_blocks(
		"the rows to be inserted"
		objects: [app_content_blocks_insert_input!]!
		"on conflict condition"
		on_conflict: app_content_blocks_on_conflict
	): app_content_blocks_mutation_response
	"insert a single row into the table: \"app.content_blocks\""
	insert_app_content_blocks_one(
		"the row to be inserted"
		object: app_content_blocks_insert_input!
		"on conflict condition"
		on_conflict: app_content_blocks_on_conflict
	): app_content_blocks
	"insert data into the table: \"app.content_content_labels\""
	insert_app_content_content_labels(
		"the rows to be inserted"
		objects: [app_content_content_labels_insert_input!]!
		"on conflict condition"
		on_conflict: app_content_content_labels_on_conflict
	): app_content_content_labels_mutation_response
	"insert a single row into the table: \"app.content_content_labels\""
	insert_app_content_content_labels_one(
		"the row to be inserted"
		object: app_content_content_labels_insert_input!
		"on conflict condition"
		on_conflict: app_content_content_labels_on_conflict
	): app_content_content_labels
	"insert data into the table: \"app.content_labels\""
	insert_app_content_labels(
		"the rows to be inserted"
		objects: [app_content_labels_insert_input!]!
		"on conflict condition"
		on_conflict: app_content_labels_on_conflict
	): app_content_labels_mutation_response
	"insert a single row into the table: \"app.content_labels\""
	insert_app_content_labels_one(
		"the row to be inserted"
		object: app_content_labels_insert_input!
		"on conflict condition"
		on_conflict: app_content_labels_on_conflict
	): app_content_labels
	"insert data into the table: \"app.content_lower_title\""
	insert_app_content_lower_title(
		"the rows to be inserted"
		objects: [app_content_lower_title_insert_input!]!
	): app_content_lower_title_mutation_response
	"insert a single row into the table: \"app.content_lower_title\""
	insert_app_content_lower_title_one(
		"the row to be inserted"
		object: app_content_lower_title_insert_input!
	): app_content_lower_title
	"insert data into the table: \"app.content_nav_elements\""
	insert_app_content_nav_elements(
		"the rows to be inserted"
		objects: [app_content_nav_elements_insert_input!]!
		"on conflict condition"
		on_conflict: app_content_nav_elements_on_conflict
	): app_content_nav_elements_mutation_response
	"insert a single row into the table: \"app.content_nav_elements\""
	insert_app_content_nav_elements_one(
		"the row to be inserted"
		object: app_content_nav_elements_insert_input!
		"on conflict condition"
		on_conflict: app_content_nav_elements_on_conflict
	): app_content_nav_elements
	"insert a single row into the table: \"app.content\""
	insert_app_content_one(
		"the row to be inserted"
		object: app_content_insert_input!
		"on conflict condition"
		on_conflict: app_content_on_conflict
	): app_content
	"insert data into the table: \"app.interactive_tour\""
	insert_app_interactive_tour(
		"the rows to be inserted"
		objects: [app_interactive_tour_insert_input!]!
		"on conflict condition"
		on_conflict: app_interactive_tour_on_conflict
	): app_interactive_tour_mutation_response
	"insert a single row into the table: \"app.interactive_tour\""
	insert_app_interactive_tour_one(
		"the row to be inserted"
		object: app_interactive_tour_insert_input!
		"on conflict condition"
		on_conflict: app_interactive_tour_on_conflict
	): app_interactive_tour
	"insert data into the table: \"app.item_bookmarks\""
	insert_app_item_bookmarks(
		"the rows to be inserted"
		objects: [app_item_bookmarks_insert_input!]!
		"on conflict condition"
		on_conflict: app_item_bookmarks_on_conflict
	): app_item_bookmarks_mutation_response
	"insert a single row into the table: \"app.item_bookmarks\""
	insert_app_item_bookmarks_one(
		"the row to be inserted"
		object: app_item_bookmarks_insert_input!
		"on conflict condition"
		on_conflict: app_item_bookmarks_on_conflict
	): app_item_bookmarks
	"insert data into the table: \"app.item_collateral\""
	insert_app_item_collateral(
		"the rows to be inserted"
		objects: [app_item_collateral_insert_input!]!
		"on conflict condition"
		on_conflict: app_item_collateral_on_conflict
	): app_item_collateral_mutation_response
	"insert a single row into the table: \"app.item_collateral\""
	insert_app_item_collateral_one(
		"the row to be inserted"
		object: app_item_collateral_insert_input!
		"on conflict condition"
		on_conflict: app_item_collateral_on_conflict
	): app_item_collateral
	"insert data into the table: \"app.item_meta\""
	insert_app_item_meta(
		"the rows to be inserted"
		objects: [app_item_meta_insert_input!]!
		"on conflict condition"
		on_conflict: app_item_meta_on_conflict
	): app_item_meta_mutation_response
	"insert a single row into the table: \"app.item_meta\""
	insert_app_item_meta_one(
		"the row to be inserted"
		object: app_item_meta_insert_input!
		"on conflict condition"
		on_conflict: app_item_meta_on_conflict
	): app_item_meta
	"insert data into the table: \"app.item_plays\""
	insert_app_item_plays(
		"the rows to be inserted"
		objects: [app_item_plays_insert_input!]!
		"on conflict condition"
		on_conflict: app_item_plays_on_conflict
	): app_item_plays_mutation_response
	"insert a single row into the table: \"app.item_plays\""
	insert_app_item_plays_one(
		"the row to be inserted"
		object: app_item_plays_insert_input!
		"on conflict condition"
		on_conflict: app_item_plays_on_conflict
	): app_item_plays
	"insert data into the table: \"app.item_relations\""
	insert_app_item_relations(
		"the rows to be inserted"
		objects: [app_item_relations_insert_input!]!
		"on conflict condition"
		on_conflict: app_item_relations_on_conflict
	): app_item_relations_mutation_response
	"insert a single row into the table: \"app.item_relations\""
	insert_app_item_relations_one(
		"the row to be inserted"
		object: app_item_relations_insert_input!
		"on conflict condition"
		on_conflict: app_item_relations_on_conflict
	): app_item_relations
	"insert data into the table: \"app.item_score\""
	insert_app_item_score(
		"the rows to be inserted"
		objects: [app_item_score_insert_input!]!
		"on conflict condition"
		on_conflict: app_item_score_on_conflict
	): app_item_score_mutation_response
	"insert a single row into the table: \"app.item_score\""
	insert_app_item_score_one(
		"the row to be inserted"
		object: app_item_score_insert_input!
		"on conflict condition"
		on_conflict: app_item_score_on_conflict
	): app_item_score
	"insert data into the table: \"app.item_views\""
	insert_app_item_views(
		"the rows to be inserted"
		objects: [app_item_views_insert_input!]!
		"on conflict condition"
		on_conflict: app_item_views_on_conflict
	): app_item_views_mutation_response
	"insert a single row into the table: \"app.item_views\""
	insert_app_item_views_one(
		"the row to be inserted"
		object: app_item_views_insert_input!
		"on conflict condition"
		on_conflict: app_item_views_on_conflict
	): app_item_views
	"insert data into the table: \"app.pupil_collection_blocks\""
	insert_app_pupil_collection_blocks(
		"the rows to be inserted"
		objects: [app_pupil_collection_blocks_insert_input!]!
		"on conflict condition"
		on_conflict: app_pupil_collection_blocks_on_conflict
	): app_pupil_collection_blocks_mutation_response
	"insert a single row into the table: \"app.pupil_collection_blocks\""
	insert_app_pupil_collection_blocks_one(
		"the row to be inserted"
		object: app_pupil_collection_blocks_insert_input!
		"on conflict condition"
		on_conflict: app_pupil_collection_blocks_on_conflict
	): app_pupil_collection_blocks
	"insert data into the table: \"app.quick_lanes\""
	insert_app_quick_lanes(
		"the rows to be inserted"
		objects: [app_quick_lanes_insert_input!]!
		"on conflict condition"
		on_conflict: app_quick_lanes_on_conflict
	): app_quick_lanes_mutation_response
	"insert a single row into the table: \"app.quick_lanes\""
	insert_app_quick_lanes_one(
		"the row to be inserted"
		object: app_quick_lanes_insert_input!
		"on conflict condition"
		on_conflict: app_quick_lanes_on_conflict
	): app_quick_lanes
	"insert data into the table: \"app.search_bookmarks\""
	insert_app_search_bookmarks(
		"the rows to be inserted"
		objects: [app_search_bookmarks_insert_input!]!
		"on conflict condition"
		on_conflict: app_search_bookmarks_on_conflict
	): app_search_bookmarks_mutation_response
	"insert a single row into the table: \"app.search_bookmarks\""
	insert_app_search_bookmarks_one(
		"the row to be inserted"
		object: app_search_bookmarks_insert_input!
		"on conflict condition"
		on_conflict: app_search_bookmarks_on_conflict
	): app_search_bookmarks
	"insert data into the table: \"app.site_variables\""
	insert_app_site_variables(
		"the rows to be inserted"
		objects: [app_site_variables_insert_input!]!
		"on conflict condition"
		on_conflict: app_site_variables_on_conflict
	): app_site_variables_mutation_response
	"insert a single row into the table: \"app.site_variables\""
	insert_app_site_variables_one(
		"the row to be inserted"
		object: app_site_variables_insert_input!
		"on conflict condition"
		on_conflict: app_site_variables_on_conflict
	): app_site_variables
	"insert data into the table: \"lookup.enum_assignment_content_labels\""
	insert_lookup_enum_assignment_content_labels(
		"the rows to be inserted"
		objects: [lookup_enum_assignment_content_labels_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_assignment_content_labels_on_conflict
	): lookup_enum_assignment_content_labels_mutation_response
	"insert a single row into the table: \"lookup.enum_assignment_content_labels\""
	insert_lookup_enum_assignment_content_labels_one(
		"the row to be inserted"
		object: lookup_enum_assignment_content_labels_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_assignment_content_labels_on_conflict
	): lookup_enum_assignment_content_labels
	"insert data into the table: \"lookup.enum_assignment_types\""
	insert_lookup_enum_assignment_types(
		"the rows to be inserted"
		objects: [lookup_enum_assignment_types_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_assignment_types_on_conflict
	): lookup_enum_assignment_types_mutation_response
	"insert a single row into the table: \"lookup.enum_assignment_types\""
	insert_lookup_enum_assignment_types_one(
		"the row to be inserted"
		object: lookup_enum_assignment_types_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_assignment_types_on_conflict
	): lookup_enum_assignment_types
	"insert data into the table: \"lookup.enum_collection_labels\""
	insert_lookup_enum_collection_labels(
		"the rows to be inserted"
		objects: [lookup_enum_collection_labels_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_collection_labels_on_conflict
	): lookup_enum_collection_labels_mutation_response
	"insert a single row into the table: \"lookup.enum_collection_labels\""
	insert_lookup_enum_collection_labels_one(
		"the row to be inserted"
		object: lookup_enum_collection_labels_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_collection_labels_on_conflict
	): lookup_enum_collection_labels
	"insert data into the table: \"lookup.enum_collection_management_qc_label\""
	insert_lookup_enum_collection_management_qc_label(
		"the rows to be inserted"
		objects: [lookup_enum_collection_management_qc_label_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_collection_management_qc_label_on_conflict
	): lookup_enum_collection_management_qc_label_mutation_response
	"insert a single row into the table: \"lookup.enum_collection_management_qc_label\""
	insert_lookup_enum_collection_management_qc_label_one(
		"the row to be inserted"
		object: lookup_enum_collection_management_qc_label_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_collection_management_qc_label_on_conflict
	): lookup_enum_collection_management_qc_label
	"insert data into the table: \"lookup.enum_collection_management_status\""
	insert_lookup_enum_collection_management_status(
		"the rows to be inserted"
		objects: [lookup_enum_collection_management_status_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_collection_management_status_on_conflict
	): lookup_enum_collection_management_status_mutation_response
	"insert a single row into the table: \"lookup.enum_collection_management_status\""
	insert_lookup_enum_collection_management_status_one(
		"the row to be inserted"
		object: lookup_enum_collection_management_status_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_collection_management_status_on_conflict
	): lookup_enum_collection_management_status
	"insert data into the table: \"lookup.enum_colors\""
	insert_lookup_enum_colors(
		"the rows to be inserted"
		objects: [lookup_enum_colors_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_colors_on_conflict
	): lookup_enum_colors_mutation_response
	"insert a single row into the table: \"lookup.enum_colors\""
	insert_lookup_enum_colors_one(
		"the row to be inserted"
		object: lookup_enum_colors_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_colors_on_conflict
	): lookup_enum_colors
	"insert data into the table: \"lookup.enum_content_block_types\""
	insert_lookup_enum_content_block_types(
		"the rows to be inserted"
		objects: [lookup_enum_content_block_types_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_content_block_types_on_conflict
	): lookup_enum_content_block_types_mutation_response
	"insert a single row into the table: \"lookup.enum_content_block_types\""
	insert_lookup_enum_content_block_types_one(
		"the row to be inserted"
		object: lookup_enum_content_block_types_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_content_block_types_on_conflict
	): lookup_enum_content_block_types
	"insert data into the table: \"lookup.enum_content_types\""
	insert_lookup_enum_content_types(
		"the rows to be inserted"
		objects: [lookup_enum_content_types_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_content_types_on_conflict
	): lookup_enum_content_types_mutation_response
	"insert a single row into the table: \"lookup.enum_content_types\""
	insert_lookup_enum_content_types_one(
		"the row to be inserted"
		object: lookup_enum_content_types_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_content_types_on_conflict
	): lookup_enum_content_types
	"insert data into the table: \"lookup.enum_input_types\""
	insert_lookup_enum_input_types(
		"the rows to be inserted"
		objects: [lookup_enum_input_types_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_input_types_on_conflict
	): lookup_enum_input_types_mutation_response
	"insert a single row into the table: \"lookup.enum_input_types\""
	insert_lookup_enum_input_types_one(
		"the row to be inserted"
		object: lookup_enum_input_types_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_input_types_on_conflict
	): lookup_enum_input_types
	"insert data into the table: \"lookup.enum_lom_classification\""
	insert_lookup_enum_lom_classification(
		"the rows to be inserted"
		objects: [lookup_enum_lom_classification_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_lom_classification_on_conflict
	): lookup_enum_lom_classification_mutation_response
	"insert a single row into the table: \"lookup.enum_lom_classification\""
	insert_lookup_enum_lom_classification_one(
		"the row to be inserted"
		object: lookup_enum_lom_classification_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_lom_classification_on_conflict
	): lookup_enum_lom_classification
	"insert data into the table: \"lookup.enum_lom_context\""
	insert_lookup_enum_lom_context(
		"the rows to be inserted"
		objects: [lookup_enum_lom_context_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_lom_context_on_conflict
	): lookup_enum_lom_context_mutation_response
	"insert a single row into the table: \"lookup.enum_lom_context\""
	insert_lookup_enum_lom_context_one(
		"the row to be inserted"
		object: lookup_enum_lom_context_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_lom_context_on_conflict
	): lookup_enum_lom_context
	"insert data into the table: \"lookup.enum_profile_flags\""
	insert_lookup_enum_profile_flags(
		"the rows to be inserted"
		objects: [lookup_enum_profile_flags_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_profile_flags_on_conflict
	): lookup_enum_profile_flags_mutation_response
	"insert a single row into the table: \"lookup.enum_profile_flags\""
	insert_lookup_enum_profile_flags_one(
		"the row to be inserted"
		object: lookup_enum_profile_flags_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_profile_flags_on_conflict
	): lookup_enum_profile_flags
	"insert data into the table: \"lookup.enum_profile_preferences_keys\""
	insert_lookup_enum_profile_preferences_keys(
		"the rows to be inserted"
		objects: [lookup_enum_profile_preferences_keys_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_profile_preferences_keys_on_conflict
	): lookup_enum_profile_preferences_keys_mutation_response
	"insert a single row into the table: \"lookup.enum_profile_preferences_keys\""
	insert_lookup_enum_profile_preferences_keys_one(
		"the row to be inserted"
		object: lookup_enum_profile_preferences_keys_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_profile_preferences_keys_on_conflict
	): lookup_enum_profile_preferences_keys
	"insert data into the table: \"lookup.enum_relation_types\""
	insert_lookup_enum_relation_types(
		"the rows to be inserted"
		objects: [lookup_enum_relation_types_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_relation_types_on_conflict
	): lookup_enum_relation_types_mutation_response
	"insert a single row into the table: \"lookup.enum_relation_types\""
	insert_lookup_enum_relation_types_one(
		"the row to be inserted"
		object: lookup_enum_relation_types_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_relation_types_on_conflict
	): lookup_enum_relation_types
	"insert data into the table: \"lookup.enum_search_bookmark_types\""
	insert_lookup_enum_search_bookmark_types(
		"the rows to be inserted"
		objects: [lookup_enum_search_bookmark_types_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_enum_search_bookmark_types_on_conflict
	): lookup_enum_search_bookmark_types_mutation_response
	"insert a single row into the table: \"lookup.enum_search_bookmark_types\""
	insert_lookup_enum_search_bookmark_types_one(
		"the row to be inserted"
		object: lookup_enum_search_bookmark_types_insert_input!
		"on conflict condition"
		on_conflict: lookup_enum_search_bookmark_types_on_conflict
	): lookup_enum_search_bookmark_types
	"insert data into the table: \"lookup.thesaurus\""
	insert_lookup_thesaurus(
		"the rows to be inserted"
		objects: [lookup_thesaurus_insert_input!]!
		"on conflict condition"
		on_conflict: lookup_thesaurus_on_conflict
	): lookup_thesaurus_mutation_response
	"insert a single row into the table: \"lookup.thesaurus\""
	insert_lookup_thesaurus_one(
		"the row to be inserted"
		object: lookup_thesaurus_insert_input!
		"on conflict condition"
		on_conflict: lookup_thesaurus_on_conflict
	): lookup_thesaurus
	"insert data into the table: \"migrate.original_publishdate\""
	insert_migrate_original_publishdate(
		"the rows to be inserted"
		objects: [migrate_original_publishdate_insert_input!]!
		"on conflict condition"
		on_conflict: migrate_original_publishdate_on_conflict
	): migrate_original_publishdate_mutation_response
	"insert a single row into the table: \"migrate.original_publishdate\""
	insert_migrate_original_publishdate_one(
		"the row to be inserted"
		object: migrate_original_publishdate_insert_input!
		"on conflict condition"
		on_conflict: migrate_original_publishdate_on_conflict
	): migrate_original_publishdate
	"insert data into the table: \"migrate.reference_ids\""
	insert_migrate_reference_ids(
		"the rows to be inserted"
		objects: [migrate_reference_ids_insert_input!]!
		"on conflict condition"
		on_conflict: migrate_reference_ids_on_conflict
	): migrate_reference_ids_mutation_response
	"insert a single row into the table: \"migrate.reference_ids\""
	insert_migrate_reference_ids_one(
		"the row to be inserted"
		object: migrate_reference_ids_insert_input!
		"on conflict condition"
		on_conflict: migrate_reference_ids_on_conflict
	): migrate_reference_ids
	"insert data into the table: \"shared.collateral\""
	insert_shared_collateral(
		"the rows to be inserted"
		objects: [shared_collateral_insert_input!]!
		"on conflict condition"
		on_conflict: shared_collateral_on_conflict
	): shared_collateral_mutation_response
	"insert a single row into the table: \"shared.collateral\""
	insert_shared_collateral_one(
		"the row to be inserted"
		object: shared_collateral_insert_input!
		"on conflict condition"
		on_conflict: shared_collateral_on_conflict
	): shared_collateral
	"insert data into the table: \"shared.items\""
	insert_shared_items(
		"the rows to be inserted"
		objects: [shared_items_insert_input!]!
		"on conflict condition"
		on_conflict: shared_items_on_conflict
	): shared_items_mutation_response
	"insert a single row into the table: \"shared.items\""
	insert_shared_items_one(
		"the row to be inserted"
		object: shared_items_insert_input!
		"on conflict condition"
		on_conflict: shared_items_on_conflict
	): shared_items
	"insert data into the table: \"shared.ldap_organizations\""
	insert_shared_ldap_organizations(
		"the rows to be inserted"
		objects: [shared_ldap_organizations_insert_input!]!
		"on conflict condition"
		on_conflict: shared_ldap_organizations_on_conflict
	): shared_ldap_organizations_mutation_response
	"insert a single row into the table: \"shared.ldap_organizations\""
	insert_shared_ldap_organizations_one(
		"the row to be inserted"
		object: shared_ldap_organizations_insert_input!
		"on conflict condition"
		on_conflict: shared_ldap_organizations_on_conflict
	): shared_ldap_organizations
	"insert data into the table: \"shared.organisations\""
	insert_shared_organisations(
		"the rows to be inserted"
		objects: [shared_organisations_insert_input!]!
		"on conflict condition"
		on_conflict: shared_organisations_on_conflict
	): shared_organisations_mutation_response
	"insert a single row into the table: \"shared.organisations\""
	insert_shared_organisations_one(
		"the row to be inserted"
		object: shared_organisations_insert_input!
		"on conflict condition"
		on_conflict: shared_organisations_on_conflict
	): shared_organisations
	"insert data into the table: \"shared.types\""
	insert_shared_types(
		"the rows to be inserted"
		objects: [shared_types_insert_input!]!
		"on conflict condition"
		on_conflict: shared_types_on_conflict
	): shared_types_mutation_response
	"insert a single row into the table: \"shared.types\""
	insert_shared_types_one(
		"the row to be inserted"
		object: shared_types_insert_input!
		"on conflict condition"
		on_conflict: shared_types_on_conflict
	): shared_types
	"insert data into the table: \"shared.user_roles\""
	insert_shared_user_roles(
		"the rows to be inserted"
		objects: [shared_user_roles_insert_input!]!
		"on conflict condition"
		on_conflict: shared_user_roles_on_conflict
	): shared_user_roles_mutation_response
	"insert a single row into the table: \"shared.user_roles\""
	insert_shared_user_roles_one(
		"the row to be inserted"
		object: shared_user_roles_insert_input!
		"on conflict condition"
		on_conflict: shared_user_roles_on_conflict
	): shared_user_roles
	"insert data into the table: \"shared.user_temp_access\""
	insert_shared_user_temp_access(
		"the rows to be inserted"
		objects: [shared_user_temp_access_insert_input!]!
		"on conflict condition"
		on_conflict: shared_user_temp_access_on_conflict
	): shared_user_temp_access_mutation_response
	"insert a single row into the table: \"shared.user_temp_access\""
	insert_shared_user_temp_access_one(
		"the row to be inserted"
		object: shared_user_temp_access_insert_input!
		"on conflict condition"
		on_conflict: shared_user_temp_access_on_conflict
	): shared_user_temp_access
	"insert data into the table: \"shared.users\""
	insert_shared_users(
		"the rows to be inserted"
		objects: [shared_users_insert_input!]!
		"on conflict condition"
		on_conflict: shared_users_on_conflict
	): shared_users_mutation_response
	"insert a single row into the table: \"shared.users\""
	insert_shared_users_one(
		"the row to be inserted"
		object: shared_users_insert_input!
		"on conflict condition"
		on_conflict: shared_users_on_conflict
	): shared_users
	"insert data into the table: \"users.audit_log\""
	insert_users_audit_log(
		"the rows to be inserted"
		objects: [users_audit_log_insert_input!]!
		"on conflict condition"
		on_conflict: users_audit_log_on_conflict
	): users_audit_log_mutation_response
	"insert a single row into the table: \"users.audit_log\""
	insert_users_audit_log_one(
		"the row to be inserted"
		object: users_audit_log_insert_input!
		"on conflict condition"
		on_conflict: users_audit_log_on_conflict
	): users_audit_log
	"insert data into the table: \"users.email_preferences\""
	insert_users_email_preferences(
		"the rows to be inserted"
		objects: [users_email_preferences_insert_input!]!
		"on conflict condition"
		on_conflict: users_email_preferences_on_conflict
	): users_email_preferences_mutation_response
	"insert a single row into the table: \"users.email_preferences\""
	insert_users_email_preferences_one(
		"the row to be inserted"
		object: users_email_preferences_insert_input!
		"on conflict condition"
		on_conflict: users_email_preferences_on_conflict
	): users_email_preferences
	"insert data into the table: \"users.group_user_permission_groups\""
	insert_users_group_user_permission_groups(
		"the rows to be inserted"
		objects: [users_group_user_permission_groups_insert_input!]!
		"on conflict condition"
		on_conflict: users_group_user_permission_groups_on_conflict
	): users_group_user_permission_groups_mutation_response
	"insert a single row into the table: \"users.group_user_permission_groups\""
	insert_users_group_user_permission_groups_one(
		"the row to be inserted"
		object: users_group_user_permission_groups_insert_input!
		"on conflict condition"
		on_conflict: users_group_user_permission_groups_on_conflict
	): users_group_user_permission_groups
	"insert data into the table: \"users.groups\""
	insert_users_groups(
		"the rows to be inserted"
		objects: [users_groups_insert_input!]!
		"on conflict condition"
		on_conflict: users_groups_on_conflict
	): users_groups_mutation_response
	"insert a single row into the table: \"users.groups\""
	insert_users_groups_one(
		"the row to be inserted"
		object: users_groups_insert_input!
		"on conflict condition"
		on_conflict: users_groups_on_conflict
	): users_groups
	"insert data into the table: \"users.idp_map\""
	insert_users_idp_map(
		"the rows to be inserted"
		objects: [users_idp_map_insert_input!]!
		"on conflict condition"
		on_conflict: users_idp_map_on_conflict
	): users_idp_map_mutation_response
	"insert a single row into the table: \"users.idp_map\""
	insert_users_idp_map_one(
		"the row to be inserted"
		object: users_idp_map_insert_input!
		"on conflict condition"
		on_conflict: users_idp_map_on_conflict
	): users_idp_map
	"insert data into the table: \"users.idps\""
	insert_users_idps(
		"the rows to be inserted"
		objects: [users_idps_insert_input!]!
		"on conflict condition"
		on_conflict: users_idps_on_conflict
	): users_idps_mutation_response
	"insert a single row into the table: \"users.idps\""
	insert_users_idps_one(
		"the row to be inserted"
		object: users_idps_insert_input!
		"on conflict condition"
		on_conflict: users_idps_on_conflict
	): users_idps
	"insert data into the table: \"users.notifications\""
	insert_users_notifications(
		"the rows to be inserted"
		objects: [users_notifications_insert_input!]!
		"on conflict condition"
		on_conflict: users_notifications_on_conflict
	): users_notifications_mutation_response
	"insert a single row into the table: \"users.notifications\""
	insert_users_notifications_one(
		"the row to be inserted"
		object: users_notifications_insert_input!
		"on conflict condition"
		on_conflict: users_notifications_on_conflict
	): users_notifications
	"insert data into the table: \"users.permission_group_user_permissions\""
	insert_users_permission_group_user_permissions(
		"the rows to be inserted"
		objects: [users_permission_group_user_permissions_insert_input!]!
		"on conflict condition"
		on_conflict: users_permission_group_user_permissions_on_conflict
	): users_permission_group_user_permissions_mutation_response
	"insert a single row into the table: \"users.permission_group_user_permissions\""
	insert_users_permission_group_user_permissions_one(
		"the row to be inserted"
		object: users_permission_group_user_permissions_insert_input!
		"on conflict condition"
		on_conflict: users_permission_group_user_permissions_on_conflict
	): users_permission_group_user_permissions
	"insert data into the table: \"users.permission_groups\""
	insert_users_permission_groups(
		"the rows to be inserted"
		objects: [users_permission_groups_insert_input!]!
		"on conflict condition"
		on_conflict: users_permission_groups_on_conflict
	): users_permission_groups_mutation_response
	"insert a single row into the table: \"users.permission_groups\""
	insert_users_permission_groups_one(
		"the row to be inserted"
		object: users_permission_groups_insert_input!
		"on conflict condition"
		on_conflict: users_permission_groups_on_conflict
	): users_permission_groups
	"insert data into the table: \"users.permission_matrix_view\""
	insert_users_permission_matrix_view(
		"the rows to be inserted"
		objects: [users_permission_matrix_view_insert_input!]!
	): users_permission_matrix_view_mutation_response
	"insert a single row into the table: \"users.permission_matrix_view\""
	insert_users_permission_matrix_view_one(
		"the row to be inserted"
		object: users_permission_matrix_view_insert_input!
	): users_permission_matrix_view
	"insert data into the table: \"users.permissions\""
	insert_users_permissions(
		"the rows to be inserted"
		objects: [users_permissions_insert_input!]!
		"on conflict condition"
		on_conflict: users_permissions_on_conflict
	): users_permissions_mutation_response
	"insert a single row into the table: \"users.permissions\""
	insert_users_permissions_one(
		"the row to be inserted"
		object: users_permissions_insert_input!
		"on conflict condition"
		on_conflict: users_permissions_on_conflict
	): users_permissions
	"insert data into the table: \"users.profile_classifications\""
	insert_users_profile_classifications(
		"the rows to be inserted"
		objects: [users_profile_classifications_insert_input!]!
		"on conflict condition"
		on_conflict: users_profile_classifications_on_conflict
	): users_profile_classifications_mutation_response
	"insert a single row into the table: \"users.profile_classifications\""
	insert_users_profile_classifications_one(
		"the row to be inserted"
		object: users_profile_classifications_insert_input!
		"on conflict condition"
		on_conflict: users_profile_classifications_on_conflict
	): users_profile_classifications
	"insert data into the table: \"users.profile_contexts\""
	insert_users_profile_contexts(
		"the rows to be inserted"
		objects: [users_profile_contexts_insert_input!]!
		"on conflict condition"
		on_conflict: users_profile_contexts_on_conflict
	): users_profile_contexts_mutation_response
	"insert a single row into the table: \"users.profile_contexts\""
	insert_users_profile_contexts_one(
		"the row to be inserted"
		object: users_profile_contexts_insert_input!
		"on conflict condition"
		on_conflict: users_profile_contexts_on_conflict
	): users_profile_contexts
	"insert data into the table: \"users.profile_flags\""
	insert_users_profile_flags(
		"the rows to be inserted"
		objects: [users_profile_flags_insert_input!]!
		"on conflict condition"
		on_conflict: users_profile_flags_on_conflict
	): users_profile_flags_mutation_response
	"insert a single row into the table: \"users.profile_flags\""
	insert_users_profile_flags_one(
		"the row to be inserted"
		object: users_profile_flags_insert_input!
		"on conflict condition"
		on_conflict: users_profile_flags_on_conflict
	): users_profile_flags
	"insert data into the table: \"users.profile_organizations\""
	insert_users_profile_organizations(
		"the rows to be inserted"
		objects: [users_profile_organizations_insert_input!]!
		"on conflict condition"
		on_conflict: users_profile_organizations_on_conflict
	): users_profile_organizations_mutation_response
	"insert a single row into the table: \"users.profile_organizations\""
	insert_users_profile_organizations_one(
		"the row to be inserted"
		object: users_profile_organizations_insert_input!
		"on conflict condition"
		on_conflict: users_profile_organizations_on_conflict
	): users_profile_organizations
	"insert data into the table: \"users.profile_preferences\""
	insert_users_profile_preferences(
		"the rows to be inserted"
		objects: [users_profile_preferences_insert_input!]!
		"on conflict condition"
		on_conflict: users_profile_preferences_on_conflict
	): users_profile_preferences_mutation_response
	"insert a single row into the table: \"users.profile_preferences\""
	insert_users_profile_preferences_one(
		"the row to be inserted"
		object: users_profile_preferences_insert_input!
		"on conflict condition"
		on_conflict: users_profile_preferences_on_conflict
	): users_profile_preferences
	"insert data into the table: \"users.profile_user_groups\""
	insert_users_profile_user_groups(
		"the rows to be inserted"
		objects: [users_profile_user_groups_insert_input!]!
		"on conflict condition"
		on_conflict: users_profile_user_groups_on_conflict
	): users_profile_user_groups_mutation_response
	"insert a single row into the table: \"users.profile_user_groups\""
	insert_users_profile_user_groups_one(
		"the row to be inserted"
		object: users_profile_user_groups_insert_input!
		"on conflict condition"
		on_conflict: users_profile_user_groups_on_conflict
	): users_profile_user_groups
	"insert data into the table: \"users.profiles\""
	insert_users_profiles(
		"the rows to be inserted"
		objects: [users_profiles_insert_input!]!
		"on conflict condition"
		on_conflict: users_profiles_on_conflict
	): users_profiles_mutation_response
	"insert a single row into the table: \"users.profiles\""
	insert_users_profiles_one(
		"the row to be inserted"
		object: users_profiles_insert_input!
		"on conflict condition"
		on_conflict: users_profiles_on_conflict
	): users_profiles
	"update data of the table: \"app.assignment_assignment_tags\""
	update_app_assignment_assignment_tags(
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignment_assignment_tags_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_assignment_tags_set_input
		"filter the rows which have to be updated"
		where: app_assignment_assignment_tags_bool_exp!
	): app_assignment_assignment_tags_mutation_response
	"update single row of the table: \"app.assignment_assignment_tags\""
	update_app_assignment_assignment_tags_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignment_assignment_tags_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_assignment_tags_set_input
		pk_columns: app_assignment_assignment_tags_pk_columns_input!
	): app_assignment_assignment_tags
	"update data of the table: \"app.assignment_blocks_v2\""
	update_app_assignment_blocks_v2(
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignment_blocks_v2_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_blocks_v2_set_input
		"filter the rows which have to be updated"
		where: app_assignment_blocks_v2_bool_exp!
	): app_assignment_blocks_v2_mutation_response
	"update single row of the table: \"app.assignment_blocks_v2\""
	update_app_assignment_blocks_v2_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignment_blocks_v2_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_blocks_v2_set_input
		pk_columns: app_assignment_blocks_v2_pk_columns_input!
	): app_assignment_blocks_v2
	"update data of the table: \"app.assignment_labels\""
	update_app_assignment_labels(
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignment_labels_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_labels_set_input
		"filter the rows which have to be updated"
		where: app_assignment_labels_bool_exp!
	): app_assignment_labels_mutation_response
	"update single row of the table: \"app.assignment_labels\""
	update_app_assignment_labels_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignment_labels_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_labels_set_input
		pk_columns: app_assignment_labels_pk_columns_input!
	): app_assignment_labels
	"update data of the table: \"app.assignment_labels_v2\""
	update_app_assignment_labels_v2(
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_labels_v2_set_input
		"filter the rows which have to be updated"
		where: app_assignment_labels_v2_bool_exp!
	): app_assignment_labels_v2_mutation_response
	"update single row of the table: \"app.assignment_labels_v2\""
	update_app_assignment_labels_v2_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_labels_v2_set_input
		pk_columns: app_assignment_labels_v2_pk_columns_input!
	): app_assignment_labels_v2
	"update data of the table: \"app.assignment_responses\""
	update_app_assignment_responses(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_assignment_responses_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_assignment_responses_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_assignment_responses_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_assignment_responses_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignment_responses_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_assignment_responses_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_responses_set_input
		"filter the rows which have to be updated"
		where: app_assignment_responses_bool_exp!
	): app_assignment_responses_mutation_response
	"update single row of the table: \"app.assignment_responses\""
	update_app_assignment_responses_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_assignment_responses_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_assignment_responses_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_assignment_responses_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_assignment_responses_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignment_responses_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_assignment_responses_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_responses_set_input
		pk_columns: app_assignment_responses_pk_columns_input!
	): app_assignment_responses
	"update data of the table: \"app.assignment_responses_v2\""
	update_app_assignment_responses_v2(
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_responses_v2_set_input
		"filter the rows which have to be updated"
		where: app_assignment_responses_v2_bool_exp!
	): app_assignment_responses_v2_mutation_response
	"update single row of the table: \"app.assignment_responses_v2\""
	update_app_assignment_responses_v2_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_responses_v2_set_input
		pk_columns: app_assignment_responses_v2_pk_columns_input!
	): app_assignment_responses_v2
	"update data of the table: \"app.assignment_v2_views\""
	update_app_assignment_v2_views(
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignment_v2_views_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_v2_views_set_input
		"filter the rows which have to be updated"
		where: app_assignment_v2_views_bool_exp!
	): app_assignment_v2_views_mutation_response
	"update single row of the table: \"app.assignment_v2_views\""
	update_app_assignment_v2_views_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignment_v2_views_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignment_v2_views_set_input
		pk_columns: app_assignment_v2_views_pk_columns_input!
	): app_assignment_v2_views
	"update data of the table: \"app.assignments\""
	update_app_assignments(
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignments_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignments_set_input
		"filter the rows which have to be updated"
		where: app_assignments_bool_exp!
	): app_assignments_mutation_response
	"update single row of the table: \"app.assignments\""
	update_app_assignments_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignments_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignments_set_input
		pk_columns: app_assignments_pk_columns_input!
	): app_assignments
	"update data of the table: \"app.assignments_v2\""
	update_app_assignments_v2(
		"sets the columns of the filtered rows to the given values"
		_set: app_assignments_v2_set_input
		"filter the rows which have to be updated"
		where: app_assignments_v2_bool_exp!
	): app_assignments_v2_mutation_response
	"update data of the table: \"app.assignments_v2_assignment_labels_v2\""
	update_app_assignments_v2_assignment_labels_v2(
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignments_v2_assignment_labels_v2_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignments_v2_assignment_labels_v2_set_input
		"filter the rows which have to be updated"
		where: app_assignments_v2_assignment_labels_v2_bool_exp!
	): app_assignments_v2_assignment_labels_v2_mutation_response
	"update single row of the table: \"app.assignments_v2_assignment_labels_v2\""
	update_app_assignments_v2_assignment_labels_v2_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_assignments_v2_assignment_labels_v2_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_assignments_v2_assignment_labels_v2_set_input
		pk_columns: app_assignments_v2_assignment_labels_v2_pk_columns_input!
	): app_assignments_v2_assignment_labels_v2
	"update single row of the table: \"app.assignments_v2\""
	update_app_assignments_v2_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: app_assignments_v2_set_input
		pk_columns: app_assignments_v2_pk_columns_input!
	): app_assignments_v2
	"update data of the table: \"app.collection_bookmarks\""
	update_app_collection_bookmarks(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_bookmarks_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_bookmarks_set_input
		"filter the rows which have to be updated"
		where: app_collection_bookmarks_bool_exp!
	): app_collection_bookmarks_mutation_response
	"update single row of the table: \"app.collection_bookmarks\""
	update_app_collection_bookmarks_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_bookmarks_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_bookmarks_set_input
		pk_columns: app_collection_bookmarks_pk_columns_input!
	): app_collection_bookmarks
	"update data of the table: \"app.collection_fragments\""
	update_app_collection_fragments(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_fragments_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_fragments_set_input
		"filter the rows which have to be updated"
		where: app_collection_fragments_bool_exp!
	): app_collection_fragments_mutation_response
	"update single row of the table: \"app.collection_fragments\""
	update_app_collection_fragments_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_fragments_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_fragments_set_input
		pk_columns: app_collection_fragments_pk_columns_input!
	): app_collection_fragments
	"update data of the table: \"app.collection_labels\""
	update_app_collection_labels(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_labels_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_labels_set_input
		"filter the rows which have to be updated"
		where: app_collection_labels_bool_exp!
	): app_collection_labels_mutation_response
	"update single row of the table: \"app.collection_labels\""
	update_app_collection_labels_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_labels_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_labels_set_input
		pk_columns: app_collection_labels_pk_columns_input!
	): app_collection_labels
	"update data of the table: \"app.collection_management\""
	update_app_collection_management(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_management_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_management_set_input
		"filter the rows which have to be updated"
		where: app_collection_management_bool_exp!
	): app_collection_management_mutation_response
	"update data of the table: \"app.collection_management_QC\""
	update_app_collection_management_QC(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_management_QC_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_management_QC_set_input
		"filter the rows which have to be updated"
		where: app_collection_management_QC_bool_exp!
	): app_collection_management_QC_mutation_response
	"update single row of the table: \"app.collection_management_QC\""
	update_app_collection_management_QC_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_management_QC_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_management_QC_set_input
		pk_columns: app_collection_management_QC_pk_columns_input!
	): app_collection_management_QC
	"update single row of the table: \"app.collection_management\""
	update_app_collection_management_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_management_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_management_set_input
		pk_columns: app_collection_management_pk_columns_input!
	): app_collection_management
	"update data of the table: \"app.collection_marcom_log\""
	update_app_collection_marcom_log(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_marcom_log_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_marcom_log_set_input
		"filter the rows which have to be updated"
		where: app_collection_marcom_log_bool_exp!
	): app_collection_marcom_log_mutation_response
	"update single row of the table: \"app.collection_marcom_log\""
	update_app_collection_marcom_log_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_marcom_log_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_marcom_log_set_input
		pk_columns: app_collection_marcom_log_pk_columns_input!
	): app_collection_marcom_log
	"update data of the table: \"app.collection_marcom_notes\""
	update_app_collection_marcom_notes(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_marcom_notes_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_marcom_notes_set_input
		"filter the rows which have to be updated"
		where: app_collection_marcom_notes_bool_exp!
	): app_collection_marcom_notes_mutation_response
	"update single row of the table: \"app.collection_marcom_notes\""
	update_app_collection_marcom_notes_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_marcom_notes_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_marcom_notes_set_input
		pk_columns: app_collection_marcom_notes_pk_columns_input!
	): app_collection_marcom_notes
	"update data of the table: \"app.collection_plays\""
	update_app_collection_plays(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_plays_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_plays_set_input
		"filter the rows which have to be updated"
		where: app_collection_plays_bool_exp!
	): app_collection_plays_mutation_response
	"update single row of the table: \"app.collection_plays\""
	update_app_collection_plays_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_plays_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_plays_set_input
		pk_columns: app_collection_plays_pk_columns_input!
	): app_collection_plays
	"update data of the table: \"app.collection_relations\""
	update_app_collection_relations(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_relations_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_relations_set_input
		"filter the rows which have to be updated"
		where: app_collection_relations_bool_exp!
	): app_collection_relations_mutation_response
	"update single row of the table: \"app.collection_relations\""
	update_app_collection_relations_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_relations_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_relations_set_input
		pk_columns: app_collection_relations_pk_columns_input!
	): app_collection_relations
	"update data of the table: \"app.collection_views\""
	update_app_collection_views(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_views_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_views_set_input
		"filter the rows which have to be updated"
		where: app_collection_views_bool_exp!
	): app_collection_views_mutation_response
	"update single row of the table: \"app.collection_views\""
	update_app_collection_views_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_collection_views_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collection_views_set_input
		pk_columns: app_collection_views_pk_columns_input!
	): app_collection_views
	"update data of the table: \"app.collections\""
	update_app_collections(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_collections_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_collections_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_collections_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_collections_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_collections_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_collections_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collections_set_input
		"filter the rows which have to be updated"
		where: app_collections_bool_exp!
	): app_collections_mutation_response
	"update single row of the table: \"app.collections\""
	update_app_collections_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_collections_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_collections_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_collections_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_collections_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_collections_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_collections_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_collections_set_input
		pk_columns: app_collections_pk_columns_input!
	): app_collections
	"update data of the table: \"app.content\""
	update_app_content(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_content_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_content_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_content_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_content_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_content_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_set_input
		"filter the rows which have to be updated"
		where: app_content_bool_exp!
	): app_content_mutation_response
	"update data of the table: \"app.content_assets\""
	update_app_content_assets(
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_assets_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_assets_set_input
		"filter the rows which have to be updated"
		where: app_content_assets_bool_exp!
	): app_content_assets_mutation_response
	"update single row of the table: \"app.content_assets\""
	update_app_content_assets_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_assets_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_assets_set_input
		pk_columns: app_content_assets_pk_columns_input!
	): app_content_assets
	"update data of the table: \"app.content_blocks\""
	update_app_content_blocks(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_content_blocks_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_content_blocks_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_content_blocks_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_content_blocks_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_blocks_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_content_blocks_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_blocks_set_input
		"filter the rows which have to be updated"
		where: app_content_blocks_bool_exp!
	): app_content_blocks_mutation_response
	"update single row of the table: \"app.content_blocks\""
	update_app_content_blocks_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_content_blocks_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_content_blocks_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_content_blocks_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_content_blocks_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_blocks_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_content_blocks_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_blocks_set_input
		pk_columns: app_content_blocks_pk_columns_input!
	): app_content_blocks
	"update single row of the table: \"app.content\""
	update_app_content_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_content_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_content_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_content_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_content_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_content_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_set_input
		pk_columns: app_content_pk_columns_input!
	): app_content
	"update data of the table: \"app.content_content_labels\""
	update_app_content_content_labels(
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_content_labels_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_content_labels_set_input
		"filter the rows which have to be updated"
		where: app_content_content_labels_bool_exp!
	): app_content_content_labels_mutation_response
	"update single row of the table: \"app.content_content_labels\""
	update_app_content_content_labels_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_content_labels_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_content_labels_set_input
		pk_columns: app_content_content_labels_pk_columns_input!
	): app_content_content_labels
	"update data of the table: \"app.content_labels\""
	update_app_content_labels(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_content_labels_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_content_labels_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_content_labels_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_content_labels_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_labels_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_content_labels_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_labels_set_input
		"filter the rows which have to be updated"
		where: app_content_labels_bool_exp!
	): app_content_labels_mutation_response
	"update single row of the table: \"app.content_labels\""
	update_app_content_labels_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_content_labels_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_content_labels_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_content_labels_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_content_labels_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_labels_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_content_labels_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_labels_set_input
		pk_columns: app_content_labels_pk_columns_input!
	): app_content_labels
	"update data of the table: \"app.content_lower_title\""
	update_app_content_lower_title(
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_lower_title_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_lower_title_set_input
		"filter the rows which have to be updated"
		where: app_content_lower_title_bool_exp!
	): app_content_lower_title_mutation_response
	"update data of the table: \"app.content_nav_elements\""
	update_app_content_nav_elements(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_content_nav_elements_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_content_nav_elements_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_content_nav_elements_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_content_nav_elements_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_nav_elements_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_content_nav_elements_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_nav_elements_set_input
		"filter the rows which have to be updated"
		where: app_content_nav_elements_bool_exp!
	): app_content_nav_elements_mutation_response
	"update single row of the table: \"app.content_nav_elements\""
	update_app_content_nav_elements_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_content_nav_elements_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_content_nav_elements_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_content_nav_elements_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_content_nav_elements_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_content_nav_elements_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_content_nav_elements_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_content_nav_elements_set_input
		pk_columns: app_content_nav_elements_pk_columns_input!
	): app_content_nav_elements
	"update data of the table: \"app.interactive_tour\""
	update_app_interactive_tour(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_interactive_tour_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_interactive_tour_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_interactive_tour_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_interactive_tour_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_interactive_tour_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_interactive_tour_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_interactive_tour_set_input
		"filter the rows which have to be updated"
		where: app_interactive_tour_bool_exp!
	): app_interactive_tour_mutation_response
	"update single row of the table: \"app.interactive_tour\""
	update_app_interactive_tour_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_interactive_tour_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_interactive_tour_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_interactive_tour_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_interactive_tour_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_interactive_tour_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_interactive_tour_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_interactive_tour_set_input
		pk_columns: app_interactive_tour_pk_columns_input!
	): app_interactive_tour
	"update data of the table: \"app.item_bookmarks\""
	update_app_item_bookmarks(
		"increments the integer columns with given value of the filtered values"
		_inc: app_item_bookmarks_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_item_bookmarks_set_input
		"filter the rows which have to be updated"
		where: app_item_bookmarks_bool_exp!
	): app_item_bookmarks_mutation_response
	"update single row of the table: \"app.item_bookmarks\""
	update_app_item_bookmarks_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_item_bookmarks_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_item_bookmarks_set_input
		pk_columns: app_item_bookmarks_pk_columns_input!
	): app_item_bookmarks
	"update data of the table: \"app.item_collateral\""
	update_app_item_collateral(
		"sets the columns of the filtered rows to the given values"
		_set: app_item_collateral_set_input
		"filter the rows which have to be updated"
		where: app_item_collateral_bool_exp!
	): app_item_collateral_mutation_response
	"update single row of the table: \"app.item_collateral\""
	update_app_item_collateral_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: app_item_collateral_set_input
		pk_columns: app_item_collateral_pk_columns_input!
	): app_item_collateral
	"update data of the table: \"app.item_meta\""
	update_app_item_meta(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_item_meta_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_item_meta_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_item_meta_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_item_meta_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_item_meta_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_item_meta_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_item_meta_set_input
		"filter the rows which have to be updated"
		where: app_item_meta_bool_exp!
	): app_item_meta_mutation_response
	"update single row of the table: \"app.item_meta\""
	update_app_item_meta_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_item_meta_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_item_meta_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_item_meta_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_item_meta_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: app_item_meta_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_item_meta_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_item_meta_set_input
		pk_columns: app_item_meta_pk_columns_input!
	): app_item_meta
	"update data of the table: \"app.item_plays\""
	update_app_item_plays(
		"increments the integer columns with given value of the filtered values"
		_inc: app_item_plays_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_item_plays_set_input
		"filter the rows which have to be updated"
		where: app_item_plays_bool_exp!
	): app_item_plays_mutation_response
	"update single row of the table: \"app.item_plays\""
	update_app_item_plays_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_item_plays_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_item_plays_set_input
		pk_columns: app_item_plays_pk_columns_input!
	): app_item_plays
	"update data of the table: \"app.item_relations\""
	update_app_item_relations(
		"increments the integer columns with given value of the filtered values"
		_inc: app_item_relations_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_item_relations_set_input
		"filter the rows which have to be updated"
		where: app_item_relations_bool_exp!
	): app_item_relations_mutation_response
	"update single row of the table: \"app.item_relations\""
	update_app_item_relations_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_item_relations_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_item_relations_set_input
		pk_columns: app_item_relations_pk_columns_input!
	): app_item_relations
	"update data of the table: \"app.item_score\""
	update_app_item_score(
		"increments the integer columns with given value of the filtered values"
		_inc: app_item_score_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_item_score_set_input
		"filter the rows which have to be updated"
		where: app_item_score_bool_exp!
	): app_item_score_mutation_response
	"update single row of the table: \"app.item_score\""
	update_app_item_score_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_item_score_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_item_score_set_input
		pk_columns: app_item_score_pk_columns_input!
	): app_item_score
	"update data of the table: \"app.item_views\""
	update_app_item_views(
		"increments the integer columns with given value of the filtered values"
		_inc: app_item_views_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_item_views_set_input
		"filter the rows which have to be updated"
		where: app_item_views_bool_exp!
	): app_item_views_mutation_response
	"update single row of the table: \"app.item_views\""
	update_app_item_views_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_item_views_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_item_views_set_input
		pk_columns: app_item_views_pk_columns_input!
	): app_item_views
	"update data of the table: \"app.pupil_collection_blocks\""
	update_app_pupil_collection_blocks(
		"increments the integer columns with given value of the filtered values"
		_inc: app_pupil_collection_blocks_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_pupil_collection_blocks_set_input
		"filter the rows which have to be updated"
		where: app_pupil_collection_blocks_bool_exp!
	): app_pupil_collection_blocks_mutation_response
	"update single row of the table: \"app.pupil_collection_blocks\""
	update_app_pupil_collection_blocks_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: app_pupil_collection_blocks_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: app_pupil_collection_blocks_set_input
		pk_columns: app_pupil_collection_blocks_pk_columns_input!
	): app_pupil_collection_blocks
	"update data of the table: \"app.quick_lanes\""
	update_app_quick_lanes(
		"sets the columns of the filtered rows to the given values"
		_set: app_quick_lanes_set_input
		"filter the rows which have to be updated"
		where: app_quick_lanes_bool_exp!
	): app_quick_lanes_mutation_response
	"update single row of the table: \"app.quick_lanes\""
	update_app_quick_lanes_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: app_quick_lanes_set_input
		pk_columns: app_quick_lanes_pk_columns_input!
	): app_quick_lanes
	"update data of the table: \"app.search_bookmarks\""
	update_app_search_bookmarks(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_search_bookmarks_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_search_bookmarks_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_search_bookmarks_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_search_bookmarks_delete_key_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_search_bookmarks_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_search_bookmarks_set_input
		"filter the rows which have to be updated"
		where: app_search_bookmarks_bool_exp!
	): app_search_bookmarks_mutation_response
	"update single row of the table: \"app.search_bookmarks\""
	update_app_search_bookmarks_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_search_bookmarks_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_search_bookmarks_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_search_bookmarks_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_search_bookmarks_delete_key_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_search_bookmarks_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_search_bookmarks_set_input
		pk_columns: app_search_bookmarks_pk_columns_input!
	): app_search_bookmarks
	"update data of the table: \"app.site_variables\""
	update_app_site_variables(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_site_variables_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_site_variables_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_site_variables_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_site_variables_delete_key_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_site_variables_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_site_variables_set_input
		"filter the rows which have to be updated"
		where: app_site_variables_bool_exp!
	): app_site_variables_mutation_response
	"update single row of the table: \"app.site_variables\""
	update_app_site_variables_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: app_site_variables_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: app_site_variables_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: app_site_variables_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: app_site_variables_delete_key_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: app_site_variables_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: app_site_variables_set_input
		pk_columns: app_site_variables_pk_columns_input!
	): app_site_variables
	"update data of the table: \"lookup.enum_assignment_content_labels\""
	update_lookup_enum_assignment_content_labels(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_assignment_content_labels_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_assignment_content_labels_bool_exp!
	): lookup_enum_assignment_content_labels_mutation_response
	"update single row of the table: \"lookup.enum_assignment_content_labels\""
	update_lookup_enum_assignment_content_labels_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_assignment_content_labels_set_input
		pk_columns: lookup_enum_assignment_content_labels_pk_columns_input!
	): lookup_enum_assignment_content_labels
	"update data of the table: \"lookup.enum_assignment_types\""
	update_lookup_enum_assignment_types(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_assignment_types_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_assignment_types_bool_exp!
	): lookup_enum_assignment_types_mutation_response
	"update single row of the table: \"lookup.enum_assignment_types\""
	update_lookup_enum_assignment_types_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_assignment_types_set_input
		pk_columns: lookup_enum_assignment_types_pk_columns_input!
	): lookup_enum_assignment_types
	"update data of the table: \"lookup.enum_collection_labels\""
	update_lookup_enum_collection_labels(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_collection_labels_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_collection_labels_bool_exp!
	): lookup_enum_collection_labels_mutation_response
	"update single row of the table: \"lookup.enum_collection_labels\""
	update_lookup_enum_collection_labels_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_collection_labels_set_input
		pk_columns: lookup_enum_collection_labels_pk_columns_input!
	): lookup_enum_collection_labels
	"update data of the table: \"lookup.enum_collection_management_qc_label\""
	update_lookup_enum_collection_management_qc_label(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_collection_management_qc_label_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_collection_management_qc_label_bool_exp!
	): lookup_enum_collection_management_qc_label_mutation_response
	"update single row of the table: \"lookup.enum_collection_management_qc_label\""
	update_lookup_enum_collection_management_qc_label_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_collection_management_qc_label_set_input
		pk_columns: lookup_enum_collection_management_qc_label_pk_columns_input!
	): lookup_enum_collection_management_qc_label
	"update data of the table: \"lookup.enum_collection_management_status\""
	update_lookup_enum_collection_management_status(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_collection_management_status_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_collection_management_status_bool_exp!
	): lookup_enum_collection_management_status_mutation_response
	"update single row of the table: \"lookup.enum_collection_management_status\""
	update_lookup_enum_collection_management_status_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_collection_management_status_set_input
		pk_columns: lookup_enum_collection_management_status_pk_columns_input!
	): lookup_enum_collection_management_status
	"update data of the table: \"lookup.enum_colors\""
	update_lookup_enum_colors(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_colors_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_colors_bool_exp!
	): lookup_enum_colors_mutation_response
	"update single row of the table: \"lookup.enum_colors\""
	update_lookup_enum_colors_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_colors_set_input
		pk_columns: lookup_enum_colors_pk_columns_input!
	): lookup_enum_colors
	"update data of the table: \"lookup.enum_content_block_types\""
	update_lookup_enum_content_block_types(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_content_block_types_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_content_block_types_bool_exp!
	): lookup_enum_content_block_types_mutation_response
	"update single row of the table: \"lookup.enum_content_block_types\""
	update_lookup_enum_content_block_types_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_content_block_types_set_input
		pk_columns: lookup_enum_content_block_types_pk_columns_input!
	): lookup_enum_content_block_types
	"update data of the table: \"lookup.enum_content_types\""
	update_lookup_enum_content_types(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_content_types_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_content_types_bool_exp!
	): lookup_enum_content_types_mutation_response
	"update single row of the table: \"lookup.enum_content_types\""
	update_lookup_enum_content_types_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_content_types_set_input
		pk_columns: lookup_enum_content_types_pk_columns_input!
	): lookup_enum_content_types
	"update data of the table: \"lookup.enum_input_types\""
	update_lookup_enum_input_types(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_input_types_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_input_types_bool_exp!
	): lookup_enum_input_types_mutation_response
	"update single row of the table: \"lookup.enum_input_types\""
	update_lookup_enum_input_types_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_input_types_set_input
		pk_columns: lookup_enum_input_types_pk_columns_input!
	): lookup_enum_input_types
	"update data of the table: \"lookup.enum_lom_classification\""
	update_lookup_enum_lom_classification(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_lom_classification_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_lom_classification_bool_exp!
	): lookup_enum_lom_classification_mutation_response
	"update single row of the table: \"lookup.enum_lom_classification\""
	update_lookup_enum_lom_classification_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_lom_classification_set_input
		pk_columns: lookup_enum_lom_classification_pk_columns_input!
	): lookup_enum_lom_classification
	"update data of the table: \"lookup.enum_lom_context\""
	update_lookup_enum_lom_context(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_lom_context_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_lom_context_bool_exp!
	): lookup_enum_lom_context_mutation_response
	"update single row of the table: \"lookup.enum_lom_context\""
	update_lookup_enum_lom_context_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_lom_context_set_input
		pk_columns: lookup_enum_lom_context_pk_columns_input!
	): lookup_enum_lom_context
	"update data of the table: \"lookup.enum_profile_flags\""
	update_lookup_enum_profile_flags(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_profile_flags_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_profile_flags_bool_exp!
	): lookup_enum_profile_flags_mutation_response
	"update single row of the table: \"lookup.enum_profile_flags\""
	update_lookup_enum_profile_flags_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_profile_flags_set_input
		pk_columns: lookup_enum_profile_flags_pk_columns_input!
	): lookup_enum_profile_flags
	"update data of the table: \"lookup.enum_profile_preferences_keys\""
	update_lookup_enum_profile_preferences_keys(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_profile_preferences_keys_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_profile_preferences_keys_bool_exp!
	): lookup_enum_profile_preferences_keys_mutation_response
	"update single row of the table: \"lookup.enum_profile_preferences_keys\""
	update_lookup_enum_profile_preferences_keys_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_profile_preferences_keys_set_input
		pk_columns: lookup_enum_profile_preferences_keys_pk_columns_input!
	): lookup_enum_profile_preferences_keys
	"update data of the table: \"lookup.enum_relation_types\""
	update_lookup_enum_relation_types(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_relation_types_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_relation_types_bool_exp!
	): lookup_enum_relation_types_mutation_response
	"update single row of the table: \"lookup.enum_relation_types\""
	update_lookup_enum_relation_types_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_relation_types_set_input
		pk_columns: lookup_enum_relation_types_pk_columns_input!
	): lookup_enum_relation_types
	"update data of the table: \"lookup.enum_search_bookmark_types\""
	update_lookup_enum_search_bookmark_types(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_search_bookmark_types_set_input
		"filter the rows which have to be updated"
		where: lookup_enum_search_bookmark_types_bool_exp!
	): lookup_enum_search_bookmark_types_mutation_response
	"update single row of the table: \"lookup.enum_search_bookmark_types\""
	update_lookup_enum_search_bookmark_types_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_enum_search_bookmark_types_set_input
		pk_columns: lookup_enum_search_bookmark_types_pk_columns_input!
	): lookup_enum_search_bookmark_types
	"update data of the table: \"lookup.thesaurus\""
	update_lookup_thesaurus(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_thesaurus_set_input
		"filter the rows which have to be updated"
		where: lookup_thesaurus_bool_exp!
	): lookup_thesaurus_mutation_response
	"update single row of the table: \"lookup.thesaurus\""
	update_lookup_thesaurus_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: lookup_thesaurus_set_input
		pk_columns: lookup_thesaurus_pk_columns_input!
	): lookup_thesaurus
	"update data of the table: \"migrate.original_publishdate\""
	update_migrate_original_publishdate(
		"sets the columns of the filtered rows to the given values"
		_set: migrate_original_publishdate_set_input
		"filter the rows which have to be updated"
		where: migrate_original_publishdate_bool_exp!
	): migrate_original_publishdate_mutation_response
	"update single row of the table: \"migrate.original_publishdate\""
	update_migrate_original_publishdate_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: migrate_original_publishdate_set_input
		pk_columns: migrate_original_publishdate_pk_columns_input!
	): migrate_original_publishdate
	"update data of the table: \"migrate.reference_ids\""
	update_migrate_reference_ids(
		"increments the integer columns with given value of the filtered values"
		_inc: migrate_reference_ids_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: migrate_reference_ids_set_input
		"filter the rows which have to be updated"
		where: migrate_reference_ids_bool_exp!
	): migrate_reference_ids_mutation_response
	"update single row of the table: \"migrate.reference_ids\""
	update_migrate_reference_ids_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: migrate_reference_ids_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: migrate_reference_ids_set_input
		pk_columns: migrate_reference_ids_pk_columns_input!
	): migrate_reference_ids
	"update data of the table: \"shared.collateral\""
	update_shared_collateral(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: shared_collateral_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: shared_collateral_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: shared_collateral_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: shared_collateral_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: shared_collateral_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: shared_collateral_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_collateral_set_input
		"filter the rows which have to be updated"
		where: shared_collateral_bool_exp!
	): shared_collateral_mutation_response
	"update single row of the table: \"shared.collateral\""
	update_shared_collateral_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: shared_collateral_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: shared_collateral_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: shared_collateral_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: shared_collateral_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: shared_collateral_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: shared_collateral_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_collateral_set_input
		pk_columns: shared_collateral_pk_columns_input!
	): shared_collateral
	"update data of the table: \"shared.items\""
	update_shared_items(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: shared_items_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: shared_items_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: shared_items_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: shared_items_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: shared_items_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: shared_items_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_items_set_input
		"filter the rows which have to be updated"
		where: shared_items_bool_exp!
	): shared_items_mutation_response
	"update single row of the table: \"shared.items\""
	update_shared_items_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: shared_items_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: shared_items_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: shared_items_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: shared_items_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: shared_items_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: shared_items_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_items_set_input
		pk_columns: shared_items_pk_columns_input!
	): shared_items
	"update data of the table: \"shared.ldap_organizations\""
	update_shared_ldap_organizations(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: shared_ldap_organizations_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: shared_ldap_organizations_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: shared_ldap_organizations_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: shared_ldap_organizations_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: shared_ldap_organizations_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: shared_ldap_organizations_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_ldap_organizations_set_input
		"filter the rows which have to be updated"
		where: shared_ldap_organizations_bool_exp!
	): shared_ldap_organizations_mutation_response
	"update single row of the table: \"shared.ldap_organizations\""
	update_shared_ldap_organizations_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: shared_ldap_organizations_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: shared_ldap_organizations_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: shared_ldap_organizations_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: shared_ldap_organizations_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: shared_ldap_organizations_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: shared_ldap_organizations_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_ldap_organizations_set_input
		pk_columns: shared_ldap_organizations_pk_columns_input!
	): shared_ldap_organizations
	"update data of the table: \"shared.organisations\""
	update_shared_organisations(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: shared_organisations_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: shared_organisations_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: shared_organisations_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: shared_organisations_delete_key_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: shared_organisations_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_organisations_set_input
		"filter the rows which have to be updated"
		where: shared_organisations_bool_exp!
	): shared_organisations_mutation_response
	"update single row of the table: \"shared.organisations\""
	update_shared_organisations_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: shared_organisations_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: shared_organisations_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: shared_organisations_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: shared_organisations_delete_key_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: shared_organisations_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_organisations_set_input
		pk_columns: shared_organisations_pk_columns_input!
	): shared_organisations
	"update data of the table: \"shared.types\""
	update_shared_types(
		"increments the integer columns with given value of the filtered values"
		_inc: shared_types_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_types_set_input
		"filter the rows which have to be updated"
		where: shared_types_bool_exp!
	): shared_types_mutation_response
	"update single row of the table: \"shared.types\""
	update_shared_types_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: shared_types_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_types_set_input
		pk_columns: shared_types_pk_columns_input!
	): shared_types
	"update data of the table: \"shared.user_roles\""
	update_shared_user_roles(
		"increments the integer columns with given value of the filtered values"
		_inc: shared_user_roles_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_user_roles_set_input
		"filter the rows which have to be updated"
		where: shared_user_roles_bool_exp!
	): shared_user_roles_mutation_response
	"update single row of the table: \"shared.user_roles\""
	update_shared_user_roles_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: shared_user_roles_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_user_roles_set_input
		pk_columns: shared_user_roles_pk_columns_input!
	): shared_user_roles
	"update data of the table: \"shared.user_temp_access\""
	update_shared_user_temp_access(
		"sets the columns of the filtered rows to the given values"
		_set: shared_user_temp_access_set_input
		"filter the rows which have to be updated"
		where: shared_user_temp_access_bool_exp!
	): shared_user_temp_access_mutation_response
	"update single row of the table: \"shared.user_temp_access\""
	update_shared_user_temp_access_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: shared_user_temp_access_set_input
		pk_columns: shared_user_temp_access_pk_columns_input!
	): shared_user_temp_access
	"update data of the table: \"shared.users\""
	update_shared_users(
		"increments the integer columns with given value of the filtered values"
		_inc: shared_users_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_users_set_input
		"filter the rows which have to be updated"
		where: shared_users_bool_exp!
	): shared_users_mutation_response
	"update single row of the table: \"shared.users\""
	update_shared_users_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: shared_users_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: shared_users_set_input
		pk_columns: shared_users_pk_columns_input!
	): shared_users
	"update data of the table: \"users.audit_log\""
	update_users_audit_log(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: users_audit_log_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: users_audit_log_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: users_audit_log_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: users_audit_log_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: users_audit_log_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: users_audit_log_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: users_audit_log_set_input
		"filter the rows which have to be updated"
		where: users_audit_log_bool_exp!
	): users_audit_log_mutation_response
	"update single row of the table: \"users.audit_log\""
	update_users_audit_log_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: users_audit_log_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: users_audit_log_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: users_audit_log_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: users_audit_log_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: users_audit_log_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: users_audit_log_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: users_audit_log_set_input
		pk_columns: users_audit_log_pk_columns_input!
	): users_audit_log
	"update data of the table: \"users.email_preferences\""
	update_users_email_preferences(
		"sets the columns of the filtered rows to the given values"
		_set: users_email_preferences_set_input
		"filter the rows which have to be updated"
		where: users_email_preferences_bool_exp!
	): users_email_preferences_mutation_response
	"update single row of the table: \"users.email_preferences\""
	update_users_email_preferences_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: users_email_preferences_set_input
		pk_columns: users_email_preferences_pk_columns_input!
	): users_email_preferences
	"update data of the table: \"users.group_user_permission_groups\""
	update_users_group_user_permission_groups(
		"increments the integer columns with given value of the filtered values"
		_inc: users_group_user_permission_groups_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_group_user_permission_groups_set_input
		"filter the rows which have to be updated"
		where: users_group_user_permission_groups_bool_exp!
	): users_group_user_permission_groups_mutation_response
	"update single row of the table: \"users.group_user_permission_groups\""
	update_users_group_user_permission_groups_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: users_group_user_permission_groups_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_group_user_permission_groups_set_input
		pk_columns: users_group_user_permission_groups_pk_columns_input!
	): users_group_user_permission_groups
	"update data of the table: \"users.groups\""
	update_users_groups(
		"increments the integer columns with given value of the filtered values"
		_inc: users_groups_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_groups_set_input
		"filter the rows which have to be updated"
		where: users_groups_bool_exp!
	): users_groups_mutation_response
	"update single row of the table: \"users.groups\""
	update_users_groups_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: users_groups_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_groups_set_input
		pk_columns: users_groups_pk_columns_input!
	): users_groups
	"update data of the table: \"users.idp_map\""
	update_users_idp_map(
		"increments the integer columns with given value of the filtered values"
		_inc: users_idp_map_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_idp_map_set_input
		"filter the rows which have to be updated"
		where: users_idp_map_bool_exp!
	): users_idp_map_mutation_response
	"update single row of the table: \"users.idp_map\""
	update_users_idp_map_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: users_idp_map_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_idp_map_set_input
		pk_columns: users_idp_map_pk_columns_input!
	): users_idp_map
	"update data of the table: \"users.idps\""
	update_users_idps(
		"sets the columns of the filtered rows to the given values"
		_set: users_idps_set_input
		"filter the rows which have to be updated"
		where: users_idps_bool_exp!
	): users_idps_mutation_response
	"update single row of the table: \"users.idps\""
	update_users_idps_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: users_idps_set_input
		pk_columns: users_idps_pk_columns_input!
	): users_idps
	"update data of the table: \"users.notifications\""
	update_users_notifications(
		"sets the columns of the filtered rows to the given values"
		_set: users_notifications_set_input
		"filter the rows which have to be updated"
		where: users_notifications_bool_exp!
	): users_notifications_mutation_response
	"update single row of the table: \"users.notifications\""
	update_users_notifications_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: users_notifications_set_input
		pk_columns: users_notifications_pk_columns_input!
	): users_notifications
	"update data of the table: \"users.permission_group_user_permissions\""
	update_users_permission_group_user_permissions(
		"increments the integer columns with given value of the filtered values"
		_inc: users_permission_group_user_permissions_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_permission_group_user_permissions_set_input
		"filter the rows which have to be updated"
		where: users_permission_group_user_permissions_bool_exp!
	): users_permission_group_user_permissions_mutation_response
	"update single row of the table: \"users.permission_group_user_permissions\""
	update_users_permission_group_user_permissions_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: users_permission_group_user_permissions_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_permission_group_user_permissions_set_input
		pk_columns: users_permission_group_user_permissions_pk_columns_input!
	): users_permission_group_user_permissions
	"update data of the table: \"users.permission_groups\""
	update_users_permission_groups(
		"increments the integer columns with given value of the filtered values"
		_inc: users_permission_groups_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_permission_groups_set_input
		"filter the rows which have to be updated"
		where: users_permission_groups_bool_exp!
	): users_permission_groups_mutation_response
	"update single row of the table: \"users.permission_groups\""
	update_users_permission_groups_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: users_permission_groups_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_permission_groups_set_input
		pk_columns: users_permission_groups_pk_columns_input!
	): users_permission_groups
	"update data of the table: \"users.permission_matrix_view\""
	update_users_permission_matrix_view(
		"increments the integer columns with given value of the filtered values"
		_inc: users_permission_matrix_view_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_permission_matrix_view_set_input
		"filter the rows which have to be updated"
		where: users_permission_matrix_view_bool_exp!
	): users_permission_matrix_view_mutation_response
	"update data of the table: \"users.permissions\""
	update_users_permissions(
		"increments the integer columns with given value of the filtered values"
		_inc: users_permissions_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_permissions_set_input
		"filter the rows which have to be updated"
		where: users_permissions_bool_exp!
	): users_permissions_mutation_response
	"update single row of the table: \"users.permissions\""
	update_users_permissions_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: users_permissions_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_permissions_set_input
		pk_columns: users_permissions_pk_columns_input!
	): users_permissions
	"update data of the table: \"users.profile_classifications\""
	update_users_profile_classifications(
		"sets the columns of the filtered rows to the given values"
		_set: users_profile_classifications_set_input
		"filter the rows which have to be updated"
		where: users_profile_classifications_bool_exp!
	): users_profile_classifications_mutation_response
	"update single row of the table: \"users.profile_classifications\""
	update_users_profile_classifications_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: users_profile_classifications_set_input
		pk_columns: users_profile_classifications_pk_columns_input!
	): users_profile_classifications
	"update data of the table: \"users.profile_contexts\""
	update_users_profile_contexts(
		"sets the columns of the filtered rows to the given values"
		_set: users_profile_contexts_set_input
		"filter the rows which have to be updated"
		where: users_profile_contexts_bool_exp!
	): users_profile_contexts_mutation_response
	"update single row of the table: \"users.profile_contexts\""
	update_users_profile_contexts_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: users_profile_contexts_set_input
		pk_columns: users_profile_contexts_pk_columns_input!
	): users_profile_contexts
	"update data of the table: \"users.profile_flags\""
	update_users_profile_flags(
		"increments the integer columns with given value of the filtered values"
		_inc: users_profile_flags_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_profile_flags_set_input
		"filter the rows which have to be updated"
		where: users_profile_flags_bool_exp!
	): users_profile_flags_mutation_response
	"update single row of the table: \"users.profile_flags\""
	update_users_profile_flags_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: users_profile_flags_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_profile_flags_set_input
		pk_columns: users_profile_flags_pk_columns_input!
	): users_profile_flags
	"update data of the table: \"users.profile_organizations\""
	update_users_profile_organizations(
		"sets the columns of the filtered rows to the given values"
		_set: users_profile_organizations_set_input
		"filter the rows which have to be updated"
		where: users_profile_organizations_bool_exp!
	): users_profile_organizations_mutation_response
	"update single row of the table: \"users.profile_organizations\""
	update_users_profile_organizations_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: users_profile_organizations_set_input
		pk_columns: users_profile_organizations_pk_columns_input!
	): users_profile_organizations
	"update data of the table: \"users.profile_preferences\""
	update_users_profile_preferences(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: users_profile_preferences_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: users_profile_preferences_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: users_profile_preferences_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: users_profile_preferences_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: users_profile_preferences_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: users_profile_preferences_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: users_profile_preferences_set_input
		"filter the rows which have to be updated"
		where: users_profile_preferences_bool_exp!
	): users_profile_preferences_mutation_response
	"update single row of the table: \"users.profile_preferences\""
	update_users_profile_preferences_by_pk(
		"append existing jsonb value of filtered columns with new jsonb value"
		_append: users_profile_preferences_append_input
		"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
		_delete_at_path: users_profile_preferences_delete_at_path_input
		"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
		_delete_elem: users_profile_preferences_delete_elem_input
		"delete key/value pair or string element. key/value pairs are matched based on their key value"
		_delete_key: users_profile_preferences_delete_key_input
		"increments the integer columns with given value of the filtered values"
		_inc: users_profile_preferences_inc_input
		"prepend existing jsonb value of filtered columns with new jsonb value"
		_prepend: users_profile_preferences_prepend_input
		"sets the columns of the filtered rows to the given values"
		_set: users_profile_preferences_set_input
		pk_columns: users_profile_preferences_pk_columns_input!
	): users_profile_preferences
	"update data of the table: \"users.profile_user_groups\""
	update_users_profile_user_groups(
		"increments the integer columns with given value of the filtered values"
		_inc: users_profile_user_groups_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_profile_user_groups_set_input
		"filter the rows which have to be updated"
		where: users_profile_user_groups_bool_exp!
	): users_profile_user_groups_mutation_response
	"update single row of the table: \"users.profile_user_groups\""
	update_users_profile_user_groups_by_pk(
		"increments the integer columns with given value of the filtered values"
		_inc: users_profile_user_groups_inc_input
		"sets the columns of the filtered rows to the given values"
		_set: users_profile_user_groups_set_input
		pk_columns: users_profile_user_groups_pk_columns_input!
	): users_profile_user_groups
	"update data of the table: \"users.profiles\""
	update_users_profiles(
		"sets the columns of the filtered rows to the given values"
		_set: users_profiles_set_input
		"filter the rows which have to be updated"
		where: users_profiles_bool_exp!
	): users_profiles_mutation_response
	"update single row of the table: \"users.profiles\""
	update_users_profiles_by_pk(
		"sets the columns of the filtered rows to the given values"
		_set: users_profiles_set_input
		pk_columns: users_profiles_pk_columns_input!
	): users_profiles
}

"query root"
type query_root {
	"fetch data from the table: \"app.assignment_assignment_tags\""
	app_assignment_assignment_tags(
		"distinct select on columns"
		distinct_on: [app_assignment_assignment_tags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_assignment_tags_order_by!]
		"filter the rows returned"
		where: app_assignment_assignment_tags_bool_exp
	): [app_assignment_assignment_tags!]!
	"fetch aggregated fields from the table: \"app.assignment_assignment_tags\""
	app_assignment_assignment_tags_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_assignment_tags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_assignment_tags_order_by!]
		"filter the rows returned"
		where: app_assignment_assignment_tags_bool_exp
	): app_assignment_assignment_tags_aggregate!
	"fetch data from the table: \"app.assignment_assignment_tags\" using primary key columns"
	app_assignment_assignment_tags_by_pk(id: Int!): app_assignment_assignment_tags
	"fetch data from the table: \"app.assignment_blocks_v2\""
	app_assignment_blocks_v2(
		"distinct select on columns"
		distinct_on: [app_assignment_blocks_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_blocks_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_blocks_v2_bool_exp
	): [app_assignment_blocks_v2!]!
	"fetch aggregated fields from the table: \"app.assignment_blocks_v2\""
	app_assignment_blocks_v2_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_blocks_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_blocks_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_blocks_v2_bool_exp
	): app_assignment_blocks_v2_aggregate!
	"fetch data from the table: \"app.assignment_blocks_v2\" using primary key columns"
	app_assignment_blocks_v2_by_pk(id: uuid!): app_assignment_blocks_v2
	"fetch data from the table: \"app.assignment_labels\""
	app_assignment_labels(
		"distinct select on columns"
		distinct_on: [app_assignment_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_labels_order_by!]
		"filter the rows returned"
		where: app_assignment_labels_bool_exp
	): [app_assignment_labels!]!
	"fetch aggregated fields from the table: \"app.assignment_labels\""
	app_assignment_labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_labels_order_by!]
		"filter the rows returned"
		where: app_assignment_labels_bool_exp
	): app_assignment_labels_aggregate!
	"fetch data from the table: \"app.assignment_labels\" using primary key columns"
	app_assignment_labels_by_pk(id: Int!): app_assignment_labels
	"fetch data from the table: \"app.assignment_labels_v2\""
	app_assignment_labels_v2(
		"distinct select on columns"
		distinct_on: [app_assignment_labels_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_labels_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_labels_v2_bool_exp
	): [app_assignment_labels_v2!]!
	"fetch aggregated fields from the table: \"app.assignment_labels_v2\""
	app_assignment_labels_v2_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_labels_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_labels_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_labels_v2_bool_exp
	): app_assignment_labels_v2_aggregate!
	"fetch data from the table: \"app.assignment_labels_v2\" using primary key columns"
	app_assignment_labels_v2_by_pk(id: uuid!): app_assignment_labels_v2
	"fetch data from the table: \"app.assignment_responses\""
	app_assignment_responses(
		"distinct select on columns"
		distinct_on: [app_assignment_responses_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_responses_order_by!]
		"filter the rows returned"
		where: app_assignment_responses_bool_exp
	): [app_assignment_responses!]!
	"fetch aggregated fields from the table: \"app.assignment_responses\""
	app_assignment_responses_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_responses_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_responses_order_by!]
		"filter the rows returned"
		where: app_assignment_responses_bool_exp
	): app_assignment_responses_aggregate!
	"fetch data from the table: \"app.assignment_responses\" using primary key columns"
	app_assignment_responses_by_pk(id: Int!): app_assignment_responses
	"fetch data from the table: \"app.assignment_responses_v2\""
	app_assignment_responses_v2(
		"distinct select on columns"
		distinct_on: [app_assignment_responses_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_responses_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_responses_v2_bool_exp
	): [app_assignment_responses_v2!]!
	"fetch aggregated fields from the table: \"app.assignment_responses_v2\""
	app_assignment_responses_v2_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_responses_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_responses_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_responses_v2_bool_exp
	): app_assignment_responses_v2_aggregate!
	"fetch data from the table: \"app.assignment_responses_v2\" using primary key columns"
	app_assignment_responses_v2_by_pk(id: uuid!): app_assignment_responses_v2
	"fetch data from the table: \"app.assignment_v2_views\""
	app_assignment_v2_views(
		"distinct select on columns"
		distinct_on: [app_assignment_v2_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_v2_views_order_by!]
		"filter the rows returned"
		where: app_assignment_v2_views_bool_exp
	): [app_assignment_v2_views!]!
	"fetch aggregated fields from the table: \"app.assignment_v2_views\""
	app_assignment_v2_views_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_v2_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_v2_views_order_by!]
		"filter the rows returned"
		where: app_assignment_v2_views_bool_exp
	): app_assignment_v2_views_aggregate!
	"fetch data from the table: \"app.assignment_v2_views\" using primary key columns"
	app_assignment_v2_views_by_pk(id: uuid!): app_assignment_v2_views
	"fetch data from the table: \"app.assignments\""
	app_assignments(
		"distinct select on columns"
		distinct_on: [app_assignments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_order_by!]
		"filter the rows returned"
		where: app_assignments_bool_exp
	): [app_assignments!]!
	"fetch aggregated fields from the table: \"app.assignments\""
	app_assignments_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_order_by!]
		"filter the rows returned"
		where: app_assignments_bool_exp
	): app_assignments_aggregate!
	"fetch data from the table: \"app.assignments\" using primary key columns"
	app_assignments_by_pk(uuid: uuid!): app_assignments
	"fetch data from the table: \"app.assignments_v2\""
	app_assignments_v2(
		"distinct select on columns"
		distinct_on: [app_assignments_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_v2_order_by!]
		"filter the rows returned"
		where: app_assignments_v2_bool_exp
	): [app_assignments_v2!]!
	"fetch aggregated fields from the table: \"app.assignments_v2\""
	app_assignments_v2_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignments_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_v2_order_by!]
		"filter the rows returned"
		where: app_assignments_v2_bool_exp
	): app_assignments_v2_aggregate!
	"fetch data from the table: \"app.assignments_v2_assignment_labels_v2\""
	app_assignments_v2_assignment_labels_v2(
		"distinct select on columns"
		distinct_on: [app_assignments_v2_assignment_labels_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_v2_assignment_labels_v2_order_by!]
		"filter the rows returned"
		where: app_assignments_v2_assignment_labels_v2_bool_exp
	): [app_assignments_v2_assignment_labels_v2!]!
	"fetch aggregated fields from the table: \"app.assignments_v2_assignment_labels_v2\""
	app_assignments_v2_assignment_labels_v2_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignments_v2_assignment_labels_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_v2_assignment_labels_v2_order_by!]
		"filter the rows returned"
		where: app_assignments_v2_assignment_labels_v2_bool_exp
	): app_assignments_v2_assignment_labels_v2_aggregate!
	"fetch data from the table: \"app.assignments_v2_assignment_labels_v2\" using primary key columns"
	app_assignments_v2_assignment_labels_v2_by_pk(id: Int!): app_assignments_v2_assignment_labels_v2
	"fetch data from the table: \"app.assignments_v2\" using primary key columns"
	app_assignments_v2_by_pk(id: uuid!): app_assignments_v2
	"fetch data from the table: \"app.collection_actualisation_overview\""
	app_collection_actualisation_overview(
		"distinct select on columns"
		distinct_on: [app_collection_actualisation_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_actualisation_overview_order_by!]
		"filter the rows returned"
		where: app_collection_actualisation_overview_bool_exp
	): [app_collection_actualisation_overview!]!
	"fetch aggregated fields from the table: \"app.collection_actualisation_overview\""
	app_collection_actualisation_overview_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_actualisation_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_actualisation_overview_order_by!]
		"filter the rows returned"
		where: app_collection_actualisation_overview_bool_exp
	): app_collection_actualisation_overview_aggregate!
	"fetch data from the table: \"app.collection_bookmarks\""
	app_collection_bookmarks(
		"distinct select on columns"
		distinct_on: [app_collection_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_bookmarks_order_by!]
		"filter the rows returned"
		where: app_collection_bookmarks_bool_exp
	): [app_collection_bookmarks!]!
	"fetch aggregated fields from the table: \"app.collection_bookmarks\""
	app_collection_bookmarks_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_bookmarks_order_by!]
		"filter the rows returned"
		where: app_collection_bookmarks_bool_exp
	): app_collection_bookmarks_aggregate!
	"fetch data from the table: \"app.collection_bookmarks\" using primary key columns"
	app_collection_bookmarks_by_pk(id: Int!): app_collection_bookmarks
	"fetch data from the table: \"app.collection_counts\""
	app_collection_counts(
		"distinct select on columns"
		distinct_on: [app_collection_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_counts_order_by!]
		"filter the rows returned"
		where: app_collection_counts_bool_exp
	): [app_collection_counts!]!
	"fetch aggregated fields from the table: \"app.collection_counts\""
	app_collection_counts_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_counts_order_by!]
		"filter the rows returned"
		where: app_collection_counts_bool_exp
	): app_collection_counts_aggregate!
	"fetch data from the table: \"app.collection_fragments\""
	app_collection_fragments(
		"distinct select on columns"
		distinct_on: [app_collection_fragments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_fragments_order_by!]
		"filter the rows returned"
		where: app_collection_fragments_bool_exp
	): [app_collection_fragments!]!
	"fetch aggregated fields from the table: \"app.collection_fragments\""
	app_collection_fragments_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_fragments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_fragments_order_by!]
		"filter the rows returned"
		where: app_collection_fragments_bool_exp
	): app_collection_fragments_aggregate!
	"fetch data from the table: \"app.collection_fragments\" using primary key columns"
	app_collection_fragments_by_pk(id: Int!): app_collection_fragments
	"fetch data from the table: \"app.collection_labels\""
	app_collection_labels(
		"distinct select on columns"
		distinct_on: [app_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_labels_order_by!]
		"filter the rows returned"
		where: app_collection_labels_bool_exp
	): [app_collection_labels!]!
	"fetch aggregated fields from the table: \"app.collection_labels\""
	app_collection_labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_labels_order_by!]
		"filter the rows returned"
		where: app_collection_labels_bool_exp
	): app_collection_labels_aggregate!
	"fetch data from the table: \"app.collection_labels\" using primary key columns"
	app_collection_labels_by_pk(id: Int!): app_collection_labels
	"fetch data from the table: \"app.collection_management\""
	app_collection_management(
		"distinct select on columns"
		distinct_on: [app_collection_management_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_management_order_by!]
		"filter the rows returned"
		where: app_collection_management_bool_exp
	): [app_collection_management!]!
	"fetch data from the table: \"app.collection_management_QC\""
	app_collection_management_QC(
		"distinct select on columns"
		distinct_on: [app_collection_management_QC_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_management_QC_order_by!]
		"filter the rows returned"
		where: app_collection_management_QC_bool_exp
	): [app_collection_management_QC!]!
	"fetch aggregated fields from the table: \"app.collection_management_QC\""
	app_collection_management_QC_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_management_QC_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_management_QC_order_by!]
		"filter the rows returned"
		where: app_collection_management_QC_bool_exp
	): app_collection_management_QC_aggregate!
	"fetch data from the table: \"app.collection_management_QC\" using primary key columns"
	app_collection_management_QC_by_pk(id: Int!): app_collection_management_QC
	"fetch aggregated fields from the table: \"app.collection_management\""
	app_collection_management_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_management_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_management_order_by!]
		"filter the rows returned"
		where: app_collection_management_bool_exp
	): app_collection_management_aggregate!
	"fetch data from the table: \"app.collection_management\" using primary key columns"
	app_collection_management_by_pk(id: Int!): app_collection_management
	"fetch data from the table: \"app.collection_marcom_klascement_view\""
	app_collection_marcom_klascement_view(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_klascement_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_klascement_view_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_klascement_view_bool_exp
	): [app_collection_marcom_klascement_view!]!
	"fetch aggregated fields from the table: \"app.collection_marcom_klascement_view\""
	app_collection_marcom_klascement_view_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_klascement_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_klascement_view_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_klascement_view_bool_exp
	): app_collection_marcom_klascement_view_aggregate!
	"fetch data from the table: \"app.collection_marcom_log\""
	app_collection_marcom_log(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_log_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_log_bool_exp
	): [app_collection_marcom_log!]!
	"fetch aggregated fields from the table: \"app.collection_marcom_log\""
	app_collection_marcom_log_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_log_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_log_bool_exp
	): app_collection_marcom_log_aggregate!
	"fetch data from the table: \"app.collection_marcom_log\" using primary key columns"
	app_collection_marcom_log_by_pk(id: Int!): app_collection_marcom_log
	"fetch data from the table: \"app.collection_marcom_notes\""
	app_collection_marcom_notes(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_notes_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_notes_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_notes_bool_exp
	): [app_collection_marcom_notes!]!
	"fetch aggregated fields from the table: \"app.collection_marcom_notes\""
	app_collection_marcom_notes_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_notes_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_notes_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_notes_bool_exp
	): app_collection_marcom_notes_aggregate!
	"fetch data from the table: \"app.collection_marcom_notes\" using primary key columns"
	app_collection_marcom_notes_by_pk(collection_id: uuid!): app_collection_marcom_notes
	"fetch data from the table: \"app.collection_marcom_overview\""
	app_collection_marcom_overview(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_overview_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_overview_bool_exp
	): [app_collection_marcom_overview!]!
	"fetch aggregated fields from the table: \"app.collection_marcom_overview\""
	app_collection_marcom_overview_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_overview_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_overview_bool_exp
	): app_collection_marcom_overview_aggregate!
	"fetch data from the table: \"app.collection_plays\""
	app_collection_plays(
		"distinct select on columns"
		distinct_on: [app_collection_plays_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_plays_order_by!]
		"filter the rows returned"
		where: app_collection_plays_bool_exp
	): [app_collection_plays!]!
	"fetch aggregated fields from the table: \"app.collection_plays\""
	app_collection_plays_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_plays_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_plays_order_by!]
		"filter the rows returned"
		where: app_collection_plays_bool_exp
	): app_collection_plays_aggregate!
	"fetch data from the table: \"app.collection_plays\" using primary key columns"
	app_collection_plays_by_pk(id: Int!): app_collection_plays
	"fetch data from the table: \"app.collection_qc_overview\""
	app_collection_qc_overview(
		"distinct select on columns"
		distinct_on: [app_collection_qc_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_qc_overview_order_by!]
		"filter the rows returned"
		where: app_collection_qc_overview_bool_exp
	): [app_collection_qc_overview!]!
	"fetch aggregated fields from the table: \"app.collection_qc_overview\""
	app_collection_qc_overview_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_qc_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_qc_overview_order_by!]
		"filter the rows returned"
		where: app_collection_qc_overview_bool_exp
	): app_collection_qc_overview_aggregate!
	"fetch data from the table: \"app.collection_relations\""
	app_collection_relations(
		"distinct select on columns"
		distinct_on: [app_collection_relations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_relations_order_by!]
		"filter the rows returned"
		where: app_collection_relations_bool_exp
	): [app_collection_relations!]!
	"fetch aggregated fields from the table: \"app.collection_relations\""
	app_collection_relations_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_relations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_relations_order_by!]
		"filter the rows returned"
		where: app_collection_relations_bool_exp
	): app_collection_relations_aggregate!
	"fetch data from the table: \"app.collection_relations\" using primary key columns"
	app_collection_relations_by_pk(id: Int!): app_collection_relations
	"fetch data from the table: \"app.collection_relations_view\""
	app_collection_relations_view(
		"distinct select on columns"
		distinct_on: [app_collection_relations_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_relations_view_order_by!]
		"filter the rows returned"
		where: app_collection_relations_view_bool_exp
	): [app_collection_relations_view!]!
	"fetch aggregated fields from the table: \"app.collection_relations_view\""
	app_collection_relations_view_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_relations_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_relations_view_order_by!]
		"filter the rows returned"
		where: app_collection_relations_view_bool_exp
	): app_collection_relations_view_aggregate!
	"fetch data from the table: \"app.collection_views\""
	app_collection_views(
		"distinct select on columns"
		distinct_on: [app_collection_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_views_order_by!]
		"filter the rows returned"
		where: app_collection_views_bool_exp
	): [app_collection_views!]!
	"fetch aggregated fields from the table: \"app.collection_views\""
	app_collection_views_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_views_order_by!]
		"filter the rows returned"
		where: app_collection_views_bool_exp
	): app_collection_views_aggregate!
	"fetch data from the table: \"app.collection_views\" using primary key columns"
	app_collection_views_by_pk(id: Int!): app_collection_views
	"fetch data from the table: \"app.collections\""
	app_collections(
		"distinct select on columns"
		distinct_on: [app_collections_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collections_order_by!]
		"filter the rows returned"
		where: app_collections_bool_exp
	): [app_collections!]!
	"fetch aggregated fields from the table: \"app.collections\""
	app_collections_aggregate(
		"distinct select on columns"
		distinct_on: [app_collections_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collections_order_by!]
		"filter the rows returned"
		where: app_collections_bool_exp
	): app_collections_aggregate!
	"fetch data from the table: \"app.collections\" using primary key columns"
	app_collections_by_pk(id: uuid!): app_collections
	"fetch data from the table: \"app.content\""
	app_content(
		"distinct select on columns"
		distinct_on: [app_content_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_order_by!]
		"filter the rows returned"
		where: app_content_bool_exp
	): [app_content!]!
	"fetch aggregated fields from the table: \"app.content\""
	app_content_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_order_by!]
		"filter the rows returned"
		where: app_content_bool_exp
	): app_content_aggregate!
	"fetch data from the table: \"app.content_assets\""
	app_content_assets(
		"distinct select on columns"
		distinct_on: [app_content_assets_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_assets_order_by!]
		"filter the rows returned"
		where: app_content_assets_bool_exp
	): [app_content_assets!]!
	"fetch aggregated fields from the table: \"app.content_assets\""
	app_content_assets_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_assets_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_assets_order_by!]
		"filter the rows returned"
		where: app_content_assets_bool_exp
	): app_content_assets_aggregate!
	"fetch data from the table: \"app.content_assets\" using primary key columns"
	app_content_assets_by_pk(id: Int!): app_content_assets
	"fetch data from the table: \"app.content_blocks\""
	app_content_blocks(
		"distinct select on columns"
		distinct_on: [app_content_blocks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_blocks_order_by!]
		"filter the rows returned"
		where: app_content_blocks_bool_exp
	): [app_content_blocks!]!
	"fetch aggregated fields from the table: \"app.content_blocks\""
	app_content_blocks_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_blocks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_blocks_order_by!]
		"filter the rows returned"
		where: app_content_blocks_bool_exp
	): app_content_blocks_aggregate!
	"fetch data from the table: \"app.content_blocks\" using primary key columns"
	app_content_blocks_by_pk(id: Int!): app_content_blocks
	"fetch data from the table: \"app.content\" using primary key columns"
	app_content_by_pk(id: Int!): app_content
	"fetch data from the table: \"app.content_content_labels\""
	app_content_content_labels(
		"distinct select on columns"
		distinct_on: [app_content_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_content_labels_order_by!]
		"filter the rows returned"
		where: app_content_content_labels_bool_exp
	): [app_content_content_labels!]!
	"fetch aggregated fields from the table: \"app.content_content_labels\""
	app_content_content_labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_content_labels_order_by!]
		"filter the rows returned"
		where: app_content_content_labels_bool_exp
	): app_content_content_labels_aggregate!
	"fetch data from the table: \"app.content_content_labels\" using primary key columns"
	app_content_content_labels_by_pk(id: Int!): app_content_content_labels
	"fetch data from the table: \"app.content_labels\""
	app_content_labels(
		"distinct select on columns"
		distinct_on: [app_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_labels_order_by!]
		"filter the rows returned"
		where: app_content_labels_bool_exp
	): [app_content_labels!]!
	"fetch aggregated fields from the table: \"app.content_labels\""
	app_content_labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_labels_order_by!]
		"filter the rows returned"
		where: app_content_labels_bool_exp
	): app_content_labels_aggregate!
	"fetch data from the table: \"app.content_labels\" using primary key columns"
	app_content_labels_by_pk(id: Int!): app_content_labels
	"fetch data from the table: \"app.content_lower_title\""
	app_content_lower_title(
		"distinct select on columns"
		distinct_on: [app_content_lower_title_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_lower_title_order_by!]
		"filter the rows returned"
		where: app_content_lower_title_bool_exp
	): [app_content_lower_title!]!
	"fetch aggregated fields from the table: \"app.content_lower_title\""
	app_content_lower_title_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_lower_title_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_lower_title_order_by!]
		"filter the rows returned"
		where: app_content_lower_title_bool_exp
	): app_content_lower_title_aggregate!
	"fetch data from the table: \"app.content_nav_elements\""
	app_content_nav_elements(
		"distinct select on columns"
		distinct_on: [app_content_nav_elements_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_nav_elements_order_by!]
		"filter the rows returned"
		where: app_content_nav_elements_bool_exp
	): [app_content_nav_elements!]!
	"fetch aggregated fields from the table: \"app.content_nav_elements\""
	app_content_nav_elements_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_nav_elements_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_nav_elements_order_by!]
		"filter the rows returned"
		where: app_content_nav_elements_bool_exp
	): app_content_nav_elements_aggregate!
	"fetch data from the table: \"app.content_nav_elements\" using primary key columns"
	app_content_nav_elements_by_pk(id: Int!): app_content_nav_elements
	"fetch data from the table: \"app.interactive_tour\""
	app_interactive_tour(
		"distinct select on columns"
		distinct_on: [app_interactive_tour_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_interactive_tour_order_by!]
		"filter the rows returned"
		where: app_interactive_tour_bool_exp
	): [app_interactive_tour!]!
	"fetch aggregated fields from the table: \"app.interactive_tour\""
	app_interactive_tour_aggregate(
		"distinct select on columns"
		distinct_on: [app_interactive_tour_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_interactive_tour_order_by!]
		"filter the rows returned"
		where: app_interactive_tour_bool_exp
	): app_interactive_tour_aggregate!
	"fetch data from the table: \"app.interactive_tour\" using primary key columns"
	app_interactive_tour_by_pk(id: Int!): app_interactive_tour
	"fetch data from the table: \"app.item_bookmarks\""
	app_item_bookmarks(
		"distinct select on columns"
		distinct_on: [app_item_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_bookmarks_order_by!]
		"filter the rows returned"
		where: app_item_bookmarks_bool_exp
	): [app_item_bookmarks!]!
	"fetch aggregated fields from the table: \"app.item_bookmarks\""
	app_item_bookmarks_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_bookmarks_order_by!]
		"filter the rows returned"
		where: app_item_bookmarks_bool_exp
	): app_item_bookmarks_aggregate!
	"fetch data from the table: \"app.item_bookmarks\" using primary key columns"
	app_item_bookmarks_by_pk(id: Int!): app_item_bookmarks
	"fetch data from the table: \"app.item_collateral\""
	app_item_collateral(
		"distinct select on columns"
		distinct_on: [app_item_collateral_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_collateral_order_by!]
		"filter the rows returned"
		where: app_item_collateral_bool_exp
	): [app_item_collateral!]!
	"fetch aggregated fields from the table: \"app.item_collateral\""
	app_item_collateral_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_collateral_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_collateral_order_by!]
		"filter the rows returned"
		where: app_item_collateral_bool_exp
	): app_item_collateral_aggregate!
	"fetch data from the table: \"app.item_collateral\" using primary key columns"
	app_item_collateral_by_pk(external_id: String!): app_item_collateral
	"fetch data from the table: \"app.item_counts\""
	app_item_counts(
		"distinct select on columns"
		distinct_on: [app_item_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_counts_order_by!]
		"filter the rows returned"
		where: app_item_counts_bool_exp
	): [app_item_counts!]!
	"fetch aggregated fields from the table: \"app.item_counts\""
	app_item_counts_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_counts_order_by!]
		"filter the rows returned"
		where: app_item_counts_bool_exp
	): app_item_counts_aggregate!
	"fetch data from the table: \"app.item_meta\""
	app_item_meta(
		"distinct select on columns"
		distinct_on: [app_item_meta_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_meta_order_by!]
		"filter the rows returned"
		where: app_item_meta_bool_exp
	): [app_item_meta!]!
	"fetch aggregated fields from the table: \"app.item_meta\""
	app_item_meta_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_meta_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_meta_order_by!]
		"filter the rows returned"
		where: app_item_meta_bool_exp
	): app_item_meta_aggregate!
	"fetch data from the table: \"app.item_meta\" using primary key columns"
	app_item_meta_by_pk(id: Int!): app_item_meta
	"fetch data from the table: \"app.item_plays\""
	app_item_plays(
		"distinct select on columns"
		distinct_on: [app_item_plays_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_plays_order_by!]
		"filter the rows returned"
		where: app_item_plays_bool_exp
	): [app_item_plays!]!
	"fetch aggregated fields from the table: \"app.item_plays\""
	app_item_plays_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_plays_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_plays_order_by!]
		"filter the rows returned"
		where: app_item_plays_bool_exp
	): app_item_plays_aggregate!
	"fetch data from the table: \"app.item_plays\" using primary key columns"
	app_item_plays_by_pk(id: Int!): app_item_plays
	"fetch data from the table: \"app.item_relations\""
	app_item_relations(
		"distinct select on columns"
		distinct_on: [app_item_relations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_relations_order_by!]
		"filter the rows returned"
		where: app_item_relations_bool_exp
	): [app_item_relations!]!
	"fetch aggregated fields from the table: \"app.item_relations\""
	app_item_relations_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_relations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_relations_order_by!]
		"filter the rows returned"
		where: app_item_relations_bool_exp
	): app_item_relations_aggregate!
	"fetch data from the table: \"app.item_relations\" using primary key columns"
	app_item_relations_by_pk(id: Int!): app_item_relations
	"fetch data from the table: \"app.item_relations_view\""
	app_item_relations_view(
		"distinct select on columns"
		distinct_on: [app_item_relations_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_relations_view_order_by!]
		"filter the rows returned"
		where: app_item_relations_view_bool_exp
	): [app_item_relations_view!]!
	"fetch aggregated fields from the table: \"app.item_relations_view\""
	app_item_relations_view_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_relations_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_relations_view_order_by!]
		"filter the rows returned"
		where: app_item_relations_view_bool_exp
	): app_item_relations_view_aggregate!
	"fetch data from the table: \"app.item_score\""
	app_item_score(
		"distinct select on columns"
		distinct_on: [app_item_score_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_score_order_by!]
		"filter the rows returned"
		where: app_item_score_bool_exp
	): [app_item_score!]!
	"fetch aggregated fields from the table: \"app.item_score\""
	app_item_score_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_score_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_score_order_by!]
		"filter the rows returned"
		where: app_item_score_bool_exp
	): app_item_score_aggregate!
	"fetch data from the table: \"app.item_score\" using primary key columns"
	app_item_score_by_pk(id: Int!): app_item_score
	"fetch data from the table: \"app.item_views\""
	app_item_views(
		"distinct select on columns"
		distinct_on: [app_item_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_views_order_by!]
		"filter the rows returned"
		where: app_item_views_bool_exp
	): [app_item_views!]!
	"fetch aggregated fields from the table: \"app.item_views\""
	app_item_views_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_views_order_by!]
		"filter the rows returned"
		where: app_item_views_bool_exp
	): app_item_views_aggregate!
	"fetch data from the table: \"app.item_views\" using primary key columns"
	app_item_views_by_pk(id: Int!): app_item_views
	"fetch data from the table: \"app.pupil_collection_blocks\""
	app_pupil_collection_blocks(
		"distinct select on columns"
		distinct_on: [app_pupil_collection_blocks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_pupil_collection_blocks_order_by!]
		"filter the rows returned"
		where: app_pupil_collection_blocks_bool_exp
	): [app_pupil_collection_blocks!]!
	"fetch aggregated fields from the table: \"app.pupil_collection_blocks\""
	app_pupil_collection_blocks_aggregate(
		"distinct select on columns"
		distinct_on: [app_pupil_collection_blocks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_pupil_collection_blocks_order_by!]
		"filter the rows returned"
		where: app_pupil_collection_blocks_bool_exp
	): app_pupil_collection_blocks_aggregate!
	"fetch data from the table: \"app.pupil_collection_blocks\" using primary key columns"
	app_pupil_collection_blocks_by_pk(id: uuid!): app_pupil_collection_blocks
	"fetch data from the table: \"app.quick_lanes\""
	app_quick_lanes(
		"distinct select on columns"
		distinct_on: [app_quick_lanes_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_quick_lanes_order_by!]
		"filter the rows returned"
		where: app_quick_lanes_bool_exp
	): [app_quick_lanes!]!
	"fetch aggregated fields from the table: \"app.quick_lanes\""
	app_quick_lanes_aggregate(
		"distinct select on columns"
		distinct_on: [app_quick_lanes_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_quick_lanes_order_by!]
		"filter the rows returned"
		where: app_quick_lanes_bool_exp
	): app_quick_lanes_aggregate!
	"fetch data from the table: \"app.quick_lanes\" using primary key columns"
	app_quick_lanes_by_pk(id: uuid!): app_quick_lanes
	"fetch data from the table: \"app.quick_lanes_overview\""
	app_quick_lanes_overview(
		"distinct select on columns"
		distinct_on: [app_quick_lanes_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_quick_lanes_overview_order_by!]
		"filter the rows returned"
		where: app_quick_lanes_overview_bool_exp
	): [app_quick_lanes_overview!]!
	"fetch aggregated fields from the table: \"app.quick_lanes_overview\""
	app_quick_lanes_overview_aggregate(
		"distinct select on columns"
		distinct_on: [app_quick_lanes_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_quick_lanes_overview_order_by!]
		"filter the rows returned"
		where: app_quick_lanes_overview_bool_exp
	): app_quick_lanes_overview_aggregate!
	"fetch data from the table: \"app.search_bookmarks\""
	app_search_bookmarks(
		"distinct select on columns"
		distinct_on: [app_search_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_search_bookmarks_order_by!]
		"filter the rows returned"
		where: app_search_bookmarks_bool_exp
	): [app_search_bookmarks!]!
	"fetch aggregated fields from the table: \"app.search_bookmarks\""
	app_search_bookmarks_aggregate(
		"distinct select on columns"
		distinct_on: [app_search_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_search_bookmarks_order_by!]
		"filter the rows returned"
		where: app_search_bookmarks_bool_exp
	): app_search_bookmarks_aggregate!
	"fetch data from the table: \"app.search_bookmarks\" using primary key columns"
	app_search_bookmarks_by_pk(id: uuid!): app_search_bookmarks
	"fetch data from the table: \"app.site_variables\""
	app_site_variables(
		"distinct select on columns"
		distinct_on: [app_site_variables_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_site_variables_order_by!]
		"filter the rows returned"
		where: app_site_variables_bool_exp
	): [app_site_variables!]!
	"fetch aggregated fields from the table: \"app.site_variables\""
	app_site_variables_aggregate(
		"distinct select on columns"
		distinct_on: [app_site_variables_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_site_variables_order_by!]
		"filter the rows returned"
		where: app_site_variables_bool_exp
	): app_site_variables_aggregate!
	"fetch data from the table: \"app.site_variables\" using primary key columns"
	app_site_variables_by_pk(name: String!): app_site_variables
	"fetch data from the table: \"app.usage_counts\""
	app_usage_counts(
		"distinct select on columns"
		distinct_on: [app_usage_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_usage_counts_order_by!]
		"filter the rows returned"
		where: app_usage_counts_bool_exp
	): [app_usage_counts!]!
	"fetch aggregated fields from the table: \"app.usage_counts\""
	app_usage_counts_aggregate(
		"distinct select on columns"
		distinct_on: [app_usage_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_usage_counts_order_by!]
		"filter the rows returned"
		where: app_usage_counts_bool_exp
	): app_usage_counts_aggregate!
	"fetch data from the table: \"lookup.enum_assignment_content_labels\""
	lookup_enum_assignment_content_labels(
		"distinct select on columns"
		distinct_on: [lookup_enum_assignment_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_assignment_content_labels_order_by!]
		"filter the rows returned"
		where: lookup_enum_assignment_content_labels_bool_exp
	): [lookup_enum_assignment_content_labels!]!
	"fetch aggregated fields from the table: \"lookup.enum_assignment_content_labels\""
	lookup_enum_assignment_content_labels_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_assignment_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_assignment_content_labels_order_by!]
		"filter the rows returned"
		where: lookup_enum_assignment_content_labels_bool_exp
	): lookup_enum_assignment_content_labels_aggregate!
	"fetch data from the table: \"lookup.enum_assignment_content_labels\" using primary key columns"
	lookup_enum_assignment_content_labels_by_pk(
		value: String!
	): lookup_enum_assignment_content_labels
	"fetch data from the table: \"lookup.enum_assignment_types\""
	lookup_enum_assignment_types(
		"distinct select on columns"
		distinct_on: [lookup_enum_assignment_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_assignment_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_assignment_types_bool_exp
	): [lookup_enum_assignment_types!]!
	"fetch aggregated fields from the table: \"lookup.enum_assignment_types\""
	lookup_enum_assignment_types_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_assignment_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_assignment_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_assignment_types_bool_exp
	): lookup_enum_assignment_types_aggregate!
	"fetch data from the table: \"lookup.enum_assignment_types\" using primary key columns"
	lookup_enum_assignment_types_by_pk(value: String!): lookup_enum_assignment_types
	"fetch data from the table: \"lookup.enum_collection_labels\""
	lookup_enum_collection_labels(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_labels_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_labels_bool_exp
	): [lookup_enum_collection_labels!]!
	"fetch aggregated fields from the table: \"lookup.enum_collection_labels\""
	lookup_enum_collection_labels_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_labels_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_labels_bool_exp
	): lookup_enum_collection_labels_aggregate!
	"fetch data from the table: \"lookup.enum_collection_labels\" using primary key columns"
	lookup_enum_collection_labels_by_pk(value: String!): lookup_enum_collection_labels
	"fetch data from the table: \"lookup.enum_collection_management_qc_label\""
	lookup_enum_collection_management_qc_label(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_management_qc_label_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_management_qc_label_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_management_qc_label_bool_exp
	): [lookup_enum_collection_management_qc_label!]!
	"fetch aggregated fields from the table: \"lookup.enum_collection_management_qc_label\""
	lookup_enum_collection_management_qc_label_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_management_qc_label_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_management_qc_label_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_management_qc_label_bool_exp
	): lookup_enum_collection_management_qc_label_aggregate!
	"fetch data from the table: \"lookup.enum_collection_management_qc_label\" using primary key columns"
	lookup_enum_collection_management_qc_label_by_pk(
		value: String!
	): lookup_enum_collection_management_qc_label
	"fetch data from the table: \"lookup.enum_collection_management_status\""
	lookup_enum_collection_management_status(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_management_status_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_management_status_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_management_status_bool_exp
	): [lookup_enum_collection_management_status!]!
	"fetch aggregated fields from the table: \"lookup.enum_collection_management_status\""
	lookup_enum_collection_management_status_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_management_status_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_management_status_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_management_status_bool_exp
	): lookup_enum_collection_management_status_aggregate!
	"fetch data from the table: \"lookup.enum_collection_management_status\" using primary key columns"
	lookup_enum_collection_management_status_by_pk(
		value: String!
	): lookup_enum_collection_management_status
	"fetch data from the table: \"lookup.enum_colors\""
	lookup_enum_colors(
		"distinct select on columns"
		distinct_on: [lookup_enum_colors_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_colors_order_by!]
		"filter the rows returned"
		where: lookup_enum_colors_bool_exp
	): [lookup_enum_colors!]!
	"fetch aggregated fields from the table: \"lookup.enum_colors\""
	lookup_enum_colors_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_colors_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_colors_order_by!]
		"filter the rows returned"
		where: lookup_enum_colors_bool_exp
	): lookup_enum_colors_aggregate!
	"fetch data from the table: \"lookup.enum_colors\" using primary key columns"
	lookup_enum_colors_by_pk(value: String!): lookup_enum_colors
	"fetch data from the table: \"lookup.enum_content_block_types\""
	lookup_enum_content_block_types(
		"distinct select on columns"
		distinct_on: [lookup_enum_content_block_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_content_block_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_content_block_types_bool_exp
	): [lookup_enum_content_block_types!]!
	"fetch aggregated fields from the table: \"lookup.enum_content_block_types\""
	lookup_enum_content_block_types_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_content_block_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_content_block_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_content_block_types_bool_exp
	): lookup_enum_content_block_types_aggregate!
	"fetch data from the table: \"lookup.enum_content_block_types\" using primary key columns"
	lookup_enum_content_block_types_by_pk(value: String!): lookup_enum_content_block_types
	"fetch data from the table: \"lookup.enum_content_types\""
	lookup_enum_content_types(
		"distinct select on columns"
		distinct_on: [lookup_enum_content_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_content_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_content_types_bool_exp
	): [lookup_enum_content_types!]!
	"fetch aggregated fields from the table: \"lookup.enum_content_types\""
	lookup_enum_content_types_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_content_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_content_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_content_types_bool_exp
	): lookup_enum_content_types_aggregate!
	"fetch data from the table: \"lookup.enum_content_types\" using primary key columns"
	lookup_enum_content_types_by_pk(value: String!): lookup_enum_content_types
	"fetch data from the table: \"lookup.enum_input_types\""
	lookup_enum_input_types(
		"distinct select on columns"
		distinct_on: [lookup_enum_input_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_input_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_input_types_bool_exp
	): [lookup_enum_input_types!]!
	"fetch aggregated fields from the table: \"lookup.enum_input_types\""
	lookup_enum_input_types_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_input_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_input_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_input_types_bool_exp
	): lookup_enum_input_types_aggregate!
	"fetch data from the table: \"lookup.enum_input_types\" using primary key columns"
	lookup_enum_input_types_by_pk(value: String!): lookup_enum_input_types
	"fetch data from the table: \"lookup.enum_lom_classification\""
	lookup_enum_lom_classification(
		"distinct select on columns"
		distinct_on: [lookup_enum_lom_classification_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_lom_classification_order_by!]
		"filter the rows returned"
		where: lookup_enum_lom_classification_bool_exp
	): [lookup_enum_lom_classification!]!
	"fetch aggregated fields from the table: \"lookup.enum_lom_classification\""
	lookup_enum_lom_classification_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_lom_classification_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_lom_classification_order_by!]
		"filter the rows returned"
		where: lookup_enum_lom_classification_bool_exp
	): lookup_enum_lom_classification_aggregate!
	"fetch data from the table: \"lookup.enum_lom_classification\" using primary key columns"
	lookup_enum_lom_classification_by_pk(value: String!): lookup_enum_lom_classification
	"fetch data from the table: \"lookup.enum_lom_context\""
	lookup_enum_lom_context(
		"distinct select on columns"
		distinct_on: [lookup_enum_lom_context_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_lom_context_order_by!]
		"filter the rows returned"
		where: lookup_enum_lom_context_bool_exp
	): [lookup_enum_lom_context!]!
	"fetch aggregated fields from the table: \"lookup.enum_lom_context\""
	lookup_enum_lom_context_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_lom_context_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_lom_context_order_by!]
		"filter the rows returned"
		where: lookup_enum_lom_context_bool_exp
	): lookup_enum_lom_context_aggregate!
	"fetch data from the table: \"lookup.enum_lom_context\" using primary key columns"
	lookup_enum_lom_context_by_pk(value: String!): lookup_enum_lom_context
	"fetch data from the table: \"lookup.enum_profile_flags\""
	lookup_enum_profile_flags(
		"distinct select on columns"
		distinct_on: [lookup_enum_profile_flags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_profile_flags_order_by!]
		"filter the rows returned"
		where: lookup_enum_profile_flags_bool_exp
	): [lookup_enum_profile_flags!]!
	"fetch aggregated fields from the table: \"lookup.enum_profile_flags\""
	lookup_enum_profile_flags_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_profile_flags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_profile_flags_order_by!]
		"filter the rows returned"
		where: lookup_enum_profile_flags_bool_exp
	): lookup_enum_profile_flags_aggregate!
	"fetch data from the table: \"lookup.enum_profile_flags\" using primary key columns"
	lookup_enum_profile_flags_by_pk(value: String!): lookup_enum_profile_flags
	"fetch data from the table: \"lookup.enum_profile_preferences_keys\""
	lookup_enum_profile_preferences_keys(
		"distinct select on columns"
		distinct_on: [lookup_enum_profile_preferences_keys_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_profile_preferences_keys_order_by!]
		"filter the rows returned"
		where: lookup_enum_profile_preferences_keys_bool_exp
	): [lookup_enum_profile_preferences_keys!]!
	"fetch aggregated fields from the table: \"lookup.enum_profile_preferences_keys\""
	lookup_enum_profile_preferences_keys_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_profile_preferences_keys_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_profile_preferences_keys_order_by!]
		"filter the rows returned"
		where: lookup_enum_profile_preferences_keys_bool_exp
	): lookup_enum_profile_preferences_keys_aggregate!
	"fetch data from the table: \"lookup.enum_profile_preferences_keys\" using primary key columns"
	lookup_enum_profile_preferences_keys_by_pk(value: String!): lookup_enum_profile_preferences_keys
	"fetch data from the table: \"lookup.enum_relation_types\""
	lookup_enum_relation_types(
		"distinct select on columns"
		distinct_on: [lookup_enum_relation_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_relation_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_relation_types_bool_exp
	): [lookup_enum_relation_types!]!
	"fetch aggregated fields from the table: \"lookup.enum_relation_types\""
	lookup_enum_relation_types_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_relation_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_relation_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_relation_types_bool_exp
	): lookup_enum_relation_types_aggregate!
	"fetch data from the table: \"lookup.enum_relation_types\" using primary key columns"
	lookup_enum_relation_types_by_pk(value: String!): lookup_enum_relation_types
	"fetch data from the table: \"lookup.enum_search_bookmark_types\""
	lookup_enum_search_bookmark_types(
		"distinct select on columns"
		distinct_on: [lookup_enum_search_bookmark_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_search_bookmark_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_search_bookmark_types_bool_exp
	): [lookup_enum_search_bookmark_types!]!
	"fetch aggregated fields from the table: \"lookup.enum_search_bookmark_types\""
	lookup_enum_search_bookmark_types_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_search_bookmark_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_search_bookmark_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_search_bookmark_types_bool_exp
	): lookup_enum_search_bookmark_types_aggregate!
	"fetch data from the table: \"lookup.enum_search_bookmark_types\" using primary key columns"
	lookup_enum_search_bookmark_types_by_pk(value: String!): lookup_enum_search_bookmark_types
	"fetch data from the table: \"lookup.thesaurus\""
	lookup_thesaurus(
		"distinct select on columns"
		distinct_on: [lookup_thesaurus_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_thesaurus_order_by!]
		"filter the rows returned"
		where: lookup_thesaurus_bool_exp
	): [lookup_thesaurus!]!
	"fetch aggregated fields from the table: \"lookup.thesaurus\""
	lookup_thesaurus_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_thesaurus_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_thesaurus_order_by!]
		"filter the rows returned"
		where: lookup_thesaurus_bool_exp
	): lookup_thesaurus_aggregate!
	"fetch data from the table: \"lookup.thesaurus\" using primary key columns"
	lookup_thesaurus_by_pk(id: String!): lookup_thesaurus
	"fetch data from the table: \"migrate.original_publishdate\""
	migrate_original_publishdate(
		"distinct select on columns"
		distinct_on: [migrate_original_publishdate_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [migrate_original_publishdate_order_by!]
		"filter the rows returned"
		where: migrate_original_publishdate_bool_exp
	): [migrate_original_publishdate!]!
	"fetch aggregated fields from the table: \"migrate.original_publishdate\""
	migrate_original_publishdate_aggregate(
		"distinct select on columns"
		distinct_on: [migrate_original_publishdate_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [migrate_original_publishdate_order_by!]
		"filter the rows returned"
		where: migrate_original_publishdate_bool_exp
	): migrate_original_publishdate_aggregate!
	"fetch data from the table: \"migrate.original_publishdate\" using primary key columns"
	migrate_original_publishdate_by_pk(mediamosa_id: String!): migrate_original_publishdate
	"fetch data from the table: \"migrate.reference_ids\""
	migrate_reference_ids(
		"distinct select on columns"
		distinct_on: [migrate_reference_ids_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [migrate_reference_ids_order_by!]
		"filter the rows returned"
		where: migrate_reference_ids_bool_exp
	): [migrate_reference_ids!]!
	"fetch aggregated fields from the table: \"migrate.reference_ids\""
	migrate_reference_ids_aggregate(
		"distinct select on columns"
		distinct_on: [migrate_reference_ids_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [migrate_reference_ids_order_by!]
		"filter the rows returned"
		where: migrate_reference_ids_bool_exp
	): migrate_reference_ids_aggregate!
	"fetch data from the table: \"migrate.reference_ids\" using primary key columns"
	migrate_reference_ids_by_pk(id: Int!): migrate_reference_ids
	"fetch data from the table: \"shared.collateral\""
	shared_collateral(
		"distinct select on columns"
		distinct_on: [shared_collateral_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_collateral_order_by!]
		"filter the rows returned"
		where: shared_collateral_bool_exp
	): [shared_collateral!]!
	"fetch aggregated fields from the table: \"shared.collateral\""
	shared_collateral_aggregate(
		"distinct select on columns"
		distinct_on: [shared_collateral_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_collateral_order_by!]
		"filter the rows returned"
		where: shared_collateral_bool_exp
	): shared_collateral_aggregate!
	"fetch data from the table: \"shared.collateral\" using primary key columns"
	shared_collateral_by_pk(id: Int!): shared_collateral
	"fetch data from the table: \"shared.items\""
	shared_items(
		"distinct select on columns"
		distinct_on: [shared_items_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_items_order_by!]
		"filter the rows returned"
		where: shared_items_bool_exp
	): [shared_items!]!
	"fetch aggregated fields from the table: \"shared.items\""
	shared_items_aggregate(
		"distinct select on columns"
		distinct_on: [shared_items_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_items_order_by!]
		"filter the rows returned"
		where: shared_items_bool_exp
	): shared_items_aggregate!
	"fetch data from the table: \"shared.items\" using primary key columns"
	shared_items_by_pk(id: Int!): shared_items
	"fetch data from the table: \"shared.ldap_organizations\""
	shared_ldap_organizations(
		"distinct select on columns"
		distinct_on: [shared_ldap_organizations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_ldap_organizations_order_by!]
		"filter the rows returned"
		where: shared_ldap_organizations_bool_exp
	): [shared_ldap_organizations!]!
	"fetch aggregated fields from the table: \"shared.ldap_organizations\""
	shared_ldap_organizations_aggregate(
		"distinct select on columns"
		distinct_on: [shared_ldap_organizations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_ldap_organizations_order_by!]
		"filter the rows returned"
		where: shared_ldap_organizations_bool_exp
	): shared_ldap_organizations_aggregate!
	"fetch data from the table: \"shared.ldap_organizations\" using primary key columns"
	shared_ldap_organizations_by_pk(id: Int!): shared_ldap_organizations
	"fetch data from the table: \"shared.organisations\""
	shared_organisations(
		"distinct select on columns"
		distinct_on: [shared_organisations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_organisations_order_by!]
		"filter the rows returned"
		where: shared_organisations_bool_exp
	): [shared_organisations!]!
	"fetch aggregated fields from the table: \"shared.organisations\""
	shared_organisations_aggregate(
		"distinct select on columns"
		distinct_on: [shared_organisations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_organisations_order_by!]
		"filter the rows returned"
		where: shared_organisations_bool_exp
	): shared_organisations_aggregate!
	"fetch data from the table: \"shared.organisations\" using primary key columns"
	shared_organisations_by_pk(or_id: String!): shared_organisations
	"fetch data from the table: \"shared.organisations_with_users\""
	shared_organisations_with_users(
		"distinct select on columns"
		distinct_on: [shared_organisations_with_users_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_organisations_with_users_order_by!]
		"filter the rows returned"
		where: shared_organisations_with_users_bool_exp
	): [shared_organisations_with_users!]!
	"fetch aggregated fields from the table: \"shared.organisations_with_users\""
	shared_organisations_with_users_aggregate(
		"distinct select on columns"
		distinct_on: [shared_organisations_with_users_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_organisations_with_users_order_by!]
		"filter the rows returned"
		where: shared_organisations_with_users_bool_exp
	): shared_organisations_with_users_aggregate!
	"fetch data from the table: \"shared.types\""
	shared_types(
		"distinct select on columns"
		distinct_on: [shared_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_types_order_by!]
		"filter the rows returned"
		where: shared_types_bool_exp
	): [shared_types!]!
	"fetch aggregated fields from the table: \"shared.types\""
	shared_types_aggregate(
		"distinct select on columns"
		distinct_on: [shared_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_types_order_by!]
		"filter the rows returned"
		where: shared_types_bool_exp
	): shared_types_aggregate!
	"fetch data from the table: \"shared.types\" using primary key columns"
	shared_types_by_pk(id: Int!): shared_types
	"fetch data from the table: \"shared.user_last_blocked\""
	shared_user_last_blocked(
		"distinct select on columns"
		distinct_on: [shared_user_last_blocked_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_last_blocked_order_by!]
		"filter the rows returned"
		where: shared_user_last_blocked_bool_exp
	): [shared_user_last_blocked!]!
	"fetch aggregated fields from the table: \"shared.user_last_blocked\""
	shared_user_last_blocked_aggregate(
		"distinct select on columns"
		distinct_on: [shared_user_last_blocked_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_last_blocked_order_by!]
		"filter the rows returned"
		where: shared_user_last_blocked_bool_exp
	): shared_user_last_blocked_aggregate!
	"fetch data from the table: \"shared.user_last_unblocked\""
	shared_user_last_unblocked(
		"distinct select on columns"
		distinct_on: [shared_user_last_unblocked_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_last_unblocked_order_by!]
		"filter the rows returned"
		where: shared_user_last_unblocked_bool_exp
	): [shared_user_last_unblocked!]!
	"fetch aggregated fields from the table: \"shared.user_last_unblocked\""
	shared_user_last_unblocked_aggregate(
		"distinct select on columns"
		distinct_on: [shared_user_last_unblocked_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_last_unblocked_order_by!]
		"filter the rows returned"
		where: shared_user_last_unblocked_bool_exp
	): shared_user_last_unblocked_aggregate!
	"fetch data from the table: \"shared.user_names\""
	shared_user_names(
		"distinct select on columns"
		distinct_on: [shared_user_names_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_names_order_by!]
		"filter the rows returned"
		where: shared_user_names_bool_exp
	): [shared_user_names!]!
	"fetch aggregated fields from the table: \"shared.user_names\""
	shared_user_names_aggregate(
		"distinct select on columns"
		distinct_on: [shared_user_names_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_names_order_by!]
		"filter the rows returned"
		where: shared_user_names_bool_exp
	): shared_user_names_aggregate!
	"fetch data from the table: \"shared.user_roles\""
	shared_user_roles(
		"distinct select on columns"
		distinct_on: [shared_user_roles_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_roles_order_by!]
		"filter the rows returned"
		where: shared_user_roles_bool_exp
	): [shared_user_roles!]!
	"fetch aggregated fields from the table: \"shared.user_roles\""
	shared_user_roles_aggregate(
		"distinct select on columns"
		distinct_on: [shared_user_roles_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_roles_order_by!]
		"filter the rows returned"
		where: shared_user_roles_bool_exp
	): shared_user_roles_aggregate!
	"fetch data from the table: \"shared.user_roles\" using primary key columns"
	shared_user_roles_by_pk(id: Int!): shared_user_roles
	"fetch data from the table: \"shared.user_temp_access\""
	shared_user_temp_access(
		"distinct select on columns"
		distinct_on: [shared_user_temp_access_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_temp_access_order_by!]
		"filter the rows returned"
		where: shared_user_temp_access_bool_exp
	): [shared_user_temp_access!]!
	"fetch aggregated fields from the table: \"shared.user_temp_access\""
	shared_user_temp_access_aggregate(
		"distinct select on columns"
		distinct_on: [shared_user_temp_access_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_temp_access_order_by!]
		"filter the rows returned"
		where: shared_user_temp_access_bool_exp
	): shared_user_temp_access_aggregate!
	"fetch data from the table: \"shared.user_temp_access\" using primary key columns"
	shared_user_temp_access_by_pk(user_id: uuid!): shared_user_temp_access
	"fetch data from the table: \"shared.user_temp_access_status\""
	shared_user_temp_access_status(
		"distinct select on columns"
		distinct_on: [shared_user_temp_access_status_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_temp_access_status_order_by!]
		"filter the rows returned"
		where: shared_user_temp_access_status_bool_exp
	): [shared_user_temp_access_status!]!
	"fetch aggregated fields from the table: \"shared.user_temp_access_status\""
	shared_user_temp_access_status_aggregate(
		"distinct select on columns"
		distinct_on: [shared_user_temp_access_status_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_temp_access_status_order_by!]
		"filter the rows returned"
		where: shared_user_temp_access_status_bool_exp
	): shared_user_temp_access_status_aggregate!
	"fetch data from the table: \"shared.users\""
	shared_users(
		"distinct select on columns"
		distinct_on: [shared_users_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_users_order_by!]
		"filter the rows returned"
		where: shared_users_bool_exp
	): [shared_users!]!
	"fetch aggregated fields from the table: \"shared.users\""
	shared_users_aggregate(
		"distinct select on columns"
		distinct_on: [shared_users_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_users_order_by!]
		"filter the rows returned"
		where: shared_users_bool_exp
	): shared_users_aggregate!
	"fetch data from the table: \"shared.users\" using primary key columns"
	shared_users_by_pk(uid: uuid!): shared_users
	"fetch data from the table: \"users.audit_log\""
	users_audit_log(
		"distinct select on columns"
		distinct_on: [users_audit_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_audit_log_order_by!]
		"filter the rows returned"
		where: users_audit_log_bool_exp
	): [users_audit_log!]!
	"fetch aggregated fields from the table: \"users.audit_log\""
	users_audit_log_aggregate(
		"distinct select on columns"
		distinct_on: [users_audit_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_audit_log_order_by!]
		"filter the rows returned"
		where: users_audit_log_bool_exp
	): users_audit_log_aggregate!
	"fetch data from the table: \"users.audit_log\" using primary key columns"
	users_audit_log_by_pk(id: Int!): users_audit_log
	"fetch data from the table: \"users.email_preferences\""
	users_email_preferences(
		"distinct select on columns"
		distinct_on: [users_email_preferences_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_email_preferences_order_by!]
		"filter the rows returned"
		where: users_email_preferences_bool_exp
	): [users_email_preferences!]!
	"fetch aggregated fields from the table: \"users.email_preferences\""
	users_email_preferences_aggregate(
		"distinct select on columns"
		distinct_on: [users_email_preferences_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_email_preferences_order_by!]
		"filter the rows returned"
		where: users_email_preferences_bool_exp
	): users_email_preferences_aggregate!
	"fetch data from the table: \"users.email_preferences\" using primary key columns"
	users_email_preferences_by_pk(id: uuid!): users_email_preferences
	"fetch data from the table: \"users.group_user_permission_groups\""
	users_group_user_permission_groups(
		"distinct select on columns"
		distinct_on: [users_group_user_permission_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_group_user_permission_groups_order_by!]
		"filter the rows returned"
		where: users_group_user_permission_groups_bool_exp
	): [users_group_user_permission_groups!]!
	"fetch aggregated fields from the table: \"users.group_user_permission_groups\""
	users_group_user_permission_groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_group_user_permission_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_group_user_permission_groups_order_by!]
		"filter the rows returned"
		where: users_group_user_permission_groups_bool_exp
	): users_group_user_permission_groups_aggregate!
	"fetch data from the table: \"users.group_user_permission_groups\" using primary key columns"
	users_group_user_permission_groups_by_pk(id: Int!): users_group_user_permission_groups
	"fetch data from the table: \"users.groups\""
	users_groups(
		"distinct select on columns"
		distinct_on: [users_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_groups_order_by!]
		"filter the rows returned"
		where: users_groups_bool_exp
	): [users_groups!]!
	"fetch aggregated fields from the table: \"users.groups\""
	users_groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_groups_order_by!]
		"filter the rows returned"
		where: users_groups_bool_exp
	): users_groups_aggregate!
	"fetch data from the table: \"users.groups\" using primary key columns"
	users_groups_by_pk(id: Int!): users_groups
	"fetch data from the table: \"users.idp_map\""
	users_idp_map(
		"distinct select on columns"
		distinct_on: [users_idp_map_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_idp_map_order_by!]
		"filter the rows returned"
		where: users_idp_map_bool_exp
	): [users_idp_map!]!
	"fetch aggregated fields from the table: \"users.idp_map\""
	users_idp_map_aggregate(
		"distinct select on columns"
		distinct_on: [users_idp_map_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_idp_map_order_by!]
		"filter the rows returned"
		where: users_idp_map_bool_exp
	): users_idp_map_aggregate!
	"fetch data from the table: \"users.idp_map\" using primary key columns"
	users_idp_map_by_pk(id: Int!): users_idp_map
	"fetch data from the table: \"users.idps\""
	users_idps(
		"distinct select on columns"
		distinct_on: [users_idps_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_idps_order_by!]
		"filter the rows returned"
		where: users_idps_bool_exp
	): [users_idps!]!
	"fetch aggregated fields from the table: \"users.idps\""
	users_idps_aggregate(
		"distinct select on columns"
		distinct_on: [users_idps_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_idps_order_by!]
		"filter the rows returned"
		where: users_idps_bool_exp
	): users_idps_aggregate!
	"fetch data from the table: \"users.idps\" using primary key columns"
	users_idps_by_pk(value: String!): users_idps
	"fetch data from the table: \"users.notifications\""
	users_notifications(
		"distinct select on columns"
		distinct_on: [users_notifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_notifications_order_by!]
		"filter the rows returned"
		where: users_notifications_bool_exp
	): [users_notifications!]!
	"fetch aggregated fields from the table: \"users.notifications\""
	users_notifications_aggregate(
		"distinct select on columns"
		distinct_on: [users_notifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_notifications_order_by!]
		"filter the rows returned"
		where: users_notifications_bool_exp
	): users_notifications_aggregate!
	"fetch data from the table: \"users.notifications\" using primary key columns"
	users_notifications_by_pk(id: uuid!): users_notifications
	"fetch data from the table: \"users.permission_group_user_permissions\""
	users_permission_group_user_permissions(
		"distinct select on columns"
		distinct_on: [users_permission_group_user_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_group_user_permissions_order_by!]
		"filter the rows returned"
		where: users_permission_group_user_permissions_bool_exp
	): [users_permission_group_user_permissions!]!
	"fetch aggregated fields from the table: \"users.permission_group_user_permissions\""
	users_permission_group_user_permissions_aggregate(
		"distinct select on columns"
		distinct_on: [users_permission_group_user_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_group_user_permissions_order_by!]
		"filter the rows returned"
		where: users_permission_group_user_permissions_bool_exp
	): users_permission_group_user_permissions_aggregate!
	"fetch data from the table: \"users.permission_group_user_permissions\" using primary key columns"
	users_permission_group_user_permissions_by_pk(id: Int!): users_permission_group_user_permissions
	"fetch data from the table: \"users.permission_groups\""
	users_permission_groups(
		"distinct select on columns"
		distinct_on: [users_permission_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_groups_order_by!]
		"filter the rows returned"
		where: users_permission_groups_bool_exp
	): [users_permission_groups!]!
	"fetch aggregated fields from the table: \"users.permission_groups\""
	users_permission_groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_permission_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_groups_order_by!]
		"filter the rows returned"
		where: users_permission_groups_bool_exp
	): users_permission_groups_aggregate!
	"fetch data from the table: \"users.permission_groups\" using primary key columns"
	users_permission_groups_by_pk(id: Int!): users_permission_groups
	"fetch data from the table: \"users.permission_matrix_view\""
	users_permission_matrix_view(
		"distinct select on columns"
		distinct_on: [users_permission_matrix_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_matrix_view_order_by!]
		"filter the rows returned"
		where: users_permission_matrix_view_bool_exp
	): [users_permission_matrix_view!]!
	"fetch aggregated fields from the table: \"users.permission_matrix_view\""
	users_permission_matrix_view_aggregate(
		"distinct select on columns"
		distinct_on: [users_permission_matrix_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_matrix_view_order_by!]
		"filter the rows returned"
		where: users_permission_matrix_view_bool_exp
	): users_permission_matrix_view_aggregate!
	"fetch data from the table: \"users.permissions\""
	users_permissions(
		"distinct select on columns"
		distinct_on: [users_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permissions_order_by!]
		"filter the rows returned"
		where: users_permissions_bool_exp
	): [users_permissions!]!
	"fetch aggregated fields from the table: \"users.permissions\""
	users_permissions_aggregate(
		"distinct select on columns"
		distinct_on: [users_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permissions_order_by!]
		"filter the rows returned"
		where: users_permissions_bool_exp
	): users_permissions_aggregate!
	"fetch data from the table: \"users.permissions\" using primary key columns"
	users_permissions_by_pk(id: Int!): users_permissions
	"fetch data from the table: \"users.profile_classifications\""
	users_profile_classifications(
		"distinct select on columns"
		distinct_on: [users_profile_classifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_classifications_order_by!]
		"filter the rows returned"
		where: users_profile_classifications_bool_exp
	): [users_profile_classifications!]!
	"fetch aggregated fields from the table: \"users.profile_classifications\""
	users_profile_classifications_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_classifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_classifications_order_by!]
		"filter the rows returned"
		where: users_profile_classifications_bool_exp
	): users_profile_classifications_aggregate!
	"fetch data from the table: \"users.profile_classifications\" using primary key columns"
	users_profile_classifications_by_pk(id: uuid!): users_profile_classifications
	"fetch data from the table: \"users.profile_contexts\""
	users_profile_contexts(
		"distinct select on columns"
		distinct_on: [users_profile_contexts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_contexts_order_by!]
		"filter the rows returned"
		where: users_profile_contexts_bool_exp
	): [users_profile_contexts!]!
	"fetch aggregated fields from the table: \"users.profile_contexts\""
	users_profile_contexts_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_contexts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_contexts_order_by!]
		"filter the rows returned"
		where: users_profile_contexts_bool_exp
	): users_profile_contexts_aggregate!
	"fetch data from the table: \"users.profile_contexts\" using primary key columns"
	users_profile_contexts_by_pk(id: uuid!): users_profile_contexts
	"fetch data from the table: \"users.profile_flags\""
	users_profile_flags(
		"distinct select on columns"
		distinct_on: [users_profile_flags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_flags_order_by!]
		"filter the rows returned"
		where: users_profile_flags_bool_exp
	): [users_profile_flags!]!
	"fetch aggregated fields from the table: \"users.profile_flags\""
	users_profile_flags_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_flags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_flags_order_by!]
		"filter the rows returned"
		where: users_profile_flags_bool_exp
	): users_profile_flags_aggregate!
	"fetch data from the table: \"users.profile_flags\" using primary key columns"
	users_profile_flags_by_pk(id: Int!): users_profile_flags
	"fetch data from the table: \"users.profile_organizations\""
	users_profile_organizations(
		"distinct select on columns"
		distinct_on: [users_profile_organizations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_organizations_order_by!]
		"filter the rows returned"
		where: users_profile_organizations_bool_exp
	): [users_profile_organizations!]!
	"fetch aggregated fields from the table: \"users.profile_organizations\""
	users_profile_organizations_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_organizations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_organizations_order_by!]
		"filter the rows returned"
		where: users_profile_organizations_bool_exp
	): users_profile_organizations_aggregate!
	"fetch data from the table: \"users.profile_organizations\" using primary key columns"
	users_profile_organizations_by_pk(id: uuid!): users_profile_organizations
	"fetch data from the table: \"users.profile_preferences\""
	users_profile_preferences(
		"distinct select on columns"
		distinct_on: [users_profile_preferences_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_preferences_order_by!]
		"filter the rows returned"
		where: users_profile_preferences_bool_exp
	): [users_profile_preferences!]!
	"fetch aggregated fields from the table: \"users.profile_preferences\""
	users_profile_preferences_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_preferences_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_preferences_order_by!]
		"filter the rows returned"
		where: users_profile_preferences_bool_exp
	): users_profile_preferences_aggregate!
	"fetch data from the table: \"users.profile_preferences\" using primary key columns"
	users_profile_preferences_by_pk(id: Int!): users_profile_preferences
	"fetch data from the table: \"users.profile_user_groups\""
	users_profile_user_groups(
		"distinct select on columns"
		distinct_on: [users_profile_user_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_user_groups_order_by!]
		"filter the rows returned"
		where: users_profile_user_groups_bool_exp
	): [users_profile_user_groups!]!
	"fetch aggregated fields from the table: \"users.profile_user_groups\""
	users_profile_user_groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_user_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_user_groups_order_by!]
		"filter the rows returned"
		where: users_profile_user_groups_bool_exp
	): users_profile_user_groups_aggregate!
	"fetch data from the table: \"users.profile_user_groups\" using primary key columns"
	users_profile_user_groups_by_pk(id: Int!): users_profile_user_groups
	"fetch data from the table: \"users.profiles\""
	users_profiles(
		"distinct select on columns"
		distinct_on: [users_profiles_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profiles_order_by!]
		"filter the rows returned"
		where: users_profiles_bool_exp
	): [users_profiles!]!
	"fetch aggregated fields from the table: \"users.profiles\""
	users_profiles_aggregate(
		"distinct select on columns"
		distinct_on: [users_profiles_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profiles_order_by!]
		"filter the rows returned"
		where: users_profiles_bool_exp
	): users_profiles_aggregate!
	"fetch data from the table: \"users.profiles\" using primary key columns"
	users_profiles_by_pk("Een gebruiker kan een of meer profielen hebben" id: uuid!): users_profiles
	"fetch data from the table: \"users.summary_view\""
	users_summary_view(
		"distinct select on columns"
		distinct_on: [users_summary_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_summary_view_order_by!]
		"filter the rows returned"
		where: users_summary_view_bool_exp
	): [users_summary_view!]!
	"fetch aggregated fields from the table: \"users.summary_view\""
	users_summary_view_aggregate(
		"distinct select on columns"
		distinct_on: [users_summary_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_summary_view_order_by!]
		"filter the rows returned"
		where: users_summary_view_bool_exp
	): users_summary_view_aggregate!
}

"columns and relationships of \"shared.collateral\""
type shared_collateral {
	created_at: timestamptz
	external_id: String!
	id: Int!
	json("JSON select path" path: String): jsonb
	pid: String!
	status: item_publishing_status
	title: String
	updated_at: timestamptz
}

"aggregated selection of \"shared.collateral\""
type shared_collateral_aggregate {
	aggregate: shared_collateral_aggregate_fields
	nodes: [shared_collateral!]!
}

"aggregate fields of \"shared.collateral\""
type shared_collateral_aggregate_fields {
	avg: shared_collateral_avg_fields
	count(columns: [shared_collateral_select_column!], distinct: Boolean): Int
	max: shared_collateral_max_fields
	min: shared_collateral_min_fields
	stddev: shared_collateral_stddev_fields
	stddev_pop: shared_collateral_stddev_pop_fields
	stddev_samp: shared_collateral_stddev_samp_fields
	sum: shared_collateral_sum_fields
	var_pop: shared_collateral_var_pop_fields
	var_samp: shared_collateral_var_samp_fields
	variance: shared_collateral_variance_fields
}

"aggregate avg on columns"
type shared_collateral_avg_fields {
	id: Float
}

"aggregate max on columns"
type shared_collateral_max_fields {
	created_at: timestamptz
	external_id: String
	id: Int
	pid: String
	title: String
	updated_at: timestamptz
}

"aggregate min on columns"
type shared_collateral_min_fields {
	created_at: timestamptz
	external_id: String
	id: Int
	pid: String
	title: String
	updated_at: timestamptz
}

"response of any mutation on the table \"shared.collateral\""
type shared_collateral_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [shared_collateral!]!
}

"aggregate stddev on columns"
type shared_collateral_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type shared_collateral_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type shared_collateral_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type shared_collateral_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type shared_collateral_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type shared_collateral_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type shared_collateral_variance_fields {
	id: Float
}

"columns and relationships of \"shared.items\""
type shared_items {
	created_at: timestamptz!
	external_id: String!
	id: Int!
	"An object relationship"
	item_meta: app_item_meta
	json("JSON select path" path: String): jsonb!
	pid: String!
	status: item_publishing_status
	title: String
	updated_at: timestamptz!
}

"aggregated selection of \"shared.items\""
type shared_items_aggregate {
	aggregate: shared_items_aggregate_fields
	nodes: [shared_items!]!
}

"aggregate fields of \"shared.items\""
type shared_items_aggregate_fields {
	avg: shared_items_avg_fields
	count(columns: [shared_items_select_column!], distinct: Boolean): Int
	max: shared_items_max_fields
	min: shared_items_min_fields
	stddev: shared_items_stddev_fields
	stddev_pop: shared_items_stddev_pop_fields
	stddev_samp: shared_items_stddev_samp_fields
	sum: shared_items_sum_fields
	var_pop: shared_items_var_pop_fields
	var_samp: shared_items_var_samp_fields
	variance: shared_items_variance_fields
}

"aggregate avg on columns"
type shared_items_avg_fields {
	id: Float
}

"aggregate max on columns"
type shared_items_max_fields {
	created_at: timestamptz
	external_id: String
	id: Int
	pid: String
	title: String
	updated_at: timestamptz
}

"aggregate min on columns"
type shared_items_min_fields {
	created_at: timestamptz
	external_id: String
	id: Int
	pid: String
	title: String
	updated_at: timestamptz
}

"response of any mutation on the table \"shared.items\""
type shared_items_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [shared_items!]!
}

"aggregate stddev on columns"
type shared_items_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type shared_items_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type shared_items_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type shared_items_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type shared_items_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type shared_items_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type shared_items_variance_fields {
	id: Float
}

"""
Table for organizations data from LDAP sync


columns and relationships of "shared.ldap_organizations"
"""
type shared_ldap_organizations {
	created_at: timestamptz!
	id: Int!
	ldap_content("JSON select path" path: String): jsonb!
	ldap_description: String
	ldap_entryuuid: uuid!
	ldap_modifytimestamp: timestamptz!
	organization_id: String!
	type: String
	updated_at: timestamptz!
}

"aggregated selection of \"shared.ldap_organizations\""
type shared_ldap_organizations_aggregate {
	aggregate: shared_ldap_organizations_aggregate_fields
	nodes: [shared_ldap_organizations!]!
}

"aggregate fields of \"shared.ldap_organizations\""
type shared_ldap_organizations_aggregate_fields {
	avg: shared_ldap_organizations_avg_fields
	count(columns: [shared_ldap_organizations_select_column!], distinct: Boolean): Int
	max: shared_ldap_organizations_max_fields
	min: shared_ldap_organizations_min_fields
	stddev: shared_ldap_organizations_stddev_fields
	stddev_pop: shared_ldap_organizations_stddev_pop_fields
	stddev_samp: shared_ldap_organizations_stddev_samp_fields
	sum: shared_ldap_organizations_sum_fields
	var_pop: shared_ldap_organizations_var_pop_fields
	var_samp: shared_ldap_organizations_var_samp_fields
	variance: shared_ldap_organizations_variance_fields
}

"aggregate avg on columns"
type shared_ldap_organizations_avg_fields {
	id: Float
}

"aggregate max on columns"
type shared_ldap_organizations_max_fields {
	created_at: timestamptz
	id: Int
	ldap_description: String
	ldap_entryuuid: uuid
	ldap_modifytimestamp: timestamptz
	organization_id: String
	type: String
	updated_at: timestamptz
}

"aggregate min on columns"
type shared_ldap_organizations_min_fields {
	created_at: timestamptz
	id: Int
	ldap_description: String
	ldap_entryuuid: uuid
	ldap_modifytimestamp: timestamptz
	organization_id: String
	type: String
	updated_at: timestamptz
}

"response of any mutation on the table \"shared.ldap_organizations\""
type shared_ldap_organizations_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [shared_ldap_organizations!]!
}

"aggregate stddev on columns"
type shared_ldap_organizations_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type shared_ldap_organizations_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type shared_ldap_organizations_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type shared_ldap_organizations_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type shared_ldap_organizations_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type shared_ldap_organizations_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type shared_ldap_organizations_variance_fields {
	id: Float
}

"""
Sync table for organisations API.


columns and relationships of "shared.organisations"
"""
type shared_organisations {
	data("JSON select path" path: String): jsonb!
	description: String
	logo_url: String
	name: String!
	or_id: String!
	website: String
}

"aggregated selection of \"shared.organisations\""
type shared_organisations_aggregate {
	aggregate: shared_organisations_aggregate_fields
	nodes: [shared_organisations!]!
}

"aggregate fields of \"shared.organisations\""
type shared_organisations_aggregate_fields {
	count(columns: [shared_organisations_select_column!], distinct: Boolean): Int
	max: shared_organisations_max_fields
	min: shared_organisations_min_fields
}

"aggregate max on columns"
type shared_organisations_max_fields {
	description: String
	logo_url: String
	name: String
	or_id: String
	website: String
}

"aggregate min on columns"
type shared_organisations_min_fields {
	description: String
	logo_url: String
	name: String
	or_id: String
	website: String
}

"response of any mutation on the table \"shared.organisations\""
type shared_organisations_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [shared_organisations!]!
}

"columns and relationships of \"shared.organisations_with_users\""
type shared_organisations_with_users {
	company_id: String
	name: String
}

"aggregated selection of \"shared.organisations_with_users\""
type shared_organisations_with_users_aggregate {
	aggregate: shared_organisations_with_users_aggregate_fields
	nodes: [shared_organisations_with_users!]!
}

"aggregate fields of \"shared.organisations_with_users\""
type shared_organisations_with_users_aggregate_fields {
	count(columns: [shared_organisations_with_users_select_column!], distinct: Boolean): Int
	max: shared_organisations_with_users_max_fields
	min: shared_organisations_with_users_min_fields
}

"aggregate max on columns"
type shared_organisations_with_users_max_fields {
	company_id: String
	name: String
}

"aggregate min on columns"
type shared_organisations_with_users_min_fields {
	company_id: String
	name: String
}

"columns and relationships of \"shared.types\""
type shared_types {
	id: Int!
	label: String!
}

"aggregated selection of \"shared.types\""
type shared_types_aggregate {
	aggregate: shared_types_aggregate_fields
	nodes: [shared_types!]!
}

"aggregate fields of \"shared.types\""
type shared_types_aggregate_fields {
	avg: shared_types_avg_fields
	count(columns: [shared_types_select_column!], distinct: Boolean): Int
	max: shared_types_max_fields
	min: shared_types_min_fields
	stddev: shared_types_stddev_fields
	stddev_pop: shared_types_stddev_pop_fields
	stddev_samp: shared_types_stddev_samp_fields
	sum: shared_types_sum_fields
	var_pop: shared_types_var_pop_fields
	var_samp: shared_types_var_samp_fields
	variance: shared_types_variance_fields
}

"aggregate avg on columns"
type shared_types_avg_fields {
	id: Float
}

"aggregate max on columns"
type shared_types_max_fields {
	id: Int
	label: String
}

"aggregate min on columns"
type shared_types_min_fields {
	id: Int
	label: String
}

"response of any mutation on the table \"shared.types\""
type shared_types_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [shared_types!]!
}

"aggregate stddev on columns"
type shared_types_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type shared_types_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type shared_types_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type shared_types_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type shared_types_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type shared_types_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type shared_types_variance_fields {
	id: Float
}

"columns and relationships of \"shared.user_last_blocked\""
type shared_user_last_blocked {
	event: String
	max: timestamptz
	user_id: uuid
}

"aggregated selection of \"shared.user_last_blocked\""
type shared_user_last_blocked_aggregate {
	aggregate: shared_user_last_blocked_aggregate_fields
	nodes: [shared_user_last_blocked!]!
}

"aggregate fields of \"shared.user_last_blocked\""
type shared_user_last_blocked_aggregate_fields {
	count(columns: [shared_user_last_blocked_select_column!], distinct: Boolean): Int
	max: shared_user_last_blocked_max_fields
	min: shared_user_last_blocked_min_fields
}

"aggregate max on columns"
type shared_user_last_blocked_max_fields {
	event: String
	max: timestamptz
	user_id: uuid
}

"aggregate min on columns"
type shared_user_last_blocked_min_fields {
	event: String
	max: timestamptz
	user_id: uuid
}

"columns and relationships of \"shared.user_last_unblocked\""
type shared_user_last_unblocked {
	event: String
	max: timestamptz
	user_id: uuid
}

"aggregated selection of \"shared.user_last_unblocked\""
type shared_user_last_unblocked_aggregate {
	aggregate: shared_user_last_unblocked_aggregate_fields
	nodes: [shared_user_last_unblocked!]!
}

"aggregate fields of \"shared.user_last_unblocked\""
type shared_user_last_unblocked_aggregate_fields {
	count(columns: [shared_user_last_unblocked_select_column!], distinct: Boolean): Int
	max: shared_user_last_unblocked_max_fields
	min: shared_user_last_unblocked_min_fields
}

"aggregate max on columns"
type shared_user_last_unblocked_max_fields {
	event: String
	max: timestamptz
	user_id: uuid
}

"aggregate min on columns"
type shared_user_last_unblocked_min_fields {
	event: String
	max: timestamptz
	user_id: uuid
}

"columns and relationships of \"shared.user_names\""
type shared_user_names {
	first_name: String
	full_name: String
	full_name_lower: String
	last_name: String
	mail: String
	profile_id: uuid
	user_id: uuid
}

"aggregated selection of \"shared.user_names\""
type shared_user_names_aggregate {
	aggregate: shared_user_names_aggregate_fields
	nodes: [shared_user_names!]!
}

"aggregate fields of \"shared.user_names\""
type shared_user_names_aggregate_fields {
	count(columns: [shared_user_names_select_column!], distinct: Boolean): Int
	max: shared_user_names_max_fields
	min: shared_user_names_min_fields
}

"aggregate max on columns"
type shared_user_names_max_fields {
	first_name: String
	full_name: String
	full_name_lower: String
	last_name: String
	mail: String
	profile_id: uuid
	user_id: uuid
}

"aggregate min on columns"
type shared_user_names_min_fields {
	first_name: String
	full_name: String
	full_name_lower: String
	last_name: String
	mail: String
	profile_id: uuid
	user_id: uuid
}

"columns and relationships of \"shared.user_roles\""
type shared_user_roles {
	id: Int!
	label: String!
	name: String!
	"An array relationship"
	users(
		"distinct select on columns"
		distinct_on: [shared_users_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_users_order_by!]
		"filter the rows returned"
		where: shared_users_bool_exp
	): [shared_users!]!
	"An aggregated array relationship"
	users_aggregate(
		"distinct select on columns"
		distinct_on: [shared_users_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_users_order_by!]
		"filter the rows returned"
		where: shared_users_bool_exp
	): shared_users_aggregate!
}

"aggregated selection of \"shared.user_roles\""
type shared_user_roles_aggregate {
	aggregate: shared_user_roles_aggregate_fields
	nodes: [shared_user_roles!]!
}

"aggregate fields of \"shared.user_roles\""
type shared_user_roles_aggregate_fields {
	avg: shared_user_roles_avg_fields
	count(columns: [shared_user_roles_select_column!], distinct: Boolean): Int
	max: shared_user_roles_max_fields
	min: shared_user_roles_min_fields
	stddev: shared_user_roles_stddev_fields
	stddev_pop: shared_user_roles_stddev_pop_fields
	stddev_samp: shared_user_roles_stddev_samp_fields
	sum: shared_user_roles_sum_fields
	var_pop: shared_user_roles_var_pop_fields
	var_samp: shared_user_roles_var_samp_fields
	variance: shared_user_roles_variance_fields
}

"aggregate avg on columns"
type shared_user_roles_avg_fields {
	id: Float
}

"aggregate max on columns"
type shared_user_roles_max_fields {
	id: Int
	label: String
	name: String
}

"aggregate min on columns"
type shared_user_roles_min_fields {
	id: Int
	label: String
	name: String
}

"response of any mutation on the table \"shared.user_roles\""
type shared_user_roles_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [shared_user_roles!]!
}

"aggregate stddev on columns"
type shared_user_roles_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type shared_user_roles_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type shared_user_roles_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type shared_user_roles_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type shared_user_roles_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type shared_user_roles_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type shared_user_roles_variance_fields {
	id: Float
}

"""
Tabel om de tijdelijke toegang van gebruikers te beheren.


columns and relationships of "shared.user_temp_access"
"""
type shared_user_temp_access {
	created_at: timestamptz!
	"An object relationship"
	current: shared_user_temp_access_status
	from: date
	until: date!
	updated_at: timestamptz!
	"An object relationship"
	user: shared_users!
	user_id: uuid!
}

"aggregated selection of \"shared.user_temp_access\""
type shared_user_temp_access_aggregate {
	aggregate: shared_user_temp_access_aggregate_fields
	nodes: [shared_user_temp_access!]!
}

"aggregate fields of \"shared.user_temp_access\""
type shared_user_temp_access_aggregate_fields {
	count(columns: [shared_user_temp_access_select_column!], distinct: Boolean): Int
	max: shared_user_temp_access_max_fields
	min: shared_user_temp_access_min_fields
}

"aggregate max on columns"
type shared_user_temp_access_max_fields {
	created_at: timestamptz
	from: date
	until: date
	updated_at: timestamptz
	user_id: uuid
}

"aggregate min on columns"
type shared_user_temp_access_min_fields {
	created_at: timestamptz
	from: date
	until: date
	updated_at: timestamptz
	user_id: uuid
}

"response of any mutation on the table \"shared.user_temp_access\""
type shared_user_temp_access_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [shared_user_temp_access!]!
}

"columns and relationships of \"shared.user_temp_access_status\""
type shared_user_temp_access_status {
	status: Int
	uid: uuid
}

"aggregated selection of \"shared.user_temp_access_status\""
type shared_user_temp_access_status_aggregate {
	aggregate: shared_user_temp_access_status_aggregate_fields
	nodes: [shared_user_temp_access_status!]!
}

"aggregate fields of \"shared.user_temp_access_status\""
type shared_user_temp_access_status_aggregate_fields {
	avg: shared_user_temp_access_status_avg_fields
	count(columns: [shared_user_temp_access_status_select_column!], distinct: Boolean): Int
	max: shared_user_temp_access_status_max_fields
	min: shared_user_temp_access_status_min_fields
	stddev: shared_user_temp_access_status_stddev_fields
	stddev_pop: shared_user_temp_access_status_stddev_pop_fields
	stddev_samp: shared_user_temp_access_status_stddev_samp_fields
	sum: shared_user_temp_access_status_sum_fields
	var_pop: shared_user_temp_access_status_var_pop_fields
	var_samp: shared_user_temp_access_status_var_samp_fields
	variance: shared_user_temp_access_status_variance_fields
}

"aggregate avg on columns"
type shared_user_temp_access_status_avg_fields {
	status: Float
}

"aggregate max on columns"
type shared_user_temp_access_status_max_fields {
	status: Int
	uid: uuid
}

"aggregate min on columns"
type shared_user_temp_access_status_min_fields {
	status: Int
	uid: uuid
}

"aggregate stddev on columns"
type shared_user_temp_access_status_stddev_fields {
	status: Float
}

"aggregate stddev_pop on columns"
type shared_user_temp_access_status_stddev_pop_fields {
	status: Float
}

"aggregate stddev_samp on columns"
type shared_user_temp_access_status_stddev_samp_fields {
	status: Float
}

"aggregate sum on columns"
type shared_user_temp_access_status_sum_fields {
	status: Int
}

"aggregate var_pop on columns"
type shared_user_temp_access_status_var_pop_fields {
	status: Float
}

"aggregate var_samp on columns"
type shared_user_temp_access_status_var_samp_fields {
	status: Float
}

"aggregate variance on columns"
type shared_user_temp_access_status_variance_fields {
	status: Float
}

"columns and relationships of \"shared.users\""
type shared_users {
	"An array relationship"
	audit(
		"distinct select on columns"
		distinct_on: [users_audit_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_audit_log_order_by!]
		"filter the rows returned"
		where: users_audit_log_bool_exp
	): [users_audit_log!]!
	"An aggregated array relationship"
	audit_aggregate(
		"distinct select on columns"
		distinct_on: [users_audit_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_audit_log_order_by!]
		"filter the rows returned"
		where: users_audit_log_bool_exp
	): users_audit_log_aggregate!
	created_at: timestamptz!
	expires_at: timestamptz
	external_uid: Int
	first_name: String
	"A computed field, executes function \"shared.user_full_name\""
	full_name: String
	id: Int!
	"An array relationship"
	idpmaps(
		"distinct select on columns"
		distinct_on: [users_idp_map_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_idp_map_order_by!]
		"filter the rows returned"
		where: users_idp_map_bool_exp
	): [users_idp_map!]!
	"An aggregated array relationship"
	idpmaps_aggregate(
		"distinct select on columns"
		distinct_on: [users_idp_map_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_idp_map_order_by!]
		"filter the rows returned"
		where: users_idp_map_bool_exp
	): users_idp_map_aggregate!
	is_blocked: Boolean
	last_access_at: timestamptz
	"An object relationship"
	last_block: shared_user_last_blocked
	last_name: String
	"An object relationship"
	last_unblock: shared_user_last_unblocked
	"as stored in ldap and used for login"
	mail: String
	"An object relationship"
	profile: users_profiles
	"An array relationship"
	profiles(
		"distinct select on columns"
		distinct_on: [users_profiles_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profiles_order_by!]
		"filter the rows returned"
		where: users_profiles_bool_exp
	): [users_profiles!]!
	"An aggregated array relationship"
	profiles_aggregate(
		"distinct select on columns"
		distinct_on: [users_profiles_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profiles_order_by!]
		"filter the rows returned"
		where: users_profiles_bool_exp
	): users_profiles_aggregate!
	"An object relationship"
	role: shared_user_roles
	role_id: Int
	"An object relationship"
	temp_access: shared_user_temp_access
	type_label: String
	uid: uuid!
	updated_at: timestamptz!
}

"aggregated selection of \"shared.users\""
type shared_users_aggregate {
	aggregate: shared_users_aggregate_fields
	nodes: [shared_users!]!
}

"aggregate fields of \"shared.users\""
type shared_users_aggregate_fields {
	avg: shared_users_avg_fields
	count(columns: [shared_users_select_column!], distinct: Boolean): Int
	max: shared_users_max_fields
	min: shared_users_min_fields
	stddev: shared_users_stddev_fields
	stddev_pop: shared_users_stddev_pop_fields
	stddev_samp: shared_users_stddev_samp_fields
	sum: shared_users_sum_fields
	var_pop: shared_users_var_pop_fields
	var_samp: shared_users_var_samp_fields
	variance: shared_users_variance_fields
}

"aggregate avg on columns"
type shared_users_avg_fields {
	external_uid: Float
	id: Float
	role_id: Float
}

"aggregate max on columns"
type shared_users_max_fields {
	created_at: timestamptz
	expires_at: timestamptz
	external_uid: Int
	first_name: String
	id: Int
	last_access_at: timestamptz
	last_name: String
	mail: String
	role_id: Int
	type_label: String
	uid: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type shared_users_min_fields {
	created_at: timestamptz
	expires_at: timestamptz
	external_uid: Int
	first_name: String
	id: Int
	last_access_at: timestamptz
	last_name: String
	mail: String
	role_id: Int
	type_label: String
	uid: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"shared.users\""
type shared_users_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [shared_users!]!
}

"aggregate stddev on columns"
type shared_users_stddev_fields {
	external_uid: Float
	id: Float
	role_id: Float
}

"aggregate stddev_pop on columns"
type shared_users_stddev_pop_fields {
	external_uid: Float
	id: Float
	role_id: Float
}

"aggregate stddev_samp on columns"
type shared_users_stddev_samp_fields {
	external_uid: Float
	id: Float
	role_id: Float
}

"aggregate sum on columns"
type shared_users_sum_fields {
	external_uid: Int
	id: Int
	role_id: Int
}

"aggregate var_pop on columns"
type shared_users_var_pop_fields {
	external_uid: Float
	id: Float
	role_id: Float
}

"aggregate var_samp on columns"
type shared_users_var_samp_fields {
	external_uid: Float
	id: Float
	role_id: Float
}

"aggregate variance on columns"
type shared_users_variance_fields {
	external_uid: Float
	id: Float
	role_id: Float
}

"subscription root"
type subscription_root {
	"fetch data from the table: \"app.assignment_assignment_tags\""
	app_assignment_assignment_tags(
		"distinct select on columns"
		distinct_on: [app_assignment_assignment_tags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_assignment_tags_order_by!]
		"filter the rows returned"
		where: app_assignment_assignment_tags_bool_exp
	): [app_assignment_assignment_tags!]!
	"fetch aggregated fields from the table: \"app.assignment_assignment_tags\""
	app_assignment_assignment_tags_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_assignment_tags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_assignment_tags_order_by!]
		"filter the rows returned"
		where: app_assignment_assignment_tags_bool_exp
	): app_assignment_assignment_tags_aggregate!
	"fetch data from the table: \"app.assignment_assignment_tags\" using primary key columns"
	app_assignment_assignment_tags_by_pk(id: Int!): app_assignment_assignment_tags
	"fetch data from the table: \"app.assignment_blocks_v2\""
	app_assignment_blocks_v2(
		"distinct select on columns"
		distinct_on: [app_assignment_blocks_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_blocks_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_blocks_v2_bool_exp
	): [app_assignment_blocks_v2!]!
	"fetch aggregated fields from the table: \"app.assignment_blocks_v2\""
	app_assignment_blocks_v2_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_blocks_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_blocks_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_blocks_v2_bool_exp
	): app_assignment_blocks_v2_aggregate!
	"fetch data from the table: \"app.assignment_blocks_v2\" using primary key columns"
	app_assignment_blocks_v2_by_pk(id: uuid!): app_assignment_blocks_v2
	"fetch data from the table: \"app.assignment_labels\""
	app_assignment_labels(
		"distinct select on columns"
		distinct_on: [app_assignment_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_labels_order_by!]
		"filter the rows returned"
		where: app_assignment_labels_bool_exp
	): [app_assignment_labels!]!
	"fetch aggregated fields from the table: \"app.assignment_labels\""
	app_assignment_labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_labels_order_by!]
		"filter the rows returned"
		where: app_assignment_labels_bool_exp
	): app_assignment_labels_aggregate!
	"fetch data from the table: \"app.assignment_labels\" using primary key columns"
	app_assignment_labels_by_pk(id: Int!): app_assignment_labels
	"fetch data from the table: \"app.assignment_labels_v2\""
	app_assignment_labels_v2(
		"distinct select on columns"
		distinct_on: [app_assignment_labels_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_labels_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_labels_v2_bool_exp
	): [app_assignment_labels_v2!]!
	"fetch aggregated fields from the table: \"app.assignment_labels_v2\""
	app_assignment_labels_v2_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_labels_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_labels_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_labels_v2_bool_exp
	): app_assignment_labels_v2_aggregate!
	"fetch data from the table: \"app.assignment_labels_v2\" using primary key columns"
	app_assignment_labels_v2_by_pk(id: uuid!): app_assignment_labels_v2
	"fetch data from the table: \"app.assignment_responses\""
	app_assignment_responses(
		"distinct select on columns"
		distinct_on: [app_assignment_responses_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_responses_order_by!]
		"filter the rows returned"
		where: app_assignment_responses_bool_exp
	): [app_assignment_responses!]!
	"fetch aggregated fields from the table: \"app.assignment_responses\""
	app_assignment_responses_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_responses_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_responses_order_by!]
		"filter the rows returned"
		where: app_assignment_responses_bool_exp
	): app_assignment_responses_aggregate!
	"fetch data from the table: \"app.assignment_responses\" using primary key columns"
	app_assignment_responses_by_pk(id: Int!): app_assignment_responses
	"fetch data from the table: \"app.assignment_responses_v2\""
	app_assignment_responses_v2(
		"distinct select on columns"
		distinct_on: [app_assignment_responses_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_responses_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_responses_v2_bool_exp
	): [app_assignment_responses_v2!]!
	"fetch aggregated fields from the table: \"app.assignment_responses_v2\""
	app_assignment_responses_v2_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_responses_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_responses_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_responses_v2_bool_exp
	): app_assignment_responses_v2_aggregate!
	"fetch data from the table: \"app.assignment_responses_v2\" using primary key columns"
	app_assignment_responses_v2_by_pk(id: uuid!): app_assignment_responses_v2
	"fetch data from the table: \"app.assignment_v2_views\""
	app_assignment_v2_views(
		"distinct select on columns"
		distinct_on: [app_assignment_v2_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_v2_views_order_by!]
		"filter the rows returned"
		where: app_assignment_v2_views_bool_exp
	): [app_assignment_v2_views!]!
	"fetch aggregated fields from the table: \"app.assignment_v2_views\""
	app_assignment_v2_views_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_v2_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_v2_views_order_by!]
		"filter the rows returned"
		where: app_assignment_v2_views_bool_exp
	): app_assignment_v2_views_aggregate!
	"fetch data from the table: \"app.assignment_v2_views\" using primary key columns"
	app_assignment_v2_views_by_pk(id: uuid!): app_assignment_v2_views
	"fetch data from the table: \"app.assignments\""
	app_assignments(
		"distinct select on columns"
		distinct_on: [app_assignments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_order_by!]
		"filter the rows returned"
		where: app_assignments_bool_exp
	): [app_assignments!]!
	"fetch aggregated fields from the table: \"app.assignments\""
	app_assignments_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_order_by!]
		"filter the rows returned"
		where: app_assignments_bool_exp
	): app_assignments_aggregate!
	"fetch data from the table: \"app.assignments\" using primary key columns"
	app_assignments_by_pk(uuid: uuid!): app_assignments
	"fetch data from the table: \"app.assignments_v2\""
	app_assignments_v2(
		"distinct select on columns"
		distinct_on: [app_assignments_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_v2_order_by!]
		"filter the rows returned"
		where: app_assignments_v2_bool_exp
	): [app_assignments_v2!]!
	"fetch aggregated fields from the table: \"app.assignments_v2\""
	app_assignments_v2_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignments_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_v2_order_by!]
		"filter the rows returned"
		where: app_assignments_v2_bool_exp
	): app_assignments_v2_aggregate!
	"fetch data from the table: \"app.assignments_v2_assignment_labels_v2\""
	app_assignments_v2_assignment_labels_v2(
		"distinct select on columns"
		distinct_on: [app_assignments_v2_assignment_labels_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_v2_assignment_labels_v2_order_by!]
		"filter the rows returned"
		where: app_assignments_v2_assignment_labels_v2_bool_exp
	): [app_assignments_v2_assignment_labels_v2!]!
	"fetch aggregated fields from the table: \"app.assignments_v2_assignment_labels_v2\""
	app_assignments_v2_assignment_labels_v2_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignments_v2_assignment_labels_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_v2_assignment_labels_v2_order_by!]
		"filter the rows returned"
		where: app_assignments_v2_assignment_labels_v2_bool_exp
	): app_assignments_v2_assignment_labels_v2_aggregate!
	"fetch data from the table: \"app.assignments_v2_assignment_labels_v2\" using primary key columns"
	app_assignments_v2_assignment_labels_v2_by_pk(id: Int!): app_assignments_v2_assignment_labels_v2
	"fetch data from the table: \"app.assignments_v2\" using primary key columns"
	app_assignments_v2_by_pk(id: uuid!): app_assignments_v2
	"fetch data from the table: \"app.collection_actualisation_overview\""
	app_collection_actualisation_overview(
		"distinct select on columns"
		distinct_on: [app_collection_actualisation_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_actualisation_overview_order_by!]
		"filter the rows returned"
		where: app_collection_actualisation_overview_bool_exp
	): [app_collection_actualisation_overview!]!
	"fetch aggregated fields from the table: \"app.collection_actualisation_overview\""
	app_collection_actualisation_overview_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_actualisation_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_actualisation_overview_order_by!]
		"filter the rows returned"
		where: app_collection_actualisation_overview_bool_exp
	): app_collection_actualisation_overview_aggregate!
	"fetch data from the table: \"app.collection_bookmarks\""
	app_collection_bookmarks(
		"distinct select on columns"
		distinct_on: [app_collection_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_bookmarks_order_by!]
		"filter the rows returned"
		where: app_collection_bookmarks_bool_exp
	): [app_collection_bookmarks!]!
	"fetch aggregated fields from the table: \"app.collection_bookmarks\""
	app_collection_bookmarks_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_bookmarks_order_by!]
		"filter the rows returned"
		where: app_collection_bookmarks_bool_exp
	): app_collection_bookmarks_aggregate!
	"fetch data from the table: \"app.collection_bookmarks\" using primary key columns"
	app_collection_bookmarks_by_pk(id: Int!): app_collection_bookmarks
	"fetch data from the table: \"app.collection_counts\""
	app_collection_counts(
		"distinct select on columns"
		distinct_on: [app_collection_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_counts_order_by!]
		"filter the rows returned"
		where: app_collection_counts_bool_exp
	): [app_collection_counts!]!
	"fetch aggregated fields from the table: \"app.collection_counts\""
	app_collection_counts_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_counts_order_by!]
		"filter the rows returned"
		where: app_collection_counts_bool_exp
	): app_collection_counts_aggregate!
	"fetch data from the table: \"app.collection_fragments\""
	app_collection_fragments(
		"distinct select on columns"
		distinct_on: [app_collection_fragments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_fragments_order_by!]
		"filter the rows returned"
		where: app_collection_fragments_bool_exp
	): [app_collection_fragments!]!
	"fetch aggregated fields from the table: \"app.collection_fragments\""
	app_collection_fragments_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_fragments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_fragments_order_by!]
		"filter the rows returned"
		where: app_collection_fragments_bool_exp
	): app_collection_fragments_aggregate!
	"fetch data from the table: \"app.collection_fragments\" using primary key columns"
	app_collection_fragments_by_pk(id: Int!): app_collection_fragments
	"fetch data from the table: \"app.collection_labels\""
	app_collection_labels(
		"distinct select on columns"
		distinct_on: [app_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_labels_order_by!]
		"filter the rows returned"
		where: app_collection_labels_bool_exp
	): [app_collection_labels!]!
	"fetch aggregated fields from the table: \"app.collection_labels\""
	app_collection_labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_labels_order_by!]
		"filter the rows returned"
		where: app_collection_labels_bool_exp
	): app_collection_labels_aggregate!
	"fetch data from the table: \"app.collection_labels\" using primary key columns"
	app_collection_labels_by_pk(id: Int!): app_collection_labels
	"fetch data from the table: \"app.collection_management\""
	app_collection_management(
		"distinct select on columns"
		distinct_on: [app_collection_management_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_management_order_by!]
		"filter the rows returned"
		where: app_collection_management_bool_exp
	): [app_collection_management!]!
	"fetch data from the table: \"app.collection_management_QC\""
	app_collection_management_QC(
		"distinct select on columns"
		distinct_on: [app_collection_management_QC_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_management_QC_order_by!]
		"filter the rows returned"
		where: app_collection_management_QC_bool_exp
	): [app_collection_management_QC!]!
	"fetch aggregated fields from the table: \"app.collection_management_QC\""
	app_collection_management_QC_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_management_QC_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_management_QC_order_by!]
		"filter the rows returned"
		where: app_collection_management_QC_bool_exp
	): app_collection_management_QC_aggregate!
	"fetch data from the table: \"app.collection_management_QC\" using primary key columns"
	app_collection_management_QC_by_pk(id: Int!): app_collection_management_QC
	"fetch aggregated fields from the table: \"app.collection_management\""
	app_collection_management_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_management_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_management_order_by!]
		"filter the rows returned"
		where: app_collection_management_bool_exp
	): app_collection_management_aggregate!
	"fetch data from the table: \"app.collection_management\" using primary key columns"
	app_collection_management_by_pk(id: Int!): app_collection_management
	"fetch data from the table: \"app.collection_marcom_klascement_view\""
	app_collection_marcom_klascement_view(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_klascement_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_klascement_view_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_klascement_view_bool_exp
	): [app_collection_marcom_klascement_view!]!
	"fetch aggregated fields from the table: \"app.collection_marcom_klascement_view\""
	app_collection_marcom_klascement_view_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_klascement_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_klascement_view_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_klascement_view_bool_exp
	): app_collection_marcom_klascement_view_aggregate!
	"fetch data from the table: \"app.collection_marcom_log\""
	app_collection_marcom_log(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_log_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_log_bool_exp
	): [app_collection_marcom_log!]!
	"fetch aggregated fields from the table: \"app.collection_marcom_log\""
	app_collection_marcom_log_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_log_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_log_bool_exp
	): app_collection_marcom_log_aggregate!
	"fetch data from the table: \"app.collection_marcom_log\" using primary key columns"
	app_collection_marcom_log_by_pk(id: Int!): app_collection_marcom_log
	"fetch data from the table: \"app.collection_marcom_notes\""
	app_collection_marcom_notes(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_notes_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_notes_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_notes_bool_exp
	): [app_collection_marcom_notes!]!
	"fetch aggregated fields from the table: \"app.collection_marcom_notes\""
	app_collection_marcom_notes_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_notes_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_notes_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_notes_bool_exp
	): app_collection_marcom_notes_aggregate!
	"fetch data from the table: \"app.collection_marcom_notes\" using primary key columns"
	app_collection_marcom_notes_by_pk(collection_id: uuid!): app_collection_marcom_notes
	"fetch data from the table: \"app.collection_marcom_overview\""
	app_collection_marcom_overview(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_overview_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_overview_bool_exp
	): [app_collection_marcom_overview!]!
	"fetch aggregated fields from the table: \"app.collection_marcom_overview\""
	app_collection_marcom_overview_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_marcom_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_marcom_overview_order_by!]
		"filter the rows returned"
		where: app_collection_marcom_overview_bool_exp
	): app_collection_marcom_overview_aggregate!
	"fetch data from the table: \"app.collection_plays\""
	app_collection_plays(
		"distinct select on columns"
		distinct_on: [app_collection_plays_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_plays_order_by!]
		"filter the rows returned"
		where: app_collection_plays_bool_exp
	): [app_collection_plays!]!
	"fetch aggregated fields from the table: \"app.collection_plays\""
	app_collection_plays_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_plays_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_plays_order_by!]
		"filter the rows returned"
		where: app_collection_plays_bool_exp
	): app_collection_plays_aggregate!
	"fetch data from the table: \"app.collection_plays\" using primary key columns"
	app_collection_plays_by_pk(id: Int!): app_collection_plays
	"fetch data from the table: \"app.collection_qc_overview\""
	app_collection_qc_overview(
		"distinct select on columns"
		distinct_on: [app_collection_qc_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_qc_overview_order_by!]
		"filter the rows returned"
		where: app_collection_qc_overview_bool_exp
	): [app_collection_qc_overview!]!
	"fetch aggregated fields from the table: \"app.collection_qc_overview\""
	app_collection_qc_overview_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_qc_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_qc_overview_order_by!]
		"filter the rows returned"
		where: app_collection_qc_overview_bool_exp
	): app_collection_qc_overview_aggregate!
	"fetch data from the table: \"app.collection_relations\""
	app_collection_relations(
		"distinct select on columns"
		distinct_on: [app_collection_relations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_relations_order_by!]
		"filter the rows returned"
		where: app_collection_relations_bool_exp
	): [app_collection_relations!]!
	"fetch aggregated fields from the table: \"app.collection_relations\""
	app_collection_relations_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_relations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_relations_order_by!]
		"filter the rows returned"
		where: app_collection_relations_bool_exp
	): app_collection_relations_aggregate!
	"fetch data from the table: \"app.collection_relations\" using primary key columns"
	app_collection_relations_by_pk(id: Int!): app_collection_relations
	"fetch data from the table: \"app.collection_relations_view\""
	app_collection_relations_view(
		"distinct select on columns"
		distinct_on: [app_collection_relations_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_relations_view_order_by!]
		"filter the rows returned"
		where: app_collection_relations_view_bool_exp
	): [app_collection_relations_view!]!
	"fetch aggregated fields from the table: \"app.collection_relations_view\""
	app_collection_relations_view_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_relations_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_relations_view_order_by!]
		"filter the rows returned"
		where: app_collection_relations_view_bool_exp
	): app_collection_relations_view_aggregate!
	"fetch data from the table: \"app.collection_views\""
	app_collection_views(
		"distinct select on columns"
		distinct_on: [app_collection_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_views_order_by!]
		"filter the rows returned"
		where: app_collection_views_bool_exp
	): [app_collection_views!]!
	"fetch aggregated fields from the table: \"app.collection_views\""
	app_collection_views_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_views_order_by!]
		"filter the rows returned"
		where: app_collection_views_bool_exp
	): app_collection_views_aggregate!
	"fetch data from the table: \"app.collection_views\" using primary key columns"
	app_collection_views_by_pk(id: Int!): app_collection_views
	"fetch data from the table: \"app.collections\""
	app_collections(
		"distinct select on columns"
		distinct_on: [app_collections_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collections_order_by!]
		"filter the rows returned"
		where: app_collections_bool_exp
	): [app_collections!]!
	"fetch aggregated fields from the table: \"app.collections\""
	app_collections_aggregate(
		"distinct select on columns"
		distinct_on: [app_collections_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collections_order_by!]
		"filter the rows returned"
		where: app_collections_bool_exp
	): app_collections_aggregate!
	"fetch data from the table: \"app.collections\" using primary key columns"
	app_collections_by_pk(id: uuid!): app_collections
	"fetch data from the table: \"app.content\""
	app_content(
		"distinct select on columns"
		distinct_on: [app_content_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_order_by!]
		"filter the rows returned"
		where: app_content_bool_exp
	): [app_content!]!
	"fetch aggregated fields from the table: \"app.content\""
	app_content_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_order_by!]
		"filter the rows returned"
		where: app_content_bool_exp
	): app_content_aggregate!
	"fetch data from the table: \"app.content_assets\""
	app_content_assets(
		"distinct select on columns"
		distinct_on: [app_content_assets_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_assets_order_by!]
		"filter the rows returned"
		where: app_content_assets_bool_exp
	): [app_content_assets!]!
	"fetch aggregated fields from the table: \"app.content_assets\""
	app_content_assets_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_assets_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_assets_order_by!]
		"filter the rows returned"
		where: app_content_assets_bool_exp
	): app_content_assets_aggregate!
	"fetch data from the table: \"app.content_assets\" using primary key columns"
	app_content_assets_by_pk(id: Int!): app_content_assets
	"fetch data from the table: \"app.content_blocks\""
	app_content_blocks(
		"distinct select on columns"
		distinct_on: [app_content_blocks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_blocks_order_by!]
		"filter the rows returned"
		where: app_content_blocks_bool_exp
	): [app_content_blocks!]!
	"fetch aggregated fields from the table: \"app.content_blocks\""
	app_content_blocks_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_blocks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_blocks_order_by!]
		"filter the rows returned"
		where: app_content_blocks_bool_exp
	): app_content_blocks_aggregate!
	"fetch data from the table: \"app.content_blocks\" using primary key columns"
	app_content_blocks_by_pk(id: Int!): app_content_blocks
	"fetch data from the table: \"app.content\" using primary key columns"
	app_content_by_pk(id: Int!): app_content
	"fetch data from the table: \"app.content_content_labels\""
	app_content_content_labels(
		"distinct select on columns"
		distinct_on: [app_content_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_content_labels_order_by!]
		"filter the rows returned"
		where: app_content_content_labels_bool_exp
	): [app_content_content_labels!]!
	"fetch aggregated fields from the table: \"app.content_content_labels\""
	app_content_content_labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_content_labels_order_by!]
		"filter the rows returned"
		where: app_content_content_labels_bool_exp
	): app_content_content_labels_aggregate!
	"fetch data from the table: \"app.content_content_labels\" using primary key columns"
	app_content_content_labels_by_pk(id: Int!): app_content_content_labels
	"fetch data from the table: \"app.content_labels\""
	app_content_labels(
		"distinct select on columns"
		distinct_on: [app_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_labels_order_by!]
		"filter the rows returned"
		where: app_content_labels_bool_exp
	): [app_content_labels!]!
	"fetch aggregated fields from the table: \"app.content_labels\""
	app_content_labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_labels_order_by!]
		"filter the rows returned"
		where: app_content_labels_bool_exp
	): app_content_labels_aggregate!
	"fetch data from the table: \"app.content_labels\" using primary key columns"
	app_content_labels_by_pk(id: Int!): app_content_labels
	"fetch data from the table: \"app.content_lower_title\""
	app_content_lower_title(
		"distinct select on columns"
		distinct_on: [app_content_lower_title_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_lower_title_order_by!]
		"filter the rows returned"
		where: app_content_lower_title_bool_exp
	): [app_content_lower_title!]!
	"fetch aggregated fields from the table: \"app.content_lower_title\""
	app_content_lower_title_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_lower_title_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_lower_title_order_by!]
		"filter the rows returned"
		where: app_content_lower_title_bool_exp
	): app_content_lower_title_aggregate!
	"fetch data from the table: \"app.content_nav_elements\""
	app_content_nav_elements(
		"distinct select on columns"
		distinct_on: [app_content_nav_elements_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_nav_elements_order_by!]
		"filter the rows returned"
		where: app_content_nav_elements_bool_exp
	): [app_content_nav_elements!]!
	"fetch aggregated fields from the table: \"app.content_nav_elements\""
	app_content_nav_elements_aggregate(
		"distinct select on columns"
		distinct_on: [app_content_nav_elements_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_content_nav_elements_order_by!]
		"filter the rows returned"
		where: app_content_nav_elements_bool_exp
	): app_content_nav_elements_aggregate!
	"fetch data from the table: \"app.content_nav_elements\" using primary key columns"
	app_content_nav_elements_by_pk(id: Int!): app_content_nav_elements
	"fetch data from the table: \"app.interactive_tour\""
	app_interactive_tour(
		"distinct select on columns"
		distinct_on: [app_interactive_tour_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_interactive_tour_order_by!]
		"filter the rows returned"
		where: app_interactive_tour_bool_exp
	): [app_interactive_tour!]!
	"fetch aggregated fields from the table: \"app.interactive_tour\""
	app_interactive_tour_aggregate(
		"distinct select on columns"
		distinct_on: [app_interactive_tour_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_interactive_tour_order_by!]
		"filter the rows returned"
		where: app_interactive_tour_bool_exp
	): app_interactive_tour_aggregate!
	"fetch data from the table: \"app.interactive_tour\" using primary key columns"
	app_interactive_tour_by_pk(id: Int!): app_interactive_tour
	"fetch data from the table: \"app.item_bookmarks\""
	app_item_bookmarks(
		"distinct select on columns"
		distinct_on: [app_item_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_bookmarks_order_by!]
		"filter the rows returned"
		where: app_item_bookmarks_bool_exp
	): [app_item_bookmarks!]!
	"fetch aggregated fields from the table: \"app.item_bookmarks\""
	app_item_bookmarks_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_bookmarks_order_by!]
		"filter the rows returned"
		where: app_item_bookmarks_bool_exp
	): app_item_bookmarks_aggregate!
	"fetch data from the table: \"app.item_bookmarks\" using primary key columns"
	app_item_bookmarks_by_pk(id: Int!): app_item_bookmarks
	"fetch data from the table: \"app.item_collateral\""
	app_item_collateral(
		"distinct select on columns"
		distinct_on: [app_item_collateral_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_collateral_order_by!]
		"filter the rows returned"
		where: app_item_collateral_bool_exp
	): [app_item_collateral!]!
	"fetch aggregated fields from the table: \"app.item_collateral\""
	app_item_collateral_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_collateral_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_collateral_order_by!]
		"filter the rows returned"
		where: app_item_collateral_bool_exp
	): app_item_collateral_aggregate!
	"fetch data from the table: \"app.item_collateral\" using primary key columns"
	app_item_collateral_by_pk(external_id: String!): app_item_collateral
	"fetch data from the table: \"app.item_counts\""
	app_item_counts(
		"distinct select on columns"
		distinct_on: [app_item_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_counts_order_by!]
		"filter the rows returned"
		where: app_item_counts_bool_exp
	): [app_item_counts!]!
	"fetch aggregated fields from the table: \"app.item_counts\""
	app_item_counts_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_counts_order_by!]
		"filter the rows returned"
		where: app_item_counts_bool_exp
	): app_item_counts_aggregate!
	"fetch data from the table: \"app.item_meta\""
	app_item_meta(
		"distinct select on columns"
		distinct_on: [app_item_meta_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_meta_order_by!]
		"filter the rows returned"
		where: app_item_meta_bool_exp
	): [app_item_meta!]!
	"fetch aggregated fields from the table: \"app.item_meta\""
	app_item_meta_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_meta_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_meta_order_by!]
		"filter the rows returned"
		where: app_item_meta_bool_exp
	): app_item_meta_aggregate!
	"fetch data from the table: \"app.item_meta\" using primary key columns"
	app_item_meta_by_pk(id: Int!): app_item_meta
	"fetch data from the table: \"app.item_plays\""
	app_item_plays(
		"distinct select on columns"
		distinct_on: [app_item_plays_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_plays_order_by!]
		"filter the rows returned"
		where: app_item_plays_bool_exp
	): [app_item_plays!]!
	"fetch aggregated fields from the table: \"app.item_plays\""
	app_item_plays_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_plays_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_plays_order_by!]
		"filter the rows returned"
		where: app_item_plays_bool_exp
	): app_item_plays_aggregate!
	"fetch data from the table: \"app.item_plays\" using primary key columns"
	app_item_plays_by_pk(id: Int!): app_item_plays
	"fetch data from the table: \"app.item_relations\""
	app_item_relations(
		"distinct select on columns"
		distinct_on: [app_item_relations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_relations_order_by!]
		"filter the rows returned"
		where: app_item_relations_bool_exp
	): [app_item_relations!]!
	"fetch aggregated fields from the table: \"app.item_relations\""
	app_item_relations_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_relations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_relations_order_by!]
		"filter the rows returned"
		where: app_item_relations_bool_exp
	): app_item_relations_aggregate!
	"fetch data from the table: \"app.item_relations\" using primary key columns"
	app_item_relations_by_pk(id: Int!): app_item_relations
	"fetch data from the table: \"app.item_relations_view\""
	app_item_relations_view(
		"distinct select on columns"
		distinct_on: [app_item_relations_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_relations_view_order_by!]
		"filter the rows returned"
		where: app_item_relations_view_bool_exp
	): [app_item_relations_view!]!
	"fetch aggregated fields from the table: \"app.item_relations_view\""
	app_item_relations_view_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_relations_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_relations_view_order_by!]
		"filter the rows returned"
		where: app_item_relations_view_bool_exp
	): app_item_relations_view_aggregate!
	"fetch data from the table: \"app.item_score\""
	app_item_score(
		"distinct select on columns"
		distinct_on: [app_item_score_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_score_order_by!]
		"filter the rows returned"
		where: app_item_score_bool_exp
	): [app_item_score!]!
	"fetch aggregated fields from the table: \"app.item_score\""
	app_item_score_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_score_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_score_order_by!]
		"filter the rows returned"
		where: app_item_score_bool_exp
	): app_item_score_aggregate!
	"fetch data from the table: \"app.item_score\" using primary key columns"
	app_item_score_by_pk(id: Int!): app_item_score
	"fetch data from the table: \"app.item_views\""
	app_item_views(
		"distinct select on columns"
		distinct_on: [app_item_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_views_order_by!]
		"filter the rows returned"
		where: app_item_views_bool_exp
	): [app_item_views!]!
	"fetch aggregated fields from the table: \"app.item_views\""
	app_item_views_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_views_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_views_order_by!]
		"filter the rows returned"
		where: app_item_views_bool_exp
	): app_item_views_aggregate!
	"fetch data from the table: \"app.item_views\" using primary key columns"
	app_item_views_by_pk(id: Int!): app_item_views
	"fetch data from the table: \"app.pupil_collection_blocks\""
	app_pupil_collection_blocks(
		"distinct select on columns"
		distinct_on: [app_pupil_collection_blocks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_pupil_collection_blocks_order_by!]
		"filter the rows returned"
		where: app_pupil_collection_blocks_bool_exp
	): [app_pupil_collection_blocks!]!
	"fetch aggregated fields from the table: \"app.pupil_collection_blocks\""
	app_pupil_collection_blocks_aggregate(
		"distinct select on columns"
		distinct_on: [app_pupil_collection_blocks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_pupil_collection_blocks_order_by!]
		"filter the rows returned"
		where: app_pupil_collection_blocks_bool_exp
	): app_pupil_collection_blocks_aggregate!
	"fetch data from the table: \"app.pupil_collection_blocks\" using primary key columns"
	app_pupil_collection_blocks_by_pk(id: uuid!): app_pupil_collection_blocks
	"fetch data from the table: \"app.quick_lanes\""
	app_quick_lanes(
		"distinct select on columns"
		distinct_on: [app_quick_lanes_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_quick_lanes_order_by!]
		"filter the rows returned"
		where: app_quick_lanes_bool_exp
	): [app_quick_lanes!]!
	"fetch aggregated fields from the table: \"app.quick_lanes\""
	app_quick_lanes_aggregate(
		"distinct select on columns"
		distinct_on: [app_quick_lanes_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_quick_lanes_order_by!]
		"filter the rows returned"
		where: app_quick_lanes_bool_exp
	): app_quick_lanes_aggregate!
	"fetch data from the table: \"app.quick_lanes\" using primary key columns"
	app_quick_lanes_by_pk(id: uuid!): app_quick_lanes
	"fetch data from the table: \"app.quick_lanes_overview\""
	app_quick_lanes_overview(
		"distinct select on columns"
		distinct_on: [app_quick_lanes_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_quick_lanes_overview_order_by!]
		"filter the rows returned"
		where: app_quick_lanes_overview_bool_exp
	): [app_quick_lanes_overview!]!
	"fetch aggregated fields from the table: \"app.quick_lanes_overview\""
	app_quick_lanes_overview_aggregate(
		"distinct select on columns"
		distinct_on: [app_quick_lanes_overview_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_quick_lanes_overview_order_by!]
		"filter the rows returned"
		where: app_quick_lanes_overview_bool_exp
	): app_quick_lanes_overview_aggregate!
	"fetch data from the table: \"app.search_bookmarks\""
	app_search_bookmarks(
		"distinct select on columns"
		distinct_on: [app_search_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_search_bookmarks_order_by!]
		"filter the rows returned"
		where: app_search_bookmarks_bool_exp
	): [app_search_bookmarks!]!
	"fetch aggregated fields from the table: \"app.search_bookmarks\""
	app_search_bookmarks_aggregate(
		"distinct select on columns"
		distinct_on: [app_search_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_search_bookmarks_order_by!]
		"filter the rows returned"
		where: app_search_bookmarks_bool_exp
	): app_search_bookmarks_aggregate!
	"fetch data from the table: \"app.search_bookmarks\" using primary key columns"
	app_search_bookmarks_by_pk(id: uuid!): app_search_bookmarks
	"fetch data from the table: \"app.site_variables\""
	app_site_variables(
		"distinct select on columns"
		distinct_on: [app_site_variables_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_site_variables_order_by!]
		"filter the rows returned"
		where: app_site_variables_bool_exp
	): [app_site_variables!]!
	"fetch aggregated fields from the table: \"app.site_variables\""
	app_site_variables_aggregate(
		"distinct select on columns"
		distinct_on: [app_site_variables_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_site_variables_order_by!]
		"filter the rows returned"
		where: app_site_variables_bool_exp
	): app_site_variables_aggregate!
	"fetch data from the table: \"app.site_variables\" using primary key columns"
	app_site_variables_by_pk(name: String!): app_site_variables
	"fetch data from the table: \"app.usage_counts\""
	app_usage_counts(
		"distinct select on columns"
		distinct_on: [app_usage_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_usage_counts_order_by!]
		"filter the rows returned"
		where: app_usage_counts_bool_exp
	): [app_usage_counts!]!
	"fetch aggregated fields from the table: \"app.usage_counts\""
	app_usage_counts_aggregate(
		"distinct select on columns"
		distinct_on: [app_usage_counts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_usage_counts_order_by!]
		"filter the rows returned"
		where: app_usage_counts_bool_exp
	): app_usage_counts_aggregate!
	"fetch data from the table: \"lookup.enum_assignment_content_labels\""
	lookup_enum_assignment_content_labels(
		"distinct select on columns"
		distinct_on: [lookup_enum_assignment_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_assignment_content_labels_order_by!]
		"filter the rows returned"
		where: lookup_enum_assignment_content_labels_bool_exp
	): [lookup_enum_assignment_content_labels!]!
	"fetch aggregated fields from the table: \"lookup.enum_assignment_content_labels\""
	lookup_enum_assignment_content_labels_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_assignment_content_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_assignment_content_labels_order_by!]
		"filter the rows returned"
		where: lookup_enum_assignment_content_labels_bool_exp
	): lookup_enum_assignment_content_labels_aggregate!
	"fetch data from the table: \"lookup.enum_assignment_content_labels\" using primary key columns"
	lookup_enum_assignment_content_labels_by_pk(
		value: String!
	): lookup_enum_assignment_content_labels
	"fetch data from the table: \"lookup.enum_assignment_types\""
	lookup_enum_assignment_types(
		"distinct select on columns"
		distinct_on: [lookup_enum_assignment_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_assignment_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_assignment_types_bool_exp
	): [lookup_enum_assignment_types!]!
	"fetch aggregated fields from the table: \"lookup.enum_assignment_types\""
	lookup_enum_assignment_types_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_assignment_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_assignment_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_assignment_types_bool_exp
	): lookup_enum_assignment_types_aggregate!
	"fetch data from the table: \"lookup.enum_assignment_types\" using primary key columns"
	lookup_enum_assignment_types_by_pk(value: String!): lookup_enum_assignment_types
	"fetch data from the table: \"lookup.enum_collection_labels\""
	lookup_enum_collection_labels(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_labels_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_labels_bool_exp
	): [lookup_enum_collection_labels!]!
	"fetch aggregated fields from the table: \"lookup.enum_collection_labels\""
	lookup_enum_collection_labels_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_labels_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_labels_bool_exp
	): lookup_enum_collection_labels_aggregate!
	"fetch data from the table: \"lookup.enum_collection_labels\" using primary key columns"
	lookup_enum_collection_labels_by_pk(value: String!): lookup_enum_collection_labels
	"fetch data from the table: \"lookup.enum_collection_management_qc_label\""
	lookup_enum_collection_management_qc_label(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_management_qc_label_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_management_qc_label_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_management_qc_label_bool_exp
	): [lookup_enum_collection_management_qc_label!]!
	"fetch aggregated fields from the table: \"lookup.enum_collection_management_qc_label\""
	lookup_enum_collection_management_qc_label_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_management_qc_label_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_management_qc_label_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_management_qc_label_bool_exp
	): lookup_enum_collection_management_qc_label_aggregate!
	"fetch data from the table: \"lookup.enum_collection_management_qc_label\" using primary key columns"
	lookup_enum_collection_management_qc_label_by_pk(
		value: String!
	): lookup_enum_collection_management_qc_label
	"fetch data from the table: \"lookup.enum_collection_management_status\""
	lookup_enum_collection_management_status(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_management_status_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_management_status_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_management_status_bool_exp
	): [lookup_enum_collection_management_status!]!
	"fetch aggregated fields from the table: \"lookup.enum_collection_management_status\""
	lookup_enum_collection_management_status_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_collection_management_status_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_collection_management_status_order_by!]
		"filter the rows returned"
		where: lookup_enum_collection_management_status_bool_exp
	): lookup_enum_collection_management_status_aggregate!
	"fetch data from the table: \"lookup.enum_collection_management_status\" using primary key columns"
	lookup_enum_collection_management_status_by_pk(
		value: String!
	): lookup_enum_collection_management_status
	"fetch data from the table: \"lookup.enum_colors\""
	lookup_enum_colors(
		"distinct select on columns"
		distinct_on: [lookup_enum_colors_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_colors_order_by!]
		"filter the rows returned"
		where: lookup_enum_colors_bool_exp
	): [lookup_enum_colors!]!
	"fetch aggregated fields from the table: \"lookup.enum_colors\""
	lookup_enum_colors_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_colors_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_colors_order_by!]
		"filter the rows returned"
		where: lookup_enum_colors_bool_exp
	): lookup_enum_colors_aggregate!
	"fetch data from the table: \"lookup.enum_colors\" using primary key columns"
	lookup_enum_colors_by_pk(value: String!): lookup_enum_colors
	"fetch data from the table: \"lookup.enum_content_block_types\""
	lookup_enum_content_block_types(
		"distinct select on columns"
		distinct_on: [lookup_enum_content_block_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_content_block_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_content_block_types_bool_exp
	): [lookup_enum_content_block_types!]!
	"fetch aggregated fields from the table: \"lookup.enum_content_block_types\""
	lookup_enum_content_block_types_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_content_block_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_content_block_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_content_block_types_bool_exp
	): lookup_enum_content_block_types_aggregate!
	"fetch data from the table: \"lookup.enum_content_block_types\" using primary key columns"
	lookup_enum_content_block_types_by_pk(value: String!): lookup_enum_content_block_types
	"fetch data from the table: \"lookup.enum_content_types\""
	lookup_enum_content_types(
		"distinct select on columns"
		distinct_on: [lookup_enum_content_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_content_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_content_types_bool_exp
	): [lookup_enum_content_types!]!
	"fetch aggregated fields from the table: \"lookup.enum_content_types\""
	lookup_enum_content_types_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_content_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_content_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_content_types_bool_exp
	): lookup_enum_content_types_aggregate!
	"fetch data from the table: \"lookup.enum_content_types\" using primary key columns"
	lookup_enum_content_types_by_pk(value: String!): lookup_enum_content_types
	"fetch data from the table: \"lookup.enum_input_types\""
	lookup_enum_input_types(
		"distinct select on columns"
		distinct_on: [lookup_enum_input_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_input_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_input_types_bool_exp
	): [lookup_enum_input_types!]!
	"fetch aggregated fields from the table: \"lookup.enum_input_types\""
	lookup_enum_input_types_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_input_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_input_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_input_types_bool_exp
	): lookup_enum_input_types_aggregate!
	"fetch data from the table: \"lookup.enum_input_types\" using primary key columns"
	lookup_enum_input_types_by_pk(value: String!): lookup_enum_input_types
	"fetch data from the table: \"lookup.enum_lom_classification\""
	lookup_enum_lom_classification(
		"distinct select on columns"
		distinct_on: [lookup_enum_lom_classification_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_lom_classification_order_by!]
		"filter the rows returned"
		where: lookup_enum_lom_classification_bool_exp
	): [lookup_enum_lom_classification!]!
	"fetch aggregated fields from the table: \"lookup.enum_lom_classification\""
	lookup_enum_lom_classification_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_lom_classification_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_lom_classification_order_by!]
		"filter the rows returned"
		where: lookup_enum_lom_classification_bool_exp
	): lookup_enum_lom_classification_aggregate!
	"fetch data from the table: \"lookup.enum_lom_classification\" using primary key columns"
	lookup_enum_lom_classification_by_pk(value: String!): lookup_enum_lom_classification
	"fetch data from the table: \"lookup.enum_lom_context\""
	lookup_enum_lom_context(
		"distinct select on columns"
		distinct_on: [lookup_enum_lom_context_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_lom_context_order_by!]
		"filter the rows returned"
		where: lookup_enum_lom_context_bool_exp
	): [lookup_enum_lom_context!]!
	"fetch aggregated fields from the table: \"lookup.enum_lom_context\""
	lookup_enum_lom_context_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_lom_context_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_lom_context_order_by!]
		"filter the rows returned"
		where: lookup_enum_lom_context_bool_exp
	): lookup_enum_lom_context_aggregate!
	"fetch data from the table: \"lookup.enum_lom_context\" using primary key columns"
	lookup_enum_lom_context_by_pk(value: String!): lookup_enum_lom_context
	"fetch data from the table: \"lookup.enum_profile_flags\""
	lookup_enum_profile_flags(
		"distinct select on columns"
		distinct_on: [lookup_enum_profile_flags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_profile_flags_order_by!]
		"filter the rows returned"
		where: lookup_enum_profile_flags_bool_exp
	): [lookup_enum_profile_flags!]!
	"fetch aggregated fields from the table: \"lookup.enum_profile_flags\""
	lookup_enum_profile_flags_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_profile_flags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_profile_flags_order_by!]
		"filter the rows returned"
		where: lookup_enum_profile_flags_bool_exp
	): lookup_enum_profile_flags_aggregate!
	"fetch data from the table: \"lookup.enum_profile_flags\" using primary key columns"
	lookup_enum_profile_flags_by_pk(value: String!): lookup_enum_profile_flags
	"fetch data from the table: \"lookup.enum_profile_preferences_keys\""
	lookup_enum_profile_preferences_keys(
		"distinct select on columns"
		distinct_on: [lookup_enum_profile_preferences_keys_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_profile_preferences_keys_order_by!]
		"filter the rows returned"
		where: lookup_enum_profile_preferences_keys_bool_exp
	): [lookup_enum_profile_preferences_keys!]!
	"fetch aggregated fields from the table: \"lookup.enum_profile_preferences_keys\""
	lookup_enum_profile_preferences_keys_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_profile_preferences_keys_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_profile_preferences_keys_order_by!]
		"filter the rows returned"
		where: lookup_enum_profile_preferences_keys_bool_exp
	): lookup_enum_profile_preferences_keys_aggregate!
	"fetch data from the table: \"lookup.enum_profile_preferences_keys\" using primary key columns"
	lookup_enum_profile_preferences_keys_by_pk(value: String!): lookup_enum_profile_preferences_keys
	"fetch data from the table: \"lookup.enum_relation_types\""
	lookup_enum_relation_types(
		"distinct select on columns"
		distinct_on: [lookup_enum_relation_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_relation_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_relation_types_bool_exp
	): [lookup_enum_relation_types!]!
	"fetch aggregated fields from the table: \"lookup.enum_relation_types\""
	lookup_enum_relation_types_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_relation_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_relation_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_relation_types_bool_exp
	): lookup_enum_relation_types_aggregate!
	"fetch data from the table: \"lookup.enum_relation_types\" using primary key columns"
	lookup_enum_relation_types_by_pk(value: String!): lookup_enum_relation_types
	"fetch data from the table: \"lookup.enum_search_bookmark_types\""
	lookup_enum_search_bookmark_types(
		"distinct select on columns"
		distinct_on: [lookup_enum_search_bookmark_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_search_bookmark_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_search_bookmark_types_bool_exp
	): [lookup_enum_search_bookmark_types!]!
	"fetch aggregated fields from the table: \"lookup.enum_search_bookmark_types\""
	lookup_enum_search_bookmark_types_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_enum_search_bookmark_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_enum_search_bookmark_types_order_by!]
		"filter the rows returned"
		where: lookup_enum_search_bookmark_types_bool_exp
	): lookup_enum_search_bookmark_types_aggregate!
	"fetch data from the table: \"lookup.enum_search_bookmark_types\" using primary key columns"
	lookup_enum_search_bookmark_types_by_pk(value: String!): lookup_enum_search_bookmark_types
	"fetch data from the table: \"lookup.thesaurus\""
	lookup_thesaurus(
		"distinct select on columns"
		distinct_on: [lookup_thesaurus_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_thesaurus_order_by!]
		"filter the rows returned"
		where: lookup_thesaurus_bool_exp
	): [lookup_thesaurus!]!
	"fetch aggregated fields from the table: \"lookup.thesaurus\""
	lookup_thesaurus_aggregate(
		"distinct select on columns"
		distinct_on: [lookup_thesaurus_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [lookup_thesaurus_order_by!]
		"filter the rows returned"
		where: lookup_thesaurus_bool_exp
	): lookup_thesaurus_aggregate!
	"fetch data from the table: \"lookup.thesaurus\" using primary key columns"
	lookup_thesaurus_by_pk(id: String!): lookup_thesaurus
	"fetch data from the table: \"migrate.original_publishdate\""
	migrate_original_publishdate(
		"distinct select on columns"
		distinct_on: [migrate_original_publishdate_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [migrate_original_publishdate_order_by!]
		"filter the rows returned"
		where: migrate_original_publishdate_bool_exp
	): [migrate_original_publishdate!]!
	"fetch aggregated fields from the table: \"migrate.original_publishdate\""
	migrate_original_publishdate_aggregate(
		"distinct select on columns"
		distinct_on: [migrate_original_publishdate_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [migrate_original_publishdate_order_by!]
		"filter the rows returned"
		where: migrate_original_publishdate_bool_exp
	): migrate_original_publishdate_aggregate!
	"fetch data from the table: \"migrate.original_publishdate\" using primary key columns"
	migrate_original_publishdate_by_pk(mediamosa_id: String!): migrate_original_publishdate
	"fetch data from the table: \"migrate.reference_ids\""
	migrate_reference_ids(
		"distinct select on columns"
		distinct_on: [migrate_reference_ids_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [migrate_reference_ids_order_by!]
		"filter the rows returned"
		where: migrate_reference_ids_bool_exp
	): [migrate_reference_ids!]!
	"fetch aggregated fields from the table: \"migrate.reference_ids\""
	migrate_reference_ids_aggregate(
		"distinct select on columns"
		distinct_on: [migrate_reference_ids_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [migrate_reference_ids_order_by!]
		"filter the rows returned"
		where: migrate_reference_ids_bool_exp
	): migrate_reference_ids_aggregate!
	"fetch data from the table: \"migrate.reference_ids\" using primary key columns"
	migrate_reference_ids_by_pk(id: Int!): migrate_reference_ids
	"fetch data from the table: \"shared.collateral\""
	shared_collateral(
		"distinct select on columns"
		distinct_on: [shared_collateral_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_collateral_order_by!]
		"filter the rows returned"
		where: shared_collateral_bool_exp
	): [shared_collateral!]!
	"fetch aggregated fields from the table: \"shared.collateral\""
	shared_collateral_aggregate(
		"distinct select on columns"
		distinct_on: [shared_collateral_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_collateral_order_by!]
		"filter the rows returned"
		where: shared_collateral_bool_exp
	): shared_collateral_aggregate!
	"fetch data from the table: \"shared.collateral\" using primary key columns"
	shared_collateral_by_pk(id: Int!): shared_collateral
	"fetch data from the table: \"shared.items\""
	shared_items(
		"distinct select on columns"
		distinct_on: [shared_items_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_items_order_by!]
		"filter the rows returned"
		where: shared_items_bool_exp
	): [shared_items!]!
	"fetch aggregated fields from the table: \"shared.items\""
	shared_items_aggregate(
		"distinct select on columns"
		distinct_on: [shared_items_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_items_order_by!]
		"filter the rows returned"
		where: shared_items_bool_exp
	): shared_items_aggregate!
	"fetch data from the table: \"shared.items\" using primary key columns"
	shared_items_by_pk(id: Int!): shared_items
	"fetch data from the table: \"shared.ldap_organizations\""
	shared_ldap_organizations(
		"distinct select on columns"
		distinct_on: [shared_ldap_organizations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_ldap_organizations_order_by!]
		"filter the rows returned"
		where: shared_ldap_organizations_bool_exp
	): [shared_ldap_organizations!]!
	"fetch aggregated fields from the table: \"shared.ldap_organizations\""
	shared_ldap_organizations_aggregate(
		"distinct select on columns"
		distinct_on: [shared_ldap_organizations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_ldap_organizations_order_by!]
		"filter the rows returned"
		where: shared_ldap_organizations_bool_exp
	): shared_ldap_organizations_aggregate!
	"fetch data from the table: \"shared.ldap_organizations\" using primary key columns"
	shared_ldap_organizations_by_pk(id: Int!): shared_ldap_organizations
	"fetch data from the table: \"shared.organisations\""
	shared_organisations(
		"distinct select on columns"
		distinct_on: [shared_organisations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_organisations_order_by!]
		"filter the rows returned"
		where: shared_organisations_bool_exp
	): [shared_organisations!]!
	"fetch aggregated fields from the table: \"shared.organisations\""
	shared_organisations_aggregate(
		"distinct select on columns"
		distinct_on: [shared_organisations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_organisations_order_by!]
		"filter the rows returned"
		where: shared_organisations_bool_exp
	): shared_organisations_aggregate!
	"fetch data from the table: \"shared.organisations\" using primary key columns"
	shared_organisations_by_pk(or_id: String!): shared_organisations
	"fetch data from the table: \"shared.organisations_with_users\""
	shared_organisations_with_users(
		"distinct select on columns"
		distinct_on: [shared_organisations_with_users_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_organisations_with_users_order_by!]
		"filter the rows returned"
		where: shared_organisations_with_users_bool_exp
	): [shared_organisations_with_users!]!
	"fetch aggregated fields from the table: \"shared.organisations_with_users\""
	shared_organisations_with_users_aggregate(
		"distinct select on columns"
		distinct_on: [shared_organisations_with_users_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_organisations_with_users_order_by!]
		"filter the rows returned"
		where: shared_organisations_with_users_bool_exp
	): shared_organisations_with_users_aggregate!
	"fetch data from the table: \"shared.types\""
	shared_types(
		"distinct select on columns"
		distinct_on: [shared_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_types_order_by!]
		"filter the rows returned"
		where: shared_types_bool_exp
	): [shared_types!]!
	"fetch aggregated fields from the table: \"shared.types\""
	shared_types_aggregate(
		"distinct select on columns"
		distinct_on: [shared_types_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_types_order_by!]
		"filter the rows returned"
		where: shared_types_bool_exp
	): shared_types_aggregate!
	"fetch data from the table: \"shared.types\" using primary key columns"
	shared_types_by_pk(id: Int!): shared_types
	"fetch data from the table: \"shared.user_last_blocked\""
	shared_user_last_blocked(
		"distinct select on columns"
		distinct_on: [shared_user_last_blocked_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_last_blocked_order_by!]
		"filter the rows returned"
		where: shared_user_last_blocked_bool_exp
	): [shared_user_last_blocked!]!
	"fetch aggregated fields from the table: \"shared.user_last_blocked\""
	shared_user_last_blocked_aggregate(
		"distinct select on columns"
		distinct_on: [shared_user_last_blocked_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_last_blocked_order_by!]
		"filter the rows returned"
		where: shared_user_last_blocked_bool_exp
	): shared_user_last_blocked_aggregate!
	"fetch data from the table: \"shared.user_last_unblocked\""
	shared_user_last_unblocked(
		"distinct select on columns"
		distinct_on: [shared_user_last_unblocked_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_last_unblocked_order_by!]
		"filter the rows returned"
		where: shared_user_last_unblocked_bool_exp
	): [shared_user_last_unblocked!]!
	"fetch aggregated fields from the table: \"shared.user_last_unblocked\""
	shared_user_last_unblocked_aggregate(
		"distinct select on columns"
		distinct_on: [shared_user_last_unblocked_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_last_unblocked_order_by!]
		"filter the rows returned"
		where: shared_user_last_unblocked_bool_exp
	): shared_user_last_unblocked_aggregate!
	"fetch data from the table: \"shared.user_names\""
	shared_user_names(
		"distinct select on columns"
		distinct_on: [shared_user_names_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_names_order_by!]
		"filter the rows returned"
		where: shared_user_names_bool_exp
	): [shared_user_names!]!
	"fetch aggregated fields from the table: \"shared.user_names\""
	shared_user_names_aggregate(
		"distinct select on columns"
		distinct_on: [shared_user_names_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_names_order_by!]
		"filter the rows returned"
		where: shared_user_names_bool_exp
	): shared_user_names_aggregate!
	"fetch data from the table: \"shared.user_roles\""
	shared_user_roles(
		"distinct select on columns"
		distinct_on: [shared_user_roles_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_roles_order_by!]
		"filter the rows returned"
		where: shared_user_roles_bool_exp
	): [shared_user_roles!]!
	"fetch aggregated fields from the table: \"shared.user_roles\""
	shared_user_roles_aggregate(
		"distinct select on columns"
		distinct_on: [shared_user_roles_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_roles_order_by!]
		"filter the rows returned"
		where: shared_user_roles_bool_exp
	): shared_user_roles_aggregate!
	"fetch data from the table: \"shared.user_roles\" using primary key columns"
	shared_user_roles_by_pk(id: Int!): shared_user_roles
	"fetch data from the table: \"shared.user_temp_access\""
	shared_user_temp_access(
		"distinct select on columns"
		distinct_on: [shared_user_temp_access_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_temp_access_order_by!]
		"filter the rows returned"
		where: shared_user_temp_access_bool_exp
	): [shared_user_temp_access!]!
	"fetch aggregated fields from the table: \"shared.user_temp_access\""
	shared_user_temp_access_aggregate(
		"distinct select on columns"
		distinct_on: [shared_user_temp_access_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_temp_access_order_by!]
		"filter the rows returned"
		where: shared_user_temp_access_bool_exp
	): shared_user_temp_access_aggregate!
	"fetch data from the table: \"shared.user_temp_access\" using primary key columns"
	shared_user_temp_access_by_pk(user_id: uuid!): shared_user_temp_access
	"fetch data from the table: \"shared.user_temp_access_status\""
	shared_user_temp_access_status(
		"distinct select on columns"
		distinct_on: [shared_user_temp_access_status_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_temp_access_status_order_by!]
		"filter the rows returned"
		where: shared_user_temp_access_status_bool_exp
	): [shared_user_temp_access_status!]!
	"fetch aggregated fields from the table: \"shared.user_temp_access_status\""
	shared_user_temp_access_status_aggregate(
		"distinct select on columns"
		distinct_on: [shared_user_temp_access_status_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_user_temp_access_status_order_by!]
		"filter the rows returned"
		where: shared_user_temp_access_status_bool_exp
	): shared_user_temp_access_status_aggregate!
	"fetch data from the table: \"shared.users\""
	shared_users(
		"distinct select on columns"
		distinct_on: [shared_users_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_users_order_by!]
		"filter the rows returned"
		where: shared_users_bool_exp
	): [shared_users!]!
	"fetch aggregated fields from the table: \"shared.users\""
	shared_users_aggregate(
		"distinct select on columns"
		distinct_on: [shared_users_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [shared_users_order_by!]
		"filter the rows returned"
		where: shared_users_bool_exp
	): shared_users_aggregate!
	"fetch data from the table: \"shared.users\" using primary key columns"
	shared_users_by_pk(uid: uuid!): shared_users
	"fetch data from the table: \"users.audit_log\""
	users_audit_log(
		"distinct select on columns"
		distinct_on: [users_audit_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_audit_log_order_by!]
		"filter the rows returned"
		where: users_audit_log_bool_exp
	): [users_audit_log!]!
	"fetch aggregated fields from the table: \"users.audit_log\""
	users_audit_log_aggregate(
		"distinct select on columns"
		distinct_on: [users_audit_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_audit_log_order_by!]
		"filter the rows returned"
		where: users_audit_log_bool_exp
	): users_audit_log_aggregate!
	"fetch data from the table: \"users.audit_log\" using primary key columns"
	users_audit_log_by_pk(id: Int!): users_audit_log
	"fetch data from the table: \"users.email_preferences\""
	users_email_preferences(
		"distinct select on columns"
		distinct_on: [users_email_preferences_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_email_preferences_order_by!]
		"filter the rows returned"
		where: users_email_preferences_bool_exp
	): [users_email_preferences!]!
	"fetch aggregated fields from the table: \"users.email_preferences\""
	users_email_preferences_aggregate(
		"distinct select on columns"
		distinct_on: [users_email_preferences_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_email_preferences_order_by!]
		"filter the rows returned"
		where: users_email_preferences_bool_exp
	): users_email_preferences_aggregate!
	"fetch data from the table: \"users.email_preferences\" using primary key columns"
	users_email_preferences_by_pk(id: uuid!): users_email_preferences
	"fetch data from the table: \"users.group_user_permission_groups\""
	users_group_user_permission_groups(
		"distinct select on columns"
		distinct_on: [users_group_user_permission_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_group_user_permission_groups_order_by!]
		"filter the rows returned"
		where: users_group_user_permission_groups_bool_exp
	): [users_group_user_permission_groups!]!
	"fetch aggregated fields from the table: \"users.group_user_permission_groups\""
	users_group_user_permission_groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_group_user_permission_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_group_user_permission_groups_order_by!]
		"filter the rows returned"
		where: users_group_user_permission_groups_bool_exp
	): users_group_user_permission_groups_aggregate!
	"fetch data from the table: \"users.group_user_permission_groups\" using primary key columns"
	users_group_user_permission_groups_by_pk(id: Int!): users_group_user_permission_groups
	"fetch data from the table: \"users.groups\""
	users_groups(
		"distinct select on columns"
		distinct_on: [users_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_groups_order_by!]
		"filter the rows returned"
		where: users_groups_bool_exp
	): [users_groups!]!
	"fetch aggregated fields from the table: \"users.groups\""
	users_groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_groups_order_by!]
		"filter the rows returned"
		where: users_groups_bool_exp
	): users_groups_aggregate!
	"fetch data from the table: \"users.groups\" using primary key columns"
	users_groups_by_pk(id: Int!): users_groups
	"fetch data from the table: \"users.idp_map\""
	users_idp_map(
		"distinct select on columns"
		distinct_on: [users_idp_map_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_idp_map_order_by!]
		"filter the rows returned"
		where: users_idp_map_bool_exp
	): [users_idp_map!]!
	"fetch aggregated fields from the table: \"users.idp_map\""
	users_idp_map_aggregate(
		"distinct select on columns"
		distinct_on: [users_idp_map_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_idp_map_order_by!]
		"filter the rows returned"
		where: users_idp_map_bool_exp
	): users_idp_map_aggregate!
	"fetch data from the table: \"users.idp_map\" using primary key columns"
	users_idp_map_by_pk(id: Int!): users_idp_map
	"fetch data from the table: \"users.idps\""
	users_idps(
		"distinct select on columns"
		distinct_on: [users_idps_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_idps_order_by!]
		"filter the rows returned"
		where: users_idps_bool_exp
	): [users_idps!]!
	"fetch aggregated fields from the table: \"users.idps\""
	users_idps_aggregate(
		"distinct select on columns"
		distinct_on: [users_idps_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_idps_order_by!]
		"filter the rows returned"
		where: users_idps_bool_exp
	): users_idps_aggregate!
	"fetch data from the table: \"users.idps\" using primary key columns"
	users_idps_by_pk(value: String!): users_idps
	"fetch data from the table: \"users.notifications\""
	users_notifications(
		"distinct select on columns"
		distinct_on: [users_notifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_notifications_order_by!]
		"filter the rows returned"
		where: users_notifications_bool_exp
	): [users_notifications!]!
	"fetch aggregated fields from the table: \"users.notifications\""
	users_notifications_aggregate(
		"distinct select on columns"
		distinct_on: [users_notifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_notifications_order_by!]
		"filter the rows returned"
		where: users_notifications_bool_exp
	): users_notifications_aggregate!
	"fetch data from the table: \"users.notifications\" using primary key columns"
	users_notifications_by_pk(id: uuid!): users_notifications
	"fetch data from the table: \"users.permission_group_user_permissions\""
	users_permission_group_user_permissions(
		"distinct select on columns"
		distinct_on: [users_permission_group_user_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_group_user_permissions_order_by!]
		"filter the rows returned"
		where: users_permission_group_user_permissions_bool_exp
	): [users_permission_group_user_permissions!]!
	"fetch aggregated fields from the table: \"users.permission_group_user_permissions\""
	users_permission_group_user_permissions_aggregate(
		"distinct select on columns"
		distinct_on: [users_permission_group_user_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_group_user_permissions_order_by!]
		"filter the rows returned"
		where: users_permission_group_user_permissions_bool_exp
	): users_permission_group_user_permissions_aggregate!
	"fetch data from the table: \"users.permission_group_user_permissions\" using primary key columns"
	users_permission_group_user_permissions_by_pk(id: Int!): users_permission_group_user_permissions
	"fetch data from the table: \"users.permission_groups\""
	users_permission_groups(
		"distinct select on columns"
		distinct_on: [users_permission_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_groups_order_by!]
		"filter the rows returned"
		where: users_permission_groups_bool_exp
	): [users_permission_groups!]!
	"fetch aggregated fields from the table: \"users.permission_groups\""
	users_permission_groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_permission_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_groups_order_by!]
		"filter the rows returned"
		where: users_permission_groups_bool_exp
	): users_permission_groups_aggregate!
	"fetch data from the table: \"users.permission_groups\" using primary key columns"
	users_permission_groups_by_pk(id: Int!): users_permission_groups
	"fetch data from the table: \"users.permission_matrix_view\""
	users_permission_matrix_view(
		"distinct select on columns"
		distinct_on: [users_permission_matrix_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_matrix_view_order_by!]
		"filter the rows returned"
		where: users_permission_matrix_view_bool_exp
	): [users_permission_matrix_view!]!
	"fetch aggregated fields from the table: \"users.permission_matrix_view\""
	users_permission_matrix_view_aggregate(
		"distinct select on columns"
		distinct_on: [users_permission_matrix_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_matrix_view_order_by!]
		"filter the rows returned"
		where: users_permission_matrix_view_bool_exp
	): users_permission_matrix_view_aggregate!
	"fetch data from the table: \"users.permissions\""
	users_permissions(
		"distinct select on columns"
		distinct_on: [users_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permissions_order_by!]
		"filter the rows returned"
		where: users_permissions_bool_exp
	): [users_permissions!]!
	"fetch aggregated fields from the table: \"users.permissions\""
	users_permissions_aggregate(
		"distinct select on columns"
		distinct_on: [users_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permissions_order_by!]
		"filter the rows returned"
		where: users_permissions_bool_exp
	): users_permissions_aggregate!
	"fetch data from the table: \"users.permissions\" using primary key columns"
	users_permissions_by_pk(id: Int!): users_permissions
	"fetch data from the table: \"users.profile_classifications\""
	users_profile_classifications(
		"distinct select on columns"
		distinct_on: [users_profile_classifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_classifications_order_by!]
		"filter the rows returned"
		where: users_profile_classifications_bool_exp
	): [users_profile_classifications!]!
	"fetch aggregated fields from the table: \"users.profile_classifications\""
	users_profile_classifications_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_classifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_classifications_order_by!]
		"filter the rows returned"
		where: users_profile_classifications_bool_exp
	): users_profile_classifications_aggregate!
	"fetch data from the table: \"users.profile_classifications\" using primary key columns"
	users_profile_classifications_by_pk(id: uuid!): users_profile_classifications
	"fetch data from the table: \"users.profile_contexts\""
	users_profile_contexts(
		"distinct select on columns"
		distinct_on: [users_profile_contexts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_contexts_order_by!]
		"filter the rows returned"
		where: users_profile_contexts_bool_exp
	): [users_profile_contexts!]!
	"fetch aggregated fields from the table: \"users.profile_contexts\""
	users_profile_contexts_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_contexts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_contexts_order_by!]
		"filter the rows returned"
		where: users_profile_contexts_bool_exp
	): users_profile_contexts_aggregate!
	"fetch data from the table: \"users.profile_contexts\" using primary key columns"
	users_profile_contexts_by_pk(id: uuid!): users_profile_contexts
	"fetch data from the table: \"users.profile_flags\""
	users_profile_flags(
		"distinct select on columns"
		distinct_on: [users_profile_flags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_flags_order_by!]
		"filter the rows returned"
		where: users_profile_flags_bool_exp
	): [users_profile_flags!]!
	"fetch aggregated fields from the table: \"users.profile_flags\""
	users_profile_flags_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_flags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_flags_order_by!]
		"filter the rows returned"
		where: users_profile_flags_bool_exp
	): users_profile_flags_aggregate!
	"fetch data from the table: \"users.profile_flags\" using primary key columns"
	users_profile_flags_by_pk(id: Int!): users_profile_flags
	"fetch data from the table: \"users.profile_organizations\""
	users_profile_organizations(
		"distinct select on columns"
		distinct_on: [users_profile_organizations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_organizations_order_by!]
		"filter the rows returned"
		where: users_profile_organizations_bool_exp
	): [users_profile_organizations!]!
	"fetch aggregated fields from the table: \"users.profile_organizations\""
	users_profile_organizations_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_organizations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_organizations_order_by!]
		"filter the rows returned"
		where: users_profile_organizations_bool_exp
	): users_profile_organizations_aggregate!
	"fetch data from the table: \"users.profile_organizations\" using primary key columns"
	users_profile_organizations_by_pk(id: uuid!): users_profile_organizations
	"fetch data from the table: \"users.profile_preferences\""
	users_profile_preferences(
		"distinct select on columns"
		distinct_on: [users_profile_preferences_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_preferences_order_by!]
		"filter the rows returned"
		where: users_profile_preferences_bool_exp
	): [users_profile_preferences!]!
	"fetch aggregated fields from the table: \"users.profile_preferences\""
	users_profile_preferences_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_preferences_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_preferences_order_by!]
		"filter the rows returned"
		where: users_profile_preferences_bool_exp
	): users_profile_preferences_aggregate!
	"fetch data from the table: \"users.profile_preferences\" using primary key columns"
	users_profile_preferences_by_pk(id: Int!): users_profile_preferences
	"fetch data from the table: \"users.profile_user_groups\""
	users_profile_user_groups(
		"distinct select on columns"
		distinct_on: [users_profile_user_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_user_groups_order_by!]
		"filter the rows returned"
		where: users_profile_user_groups_bool_exp
	): [users_profile_user_groups!]!
	"fetch aggregated fields from the table: \"users.profile_user_groups\""
	users_profile_user_groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_user_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_user_groups_order_by!]
		"filter the rows returned"
		where: users_profile_user_groups_bool_exp
	): users_profile_user_groups_aggregate!
	"fetch data from the table: \"users.profile_user_groups\" using primary key columns"
	users_profile_user_groups_by_pk(id: Int!): users_profile_user_groups
	"fetch data from the table: \"users.profiles\""
	users_profiles(
		"distinct select on columns"
		distinct_on: [users_profiles_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profiles_order_by!]
		"filter the rows returned"
		where: users_profiles_bool_exp
	): [users_profiles!]!
	"fetch aggregated fields from the table: \"users.profiles\""
	users_profiles_aggregate(
		"distinct select on columns"
		distinct_on: [users_profiles_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profiles_order_by!]
		"filter the rows returned"
		where: users_profiles_bool_exp
	): users_profiles_aggregate!
	"fetch data from the table: \"users.profiles\" using primary key columns"
	users_profiles_by_pk("Een gebruiker kan een of meer profielen hebben" id: uuid!): users_profiles
	"fetch data from the table: \"users.summary_view\""
	users_summary_view(
		"distinct select on columns"
		distinct_on: [users_summary_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_summary_view_order_by!]
		"filter the rows returned"
		where: users_summary_view_bool_exp
	): [users_summary_view!]!
	"fetch aggregated fields from the table: \"users.summary_view\""
	users_summary_view_aggregate(
		"distinct select on columns"
		distinct_on: [users_summary_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_summary_view_order_by!]
		"filter the rows returned"
		where: users_summary_view_bool_exp
	): users_summary_view_aggregate!
}

"columns and relationships of \"users.audit_log\""
type users_audit_log {
	created_at: timestamptz!
	event: String!
	id: Int!
	message("JSON select path" path: String): jsonb
	"An object relationship"
	user: shared_users!
	user_id: uuid!
}

"aggregated selection of \"users.audit_log\""
type users_audit_log_aggregate {
	aggregate: users_audit_log_aggregate_fields
	nodes: [users_audit_log!]!
}

"aggregate fields of \"users.audit_log\""
type users_audit_log_aggregate_fields {
	avg: users_audit_log_avg_fields
	count(columns: [users_audit_log_select_column!], distinct: Boolean): Int
	max: users_audit_log_max_fields
	min: users_audit_log_min_fields
	stddev: users_audit_log_stddev_fields
	stddev_pop: users_audit_log_stddev_pop_fields
	stddev_samp: users_audit_log_stddev_samp_fields
	sum: users_audit_log_sum_fields
	var_pop: users_audit_log_var_pop_fields
	var_samp: users_audit_log_var_samp_fields
	variance: users_audit_log_variance_fields
}

"aggregate avg on columns"
type users_audit_log_avg_fields {
	id: Float
}

"aggregate max on columns"
type users_audit_log_max_fields {
	created_at: timestamptz
	event: String
	id: Int
	user_id: uuid
}

"aggregate min on columns"
type users_audit_log_min_fields {
	created_at: timestamptz
	event: String
	id: Int
	user_id: uuid
}

"response of any mutation on the table \"users.audit_log\""
type users_audit_log_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_audit_log!]!
}

"aggregate stddev on columns"
type users_audit_log_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type users_audit_log_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type users_audit_log_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type users_audit_log_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type users_audit_log_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type users_audit_log_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type users_audit_log_variance_fields {
	id: Float
}

"columns and relationships of \"users.email_preferences\""
type users_email_preferences {
	checked: Boolean!
	id: uuid!
	key: String!
	"An object relationship"
	profile: users_profiles!
	profile_id: uuid!
}

"aggregated selection of \"users.email_preferences\""
type users_email_preferences_aggregate {
	aggregate: users_email_preferences_aggregate_fields
	nodes: [users_email_preferences!]!
}

"aggregate fields of \"users.email_preferences\""
type users_email_preferences_aggregate_fields {
	count(columns: [users_email_preferences_select_column!], distinct: Boolean): Int
	max: users_email_preferences_max_fields
	min: users_email_preferences_min_fields
}

"aggregate max on columns"
type users_email_preferences_max_fields {
	id: uuid
	key: String
	profile_id: uuid
}

"aggregate min on columns"
type users_email_preferences_min_fields {
	id: uuid
	key: String
	profile_id: uuid
}

"response of any mutation on the table \"users.email_preferences\""
type users_email_preferences_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_email_preferences!]!
}

"""
Reference table for linking permission groups to user groups with foreign keys on both group id's.


columns and relationships of "users.group_user_permission_groups"
"""
type users_group_user_permission_groups {
	"An object relationship"
	group: users_groups!
	id: Int!
	"An object relationship"
	permission_group: users_permission_groups!
	user_group_id: Int!
	user_permission_group_id: Int!
}

"aggregated selection of \"users.group_user_permission_groups\""
type users_group_user_permission_groups_aggregate {
	aggregate: users_group_user_permission_groups_aggregate_fields
	nodes: [users_group_user_permission_groups!]!
}

"aggregate fields of \"users.group_user_permission_groups\""
type users_group_user_permission_groups_aggregate_fields {
	avg: users_group_user_permission_groups_avg_fields
	count(columns: [users_group_user_permission_groups_select_column!], distinct: Boolean): Int
	max: users_group_user_permission_groups_max_fields
	min: users_group_user_permission_groups_min_fields
	stddev: users_group_user_permission_groups_stddev_fields
	stddev_pop: users_group_user_permission_groups_stddev_pop_fields
	stddev_samp: users_group_user_permission_groups_stddev_samp_fields
	sum: users_group_user_permission_groups_sum_fields
	var_pop: users_group_user_permission_groups_var_pop_fields
	var_samp: users_group_user_permission_groups_var_samp_fields
	variance: users_group_user_permission_groups_variance_fields
}

"aggregate avg on columns"
type users_group_user_permission_groups_avg_fields {
	id: Float
	user_group_id: Float
	user_permission_group_id: Float
}

"aggregate max on columns"
type users_group_user_permission_groups_max_fields {
	id: Int
	user_group_id: Int
	user_permission_group_id: Int
}

"aggregate min on columns"
type users_group_user_permission_groups_min_fields {
	id: Int
	user_group_id: Int
	user_permission_group_id: Int
}

"response of any mutation on the table \"users.group_user_permission_groups\""
type users_group_user_permission_groups_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_group_user_permission_groups!]!
}

"aggregate stddev on columns"
type users_group_user_permission_groups_stddev_fields {
	id: Float
	user_group_id: Float
	user_permission_group_id: Float
}

"aggregate stddev_pop on columns"
type users_group_user_permission_groups_stddev_pop_fields {
	id: Float
	user_group_id: Float
	user_permission_group_id: Float
}

"aggregate stddev_samp on columns"
type users_group_user_permission_groups_stddev_samp_fields {
	id: Float
	user_group_id: Float
	user_permission_group_id: Float
}

"aggregate sum on columns"
type users_group_user_permission_groups_sum_fields {
	id: Int
	user_group_id: Int
	user_permission_group_id: Int
}

"aggregate var_pop on columns"
type users_group_user_permission_groups_var_pop_fields {
	id: Float
	user_group_id: Float
	user_permission_group_id: Float
}

"aggregate var_samp on columns"
type users_group_user_permission_groups_var_samp_fields {
	id: Float
	user_group_id: Float
	user_permission_group_id: Float
}

"aggregate variance on columns"
type users_group_user_permission_groups_variance_fields {
	id: Float
	user_group_id: Float
	user_permission_group_id: Float
}

"columns and relationships of \"users.groups\""
type users_groups {
	created_at: timestamptz!
	description: String
	"An array relationship"
	group_user_permission_groups(
		"distinct select on columns"
		distinct_on: [users_group_user_permission_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_group_user_permission_groups_order_by!]
		"filter the rows returned"
		where: users_group_user_permission_groups_bool_exp
	): [users_group_user_permission_groups!]!
	"An aggregated array relationship"
	group_user_permission_groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_group_user_permission_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_group_user_permission_groups_order_by!]
		"filter the rows returned"
		where: users_group_user_permission_groups_bool_exp
	): users_group_user_permission_groups_aggregate!
	id: Int!
	label: String!
	ldap_role: String
	"An array relationship"
	profile_user_groups(
		"distinct select on columns"
		distinct_on: [users_profile_user_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_user_groups_order_by!]
		"filter the rows returned"
		where: users_profile_user_groups_bool_exp
	): [users_profile_user_groups!]!
	"An aggregated array relationship"
	profile_user_groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_user_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_user_groups_order_by!]
		"filter the rows returned"
		where: users_profile_user_groups_bool_exp
	): users_profile_user_groups_aggregate!
	updated_at: timestamptz!
}

"aggregated selection of \"users.groups\""
type users_groups_aggregate {
	aggregate: users_groups_aggregate_fields
	nodes: [users_groups!]!
}

"aggregate fields of \"users.groups\""
type users_groups_aggregate_fields {
	avg: users_groups_avg_fields
	count(columns: [users_groups_select_column!], distinct: Boolean): Int
	max: users_groups_max_fields
	min: users_groups_min_fields
	stddev: users_groups_stddev_fields
	stddev_pop: users_groups_stddev_pop_fields
	stddev_samp: users_groups_stddev_samp_fields
	sum: users_groups_sum_fields
	var_pop: users_groups_var_pop_fields
	var_samp: users_groups_var_samp_fields
	variance: users_groups_variance_fields
}

"aggregate avg on columns"
type users_groups_avg_fields {
	id: Float
}

"aggregate max on columns"
type users_groups_max_fields {
	created_at: timestamptz
	description: String
	id: Int
	label: String
	ldap_role: String
	updated_at: timestamptz
}

"aggregate min on columns"
type users_groups_min_fields {
	created_at: timestamptz
	description: String
	id: Int
	label: String
	ldap_role: String
	updated_at: timestamptz
}

"response of any mutation on the table \"users.groups\""
type users_groups_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_groups!]!
}

"aggregate stddev on columns"
type users_groups_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type users_groups_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type users_groups_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type users_groups_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type users_groups_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type users_groups_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type users_groups_variance_fields {
	id: Float
}

"""
Mapping voor externe idp ID naar lokale user ID.


columns and relationships of "users.idp_map"
"""
type users_idp_map {
	id: Int!
	idp: users_idps_enum!
	"An object relationship"
	idpByIdp: users_idps!
	idp_user_id: String!
	"An object relationship"
	local_user: shared_users
	local_user_id: uuid!
}

"aggregated selection of \"users.idp_map\""
type users_idp_map_aggregate {
	aggregate: users_idp_map_aggregate_fields
	nodes: [users_idp_map!]!
}

"aggregate fields of \"users.idp_map\""
type users_idp_map_aggregate_fields {
	avg: users_idp_map_avg_fields
	count(columns: [users_idp_map_select_column!], distinct: Boolean): Int
	max: users_idp_map_max_fields
	min: users_idp_map_min_fields
	stddev: users_idp_map_stddev_fields
	stddev_pop: users_idp_map_stddev_pop_fields
	stddev_samp: users_idp_map_stddev_samp_fields
	sum: users_idp_map_sum_fields
	var_pop: users_idp_map_var_pop_fields
	var_samp: users_idp_map_var_samp_fields
	variance: users_idp_map_variance_fields
}

"aggregate avg on columns"
type users_idp_map_avg_fields {
	id: Float
}

"aggregate max on columns"
type users_idp_map_max_fields {
	id: Int
	idp_user_id: String
	local_user_id: uuid
}

"aggregate min on columns"
type users_idp_map_min_fields {
	id: Int
	idp_user_id: String
	local_user_id: uuid
}

"response of any mutation on the table \"users.idp_map\""
type users_idp_map_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_idp_map!]!
}

"aggregate stddev on columns"
type users_idp_map_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type users_idp_map_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type users_idp_map_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type users_idp_map_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type users_idp_map_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type users_idp_map_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type users_idp_map_variance_fields {
	id: Float
}

"columns and relationships of \"users.idps\""
type users_idps {
	description: String
	value: String!
}

"aggregated selection of \"users.idps\""
type users_idps_aggregate {
	aggregate: users_idps_aggregate_fields
	nodes: [users_idps!]!
}

"aggregate fields of \"users.idps\""
type users_idps_aggregate_fields {
	count(columns: [users_idps_select_column!], distinct: Boolean): Int
	max: users_idps_max_fields
	min: users_idps_min_fields
}

"aggregate max on columns"
type users_idps_max_fields {
	description: String
	value: String
}

"aggregate min on columns"
type users_idps_min_fields {
	description: String
	value: String
}

"response of any mutation on the table \"users.idps\""
type users_idps_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_idps!]!
}

"columns and relationships of \"users.notifications\""
type users_notifications {
	id: uuid!
	key: String!
	"An object relationship"
	profile: users_profiles!
	profile_id: uuid!
	through_email: Boolean
	through_platform: Boolean
}

"aggregated selection of \"users.notifications\""
type users_notifications_aggregate {
	aggregate: users_notifications_aggregate_fields
	nodes: [users_notifications!]!
}

"aggregate fields of \"users.notifications\""
type users_notifications_aggregate_fields {
	count(columns: [users_notifications_select_column!], distinct: Boolean): Int
	max: users_notifications_max_fields
	min: users_notifications_min_fields
}

"aggregate max on columns"
type users_notifications_max_fields {
	id: uuid
	key: String
	profile_id: uuid
}

"aggregate min on columns"
type users_notifications_min_fields {
	id: uuid
	key: String
	profile_id: uuid
}

"response of any mutation on the table \"users.notifications\""
type users_notifications_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_notifications!]!
}

"columns and relationships of \"users.permission_group_user_permissions\""
type users_permission_group_user_permissions {
	id: Int!
	"An object relationship"
	permission: users_permissions!
	"An object relationship"
	permission_group: users_permission_groups!
	"An array relationship"
	permissions(
		"distinct select on columns"
		distinct_on: [users_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permissions_order_by!]
		"filter the rows returned"
		where: users_permissions_bool_exp
	): [users_permissions!]!
	"An aggregated array relationship"
	permissions_aggregate(
		"distinct select on columns"
		distinct_on: [users_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permissions_order_by!]
		"filter the rows returned"
		where: users_permissions_bool_exp
	): users_permissions_aggregate!
	user_permission_group_id: Int!
	user_permission_id: Int!
}

"aggregated selection of \"users.permission_group_user_permissions\""
type users_permission_group_user_permissions_aggregate {
	aggregate: users_permission_group_user_permissions_aggregate_fields
	nodes: [users_permission_group_user_permissions!]!
}

"aggregate fields of \"users.permission_group_user_permissions\""
type users_permission_group_user_permissions_aggregate_fields {
	avg: users_permission_group_user_permissions_avg_fields
	count(columns: [users_permission_group_user_permissions_select_column!], distinct: Boolean): Int
	max: users_permission_group_user_permissions_max_fields
	min: users_permission_group_user_permissions_min_fields
	stddev: users_permission_group_user_permissions_stddev_fields
	stddev_pop: users_permission_group_user_permissions_stddev_pop_fields
	stddev_samp: users_permission_group_user_permissions_stddev_samp_fields
	sum: users_permission_group_user_permissions_sum_fields
	var_pop: users_permission_group_user_permissions_var_pop_fields
	var_samp: users_permission_group_user_permissions_var_samp_fields
	variance: users_permission_group_user_permissions_variance_fields
}

"aggregate avg on columns"
type users_permission_group_user_permissions_avg_fields {
	id: Float
	user_permission_group_id: Float
	user_permission_id: Float
}

"aggregate max on columns"
type users_permission_group_user_permissions_max_fields {
	id: Int
	user_permission_group_id: Int
	user_permission_id: Int
}

"aggregate min on columns"
type users_permission_group_user_permissions_min_fields {
	id: Int
	user_permission_group_id: Int
	user_permission_id: Int
}

"response of any mutation on the table \"users.permission_group_user_permissions\""
type users_permission_group_user_permissions_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_permission_group_user_permissions!]!
}

"aggregate stddev on columns"
type users_permission_group_user_permissions_stddev_fields {
	id: Float
	user_permission_group_id: Float
	user_permission_id: Float
}

"aggregate stddev_pop on columns"
type users_permission_group_user_permissions_stddev_pop_fields {
	id: Float
	user_permission_group_id: Float
	user_permission_id: Float
}

"aggregate stddev_samp on columns"
type users_permission_group_user_permissions_stddev_samp_fields {
	id: Float
	user_permission_group_id: Float
	user_permission_id: Float
}

"aggregate sum on columns"
type users_permission_group_user_permissions_sum_fields {
	id: Int
	user_permission_group_id: Int
	user_permission_id: Int
}

"aggregate var_pop on columns"
type users_permission_group_user_permissions_var_pop_fields {
	id: Float
	user_permission_group_id: Float
	user_permission_id: Float
}

"aggregate var_samp on columns"
type users_permission_group_user_permissions_var_samp_fields {
	id: Float
	user_permission_group_id: Float
	user_permission_id: Float
}

"aggregate variance on columns"
type users_permission_group_user_permissions_variance_fields {
	id: Float
	user_permission_group_id: Float
	user_permission_id: Float
}

"columns and relationships of \"users.permission_groups\""
type users_permission_groups {
	created_at: timestamptz!
	description: String
	"An array relationship"
	group_user_permission_groups(
		"distinct select on columns"
		distinct_on: [users_group_user_permission_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_group_user_permission_groups_order_by!]
		"filter the rows returned"
		where: users_group_user_permission_groups_bool_exp
	): [users_group_user_permission_groups!]!
	"An aggregated array relationship"
	group_user_permission_groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_group_user_permission_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_group_user_permission_groups_order_by!]
		"filter the rows returned"
		where: users_group_user_permission_groups_bool_exp
	): users_group_user_permission_groups_aggregate!
	id: Int!
	label: String!
	"An array relationship"
	permission_group_user_permissions(
		"distinct select on columns"
		distinct_on: [users_permission_group_user_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_group_user_permissions_order_by!]
		"filter the rows returned"
		where: users_permission_group_user_permissions_bool_exp
	): [users_permission_group_user_permissions!]!
	"An aggregated array relationship"
	permission_group_user_permissions_aggregate(
		"distinct select on columns"
		distinct_on: [users_permission_group_user_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_group_user_permissions_order_by!]
		"filter the rows returned"
		where: users_permission_group_user_permissions_bool_exp
	): users_permission_group_user_permissions_aggregate!
	updated_at: timestamptz!
}

"aggregated selection of \"users.permission_groups\""
type users_permission_groups_aggregate {
	aggregate: users_permission_groups_aggregate_fields
	nodes: [users_permission_groups!]!
}

"aggregate fields of \"users.permission_groups\""
type users_permission_groups_aggregate_fields {
	avg: users_permission_groups_avg_fields
	count(columns: [users_permission_groups_select_column!], distinct: Boolean): Int
	max: users_permission_groups_max_fields
	min: users_permission_groups_min_fields
	stddev: users_permission_groups_stddev_fields
	stddev_pop: users_permission_groups_stddev_pop_fields
	stddev_samp: users_permission_groups_stddev_samp_fields
	sum: users_permission_groups_sum_fields
	var_pop: users_permission_groups_var_pop_fields
	var_samp: users_permission_groups_var_samp_fields
	variance: users_permission_groups_variance_fields
}

"aggregate avg on columns"
type users_permission_groups_avg_fields {
	id: Float
}

"aggregate max on columns"
type users_permission_groups_max_fields {
	created_at: timestamptz
	description: String
	id: Int
	label: String
	updated_at: timestamptz
}

"aggregate min on columns"
type users_permission_groups_min_fields {
	created_at: timestamptz
	description: String
	id: Int
	label: String
	updated_at: timestamptz
}

"response of any mutation on the table \"users.permission_groups\""
type users_permission_groups_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_permission_groups!]!
}

"aggregate stddev on columns"
type users_permission_groups_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type users_permission_groups_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type users_permission_groups_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type users_permission_groups_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type users_permission_groups_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type users_permission_groups_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type users_permission_groups_variance_fields {
	id: Float
}

"columns and relationships of \"users.permission_matrix_view\""
type users_permission_matrix_view {
	group_id: Int
	permission_group_id: Int
	permission_group_label: String
	permission_id: Int
	permission_label: String
}

"aggregated selection of \"users.permission_matrix_view\""
type users_permission_matrix_view_aggregate {
	aggregate: users_permission_matrix_view_aggregate_fields
	nodes: [users_permission_matrix_view!]!
}

"aggregate fields of \"users.permission_matrix_view\""
type users_permission_matrix_view_aggregate_fields {
	avg: users_permission_matrix_view_avg_fields
	count(columns: [users_permission_matrix_view_select_column!], distinct: Boolean): Int
	max: users_permission_matrix_view_max_fields
	min: users_permission_matrix_view_min_fields
	stddev: users_permission_matrix_view_stddev_fields
	stddev_pop: users_permission_matrix_view_stddev_pop_fields
	stddev_samp: users_permission_matrix_view_stddev_samp_fields
	sum: users_permission_matrix_view_sum_fields
	var_pop: users_permission_matrix_view_var_pop_fields
	var_samp: users_permission_matrix_view_var_samp_fields
	variance: users_permission_matrix_view_variance_fields
}

"aggregate avg on columns"
type users_permission_matrix_view_avg_fields {
	group_id: Float
	permission_group_id: Float
	permission_id: Float
}

"aggregate max on columns"
type users_permission_matrix_view_max_fields {
	group_id: Int
	permission_group_id: Int
	permission_group_label: String
	permission_id: Int
	permission_label: String
}

"aggregate min on columns"
type users_permission_matrix_view_min_fields {
	group_id: Int
	permission_group_id: Int
	permission_group_label: String
	permission_id: Int
	permission_label: String
}

"response of any mutation on the table \"users.permission_matrix_view\""
type users_permission_matrix_view_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_permission_matrix_view!]!
}

"aggregate stddev on columns"
type users_permission_matrix_view_stddev_fields {
	group_id: Float
	permission_group_id: Float
	permission_id: Float
}

"aggregate stddev_pop on columns"
type users_permission_matrix_view_stddev_pop_fields {
	group_id: Float
	permission_group_id: Float
	permission_id: Float
}

"aggregate stddev_samp on columns"
type users_permission_matrix_view_stddev_samp_fields {
	group_id: Float
	permission_group_id: Float
	permission_id: Float
}

"aggregate sum on columns"
type users_permission_matrix_view_sum_fields {
	group_id: Int
	permission_group_id: Int
	permission_id: Int
}

"aggregate var_pop on columns"
type users_permission_matrix_view_var_pop_fields {
	group_id: Float
	permission_group_id: Float
	permission_id: Float
}

"aggregate var_samp on columns"
type users_permission_matrix_view_var_samp_fields {
	group_id: Float
	permission_group_id: Float
	permission_id: Float
}

"aggregate variance on columns"
type users_permission_matrix_view_variance_fields {
	group_id: Float
	permission_group_id: Float
	permission_id: Float
}

"columns and relationships of \"users.permissions\""
type users_permissions {
	created_at: timestamptz!
	description: String
	id: Int!
	label: String!
	"An array relationship"
	permission_group_user_permissions(
		"distinct select on columns"
		distinct_on: [users_permission_group_user_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_group_user_permissions_order_by!]
		"filter the rows returned"
		where: users_permission_group_user_permissions_bool_exp
	): [users_permission_group_user_permissions!]!
	"An aggregated array relationship"
	permission_group_user_permissions_aggregate(
		"distinct select on columns"
		distinct_on: [users_permission_group_user_permissions_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_group_user_permissions_order_by!]
		"filter the rows returned"
		where: users_permission_group_user_permissions_bool_exp
	): users_permission_group_user_permissions_aggregate!
	updated_at: timestamptz!
}

"aggregated selection of \"users.permissions\""
type users_permissions_aggregate {
	aggregate: users_permissions_aggregate_fields
	nodes: [users_permissions!]!
}

"aggregate fields of \"users.permissions\""
type users_permissions_aggregate_fields {
	avg: users_permissions_avg_fields
	count(columns: [users_permissions_select_column!], distinct: Boolean): Int
	max: users_permissions_max_fields
	min: users_permissions_min_fields
	stddev: users_permissions_stddev_fields
	stddev_pop: users_permissions_stddev_pop_fields
	stddev_samp: users_permissions_stddev_samp_fields
	sum: users_permissions_sum_fields
	var_pop: users_permissions_var_pop_fields
	var_samp: users_permissions_var_samp_fields
	variance: users_permissions_variance_fields
}

"aggregate avg on columns"
type users_permissions_avg_fields {
	id: Float
}

"aggregate max on columns"
type users_permissions_max_fields {
	created_at: timestamptz
	description: String
	id: Int
	label: String
	updated_at: timestamptz
}

"aggregate min on columns"
type users_permissions_min_fields {
	created_at: timestamptz
	description: String
	id: Int
	label: String
	updated_at: timestamptz
}

"response of any mutation on the table \"users.permissions\""
type users_permissions_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_permissions!]!
}

"aggregate stddev on columns"
type users_permissions_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type users_permissions_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type users_permissions_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type users_permissions_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type users_permissions_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type users_permissions_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type users_permissions_variance_fields {
	id: Float
}

"columns and relationships of \"users.profile_classifications\""
type users_profile_classifications {
	id: uuid!
	key: String!
	"An object relationship"
	profile: users_profiles!
	profile_id: uuid!
}

"aggregated selection of \"users.profile_classifications\""
type users_profile_classifications_aggregate {
	aggregate: users_profile_classifications_aggregate_fields
	nodes: [users_profile_classifications!]!
}

"aggregate fields of \"users.profile_classifications\""
type users_profile_classifications_aggregate_fields {
	count(columns: [users_profile_classifications_select_column!], distinct: Boolean): Int
	max: users_profile_classifications_max_fields
	min: users_profile_classifications_min_fields
}

"aggregate max on columns"
type users_profile_classifications_max_fields {
	id: uuid
	key: String
	profile_id: uuid
}

"aggregate min on columns"
type users_profile_classifications_min_fields {
	id: uuid
	key: String
	profile_id: uuid
}

"response of any mutation on the table \"users.profile_classifications\""
type users_profile_classifications_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_profile_classifications!]!
}

"columns and relationships of \"users.profile_contexts\""
type users_profile_contexts {
	id: uuid!
	key: String!
	"An object relationship"
	profile: users_profiles!
	profile_id: uuid!
}

"aggregated selection of \"users.profile_contexts\""
type users_profile_contexts_aggregate {
	aggregate: users_profile_contexts_aggregate_fields
	nodes: [users_profile_contexts!]!
}

"aggregate fields of \"users.profile_contexts\""
type users_profile_contexts_aggregate_fields {
	count(columns: [users_profile_contexts_select_column!], distinct: Boolean): Int
	max: users_profile_contexts_max_fields
	min: users_profile_contexts_min_fields
}

"aggregate max on columns"
type users_profile_contexts_max_fields {
	id: uuid
	key: String
	profile_id: uuid
}

"aggregate min on columns"
type users_profile_contexts_min_fields {
	id: uuid
	key: String
	profile_id: uuid
}

"response of any mutation on the table \"users.profile_contexts\""
type users_profile_contexts_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_profile_contexts!]!
}

"""
Tabel voor optionele flags en attributen van een gebruikersprofiel.


columns and relationships of "users.profile_flags"
"""
type users_profile_flags {
	created_at: timestamptz!
	"An object relationship"
	enum_profile_flag: lookup_enum_profile_flags!
	id: Int!
	key: lookup_enum_profile_flags_enum!
	profile_id: uuid!
	updated_at: timestamptz!
}

"aggregated selection of \"users.profile_flags\""
type users_profile_flags_aggregate {
	aggregate: users_profile_flags_aggregate_fields
	nodes: [users_profile_flags!]!
}

"aggregate fields of \"users.profile_flags\""
type users_profile_flags_aggregate_fields {
	avg: users_profile_flags_avg_fields
	count(columns: [users_profile_flags_select_column!], distinct: Boolean): Int
	max: users_profile_flags_max_fields
	min: users_profile_flags_min_fields
	stddev: users_profile_flags_stddev_fields
	stddev_pop: users_profile_flags_stddev_pop_fields
	stddev_samp: users_profile_flags_stddev_samp_fields
	sum: users_profile_flags_sum_fields
	var_pop: users_profile_flags_var_pop_fields
	var_samp: users_profile_flags_var_samp_fields
	variance: users_profile_flags_variance_fields
}

"aggregate avg on columns"
type users_profile_flags_avg_fields {
	id: Float
}

"aggregate max on columns"
type users_profile_flags_max_fields {
	created_at: timestamptz
	id: Int
	profile_id: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type users_profile_flags_min_fields {
	created_at: timestamptz
	id: Int
	profile_id: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"users.profile_flags\""
type users_profile_flags_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_profile_flags!]!
}

"aggregate stddev on columns"
type users_profile_flags_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type users_profile_flags_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type users_profile_flags_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type users_profile_flags_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type users_profile_flags_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type users_profile_flags_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type users_profile_flags_variance_fields {
	id: Float
}

"columns and relationships of \"users.profile_organizations\""
type users_profile_organizations {
	id: uuid!
	"An object relationship"
	organization: shared_ldap_organizations
	organization_id: String!
	"An object relationship"
	profile: users_profiles!
	profile_id: uuid!
	unit_id: String
}

"aggregated selection of \"users.profile_organizations\""
type users_profile_organizations_aggregate {
	aggregate: users_profile_organizations_aggregate_fields
	nodes: [users_profile_organizations!]!
}

"aggregate fields of \"users.profile_organizations\""
type users_profile_organizations_aggregate_fields {
	count(columns: [users_profile_organizations_select_column!], distinct: Boolean): Int
	max: users_profile_organizations_max_fields
	min: users_profile_organizations_min_fields
}

"aggregate max on columns"
type users_profile_organizations_max_fields {
	id: uuid
	organization_id: String
	profile_id: uuid
	unit_id: String
}

"aggregate min on columns"
type users_profile_organizations_min_fields {
	id: uuid
	organization_id: String
	profile_id: uuid
	unit_id: String
}

"response of any mutation on the table \"users.profile_organizations\""
type users_profile_organizations_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_profile_organizations!]!
}

"""
Tabel voor optionele voorkeuren of instellingskeuzes gekoppeld aan een gebruikersprofiel.


columns and relationships of "users.profile_preferences"
"""
type users_profile_preferences {
	created_at: timestamptz!
	"An object relationship"
	enum_profile_preferences_key: lookup_enum_profile_preferences_keys!
	id: Int!
	key: lookup_enum_profile_preferences_keys_enum!
	profile_id: uuid!
	updated_at: timestamptz!
	values("JSON select path" path: String): jsonb
}

"aggregated selection of \"users.profile_preferences\""
type users_profile_preferences_aggregate {
	aggregate: users_profile_preferences_aggregate_fields
	nodes: [users_profile_preferences!]!
}

"aggregate fields of \"users.profile_preferences\""
type users_profile_preferences_aggregate_fields {
	avg: users_profile_preferences_avg_fields
	count(columns: [users_profile_preferences_select_column!], distinct: Boolean): Int
	max: users_profile_preferences_max_fields
	min: users_profile_preferences_min_fields
	stddev: users_profile_preferences_stddev_fields
	stddev_pop: users_profile_preferences_stddev_pop_fields
	stddev_samp: users_profile_preferences_stddev_samp_fields
	sum: users_profile_preferences_sum_fields
	var_pop: users_profile_preferences_var_pop_fields
	var_samp: users_profile_preferences_var_samp_fields
	variance: users_profile_preferences_variance_fields
}

"aggregate avg on columns"
type users_profile_preferences_avg_fields {
	id: Float
}

"aggregate max on columns"
type users_profile_preferences_max_fields {
	created_at: timestamptz
	id: Int
	profile_id: uuid
	updated_at: timestamptz
}

"aggregate min on columns"
type users_profile_preferences_min_fields {
	created_at: timestamptz
	id: Int
	profile_id: uuid
	updated_at: timestamptz
}

"response of any mutation on the table \"users.profile_preferences\""
type users_profile_preferences_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_profile_preferences!]!
}

"aggregate stddev on columns"
type users_profile_preferences_stddev_fields {
	id: Float
}

"aggregate stddev_pop on columns"
type users_profile_preferences_stddev_pop_fields {
	id: Float
}

"aggregate stddev_samp on columns"
type users_profile_preferences_stddev_samp_fields {
	id: Float
}

"aggregate sum on columns"
type users_profile_preferences_sum_fields {
	id: Int
}

"aggregate var_pop on columns"
type users_profile_preferences_var_pop_fields {
	id: Float
}

"aggregate var_samp on columns"
type users_profile_preferences_var_samp_fields {
	id: Float
}

"aggregate variance on columns"
type users_profile_preferences_variance_fields {
	id: Float
}

"""
Reference table to link user by profile to one or more user groups


columns and relationships of "users.profile_user_groups"
"""
type users_profile_user_groups {
	"An object relationship"
	group: users_groups!
	"An array relationship"
	groups(
		"distinct select on columns"
		distinct_on: [users_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_groups_order_by!]
		"filter the rows returned"
		where: users_groups_bool_exp
	): [users_groups!]!
	"An aggregated array relationship"
	groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_groups_order_by!]
		"filter the rows returned"
		where: users_groups_bool_exp
	): users_groups_aggregate!
	id: Int!
	"An object relationship"
	profile: users_profiles!
	user_group_id: Int!
	user_profile_id: uuid!
}

"aggregated selection of \"users.profile_user_groups\""
type users_profile_user_groups_aggregate {
	aggregate: users_profile_user_groups_aggregate_fields
	nodes: [users_profile_user_groups!]!
}

"aggregate fields of \"users.profile_user_groups\""
type users_profile_user_groups_aggregate_fields {
	avg: users_profile_user_groups_avg_fields
	count(columns: [users_profile_user_groups_select_column!], distinct: Boolean): Int
	max: users_profile_user_groups_max_fields
	min: users_profile_user_groups_min_fields
	stddev: users_profile_user_groups_stddev_fields
	stddev_pop: users_profile_user_groups_stddev_pop_fields
	stddev_samp: users_profile_user_groups_stddev_samp_fields
	sum: users_profile_user_groups_sum_fields
	var_pop: users_profile_user_groups_var_pop_fields
	var_samp: users_profile_user_groups_var_samp_fields
	variance: users_profile_user_groups_variance_fields
}

"aggregate avg on columns"
type users_profile_user_groups_avg_fields {
	id: Float
	user_group_id: Float
}

"aggregate max on columns"
type users_profile_user_groups_max_fields {
	id: Int
	user_group_id: Int
	user_profile_id: uuid
}

"aggregate min on columns"
type users_profile_user_groups_min_fields {
	id: Int
	user_group_id: Int
	user_profile_id: uuid
}

"response of any mutation on the table \"users.profile_user_groups\""
type users_profile_user_groups_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_profile_user_groups!]!
}

"aggregate stddev on columns"
type users_profile_user_groups_stddev_fields {
	id: Float
	user_group_id: Float
}

"aggregate stddev_pop on columns"
type users_profile_user_groups_stddev_pop_fields {
	id: Float
	user_group_id: Float
}

"aggregate stddev_samp on columns"
type users_profile_user_groups_stddev_samp_fields {
	id: Float
	user_group_id: Float
}

"aggregate sum on columns"
type users_profile_user_groups_sum_fields {
	id: Int
	user_group_id: Int
}

"aggregate var_pop on columns"
type users_profile_user_groups_var_pop_fields {
	id: Float
	user_group_id: Float
}

"aggregate var_samp on columns"
type users_profile_user_groups_var_samp_fields {
	id: Float
	user_group_id: Float
}

"aggregate variance on columns"
type users_profile_user_groups_variance_fields {
	id: Float
	user_group_id: Float
}

"""
Een gebruiker kan een of meer profielen hebben. Een profiel bevat de profielgebonden informatie zoals displayName,  LOM, etc.


columns and relationships of "users.profiles"
"""
type users_profiles {
	alias: String
	"secundair e-mailadres voor communicatie"
	alternative_email: String
	"An array relationship"
	assignment_labels(
		"distinct select on columns"
		distinct_on: [app_assignment_labels_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_labels_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_labels_v2_bool_exp
	): [app_assignment_labels_v2!]!
	"An aggregated array relationship"
	assignment_labels_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_labels_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_labels_v2_order_by!]
		"filter the rows returned"
		where: app_assignment_labels_v2_bool_exp
	): app_assignment_labels_v2_aggregate!
	"An array relationship"
	assignment_tags(
		"distinct select on columns"
		distinct_on: [app_assignment_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_labels_order_by!]
		"filter the rows returned"
		where: app_assignment_labels_bool_exp
	): [app_assignment_labels!]!
	"An aggregated array relationship"
	assignment_tags_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignment_labels_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignment_labels_order_by!]
		"filter the rows returned"
		where: app_assignment_labels_bool_exp
	): app_assignment_labels_aggregate!
	"An array relationship"
	assignments(
		"distinct select on columns"
		distinct_on: [app_assignments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_order_by!]
		"filter the rows returned"
		where: app_assignments_bool_exp
	): [app_assignments!]!
	"An aggregated array relationship"
	assignments_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_order_by!]
		"filter the rows returned"
		where: app_assignments_bool_exp
	): app_assignments_aggregate!
	"An array relationship"
	assignments_v2(
		"distinct select on columns"
		distinct_on: [app_assignments_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_v2_order_by!]
		"filter the rows returned"
		where: app_assignments_v2_bool_exp
	): [app_assignments_v2!]!
	"An aggregated array relationship"
	assignments_v2_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignments_v2_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_v2_order_by!]
		"filter the rows returned"
		where: app_assignments_v2_bool_exp
	): app_assignments_v2_aggregate!
	avatar: String
	bio: String
	"An array relationship"
	bookmark_searches(
		"distinct select on columns"
		distinct_on: [app_search_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_search_bookmarks_order_by!]
		"filter the rows returned"
		where: app_search_bookmarks_bool_exp
	): [app_search_bookmarks!]!
	"An aggregated array relationship"
	bookmark_searches_aggregate(
		"distinct select on columns"
		distinct_on: [app_search_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_search_bookmarks_order_by!]
		"filter the rows returned"
		where: app_search_bookmarks_bool_exp
	): app_search_bookmarks_aggregate!
	"categorie gebruiker, in hoofdzaak voor uitzonderingen"
	business_category: String
	"An array relationship"
	collection_bookmarks(
		"distinct select on columns"
		distinct_on: [app_collection_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_bookmarks_order_by!]
		"filter the rows returned"
		where: app_collection_bookmarks_bool_exp
	): [app_collection_bookmarks!]!
	"An aggregated array relationship"
	collection_bookmarks_aggregate(
		"distinct select on columns"
		distinct_on: [app_collection_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collection_bookmarks_order_by!]
		"filter the rows returned"
		where: app_collection_bookmarks_bool_exp
	): app_collection_bookmarks_aggregate!
	"An array relationship"
	collections(
		"distinct select on columns"
		distinct_on: [app_collections_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collections_order_by!]
		"filter the rows returned"
		where: app_collections_bool_exp
	): [app_collections!]!
	"An aggregated array relationship"
	collections_aggregate(
		"distinct select on columns"
		distinct_on: [app_collections_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collections_order_by!]
		"filter the rows returned"
		where: app_collections_bool_exp
	): app_collections_aggregate!
	company_id: String
	created_at: timestamptz!
	"An array relationship"
	email_preferences(
		"distinct select on columns"
		distinct_on: [users_email_preferences_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_email_preferences_order_by!]
		"filter the rows returned"
		where: users_email_preferences_bool_exp
	): [users_email_preferences!]!
	"An aggregated array relationship"
	email_preferences_aggregate(
		"distinct select on columns"
		distinct_on: [users_email_preferences_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_email_preferences_order_by!]
		"filter the rows returned"
		where: users_email_preferences_bool_exp
	): users_email_preferences_aggregate!
	"Een gebruiker kan een of meer profielen hebben"
	id: uuid!
	is_deleted: Boolean!
	is_exception: Boolean!
	"An array relationship"
	item_bookmarks(
		"distinct select on columns"
		distinct_on: [app_item_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_bookmarks_order_by!]
		"filter the rows returned"
		where: app_item_bookmarks_bool_exp
	): [app_item_bookmarks!]!
	"An aggregated array relationship"
	item_bookmarks_aggregate(
		"distinct select on columns"
		distinct_on: [app_item_bookmarks_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_item_bookmarks_order_by!]
		"filter the rows returned"
		where: app_item_bookmarks_bool_exp
	): app_item_bookmarks_aggregate!
	"An array relationship"
	notifications(
		"distinct select on columns"
		distinct_on: [users_notifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_notifications_order_by!]
		"filter the rows returned"
		where: users_notifications_bool_exp
	): [users_notifications!]!
	"An aggregated array relationship"
	notifications_aggregate(
		"distinct select on columns"
		distinct_on: [users_notifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_notifications_order_by!]
		"filter the rows returned"
		where: users_notifications_bool_exp
	): users_notifications_aggregate!
	"An object relationship"
	organisation: shared_organisations
	"An array relationship"
	profile_classifications(
		"distinct select on columns"
		distinct_on: [users_profile_classifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_classifications_order_by!]
		"filter the rows returned"
		where: users_profile_classifications_bool_exp
	): [users_profile_classifications!]!
	"An aggregated array relationship"
	profile_classifications_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_classifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_classifications_order_by!]
		"filter the rows returned"
		where: users_profile_classifications_bool_exp
	): users_profile_classifications_aggregate!
	"An array relationship"
	profile_contexts(
		"distinct select on columns"
		distinct_on: [users_profile_contexts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_contexts_order_by!]
		"filter the rows returned"
		where: users_profile_contexts_bool_exp
	): [users_profile_contexts!]!
	"An aggregated array relationship"
	profile_contexts_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_contexts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_contexts_order_by!]
		"filter the rows returned"
		where: users_profile_contexts_bool_exp
	): users_profile_contexts_aggregate!
	"An array relationship"
	profile_flags(
		"distinct select on columns"
		distinct_on: [users_profile_flags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_flags_order_by!]
		"filter the rows returned"
		where: users_profile_flags_bool_exp
	): [users_profile_flags!]!
	"An aggregated array relationship"
	profile_flags_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_flags_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_flags_order_by!]
		"filter the rows returned"
		where: users_profile_flags_bool_exp
	): users_profile_flags_aggregate!
	"An array relationship"
	profile_organizations(
		"distinct select on columns"
		distinct_on: [users_profile_organizations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_organizations_order_by!]
		"filter the rows returned"
		where: users_profile_organizations_bool_exp
	): [users_profile_organizations!]!
	"An aggregated array relationship"
	profile_organizations_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_organizations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_organizations_order_by!]
		"filter the rows returned"
		where: users_profile_organizations_bool_exp
	): users_profile_organizations_aggregate!
	"An array relationship"
	profile_preferences(
		"distinct select on columns"
		distinct_on: [users_profile_preferences_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_preferences_order_by!]
		"filter the rows returned"
		where: users_profile_preferences_bool_exp
	): [users_profile_preferences!]!
	"An aggregated array relationship"
	profile_preferences_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_preferences_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_preferences_order_by!]
		"filter the rows returned"
		where: users_profile_preferences_bool_exp
	): users_profile_preferences_aggregate!
	"An object relationship"
	profile_user_group: users_profile_user_groups
	"An array relationship"
	profile_user_groups(
		"distinct select on columns"
		distinct_on: [users_profile_user_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_user_groups_order_by!]
		"filter the rows returned"
		where: users_profile_user_groups_bool_exp
	): [users_profile_user_groups!]!
	"An aggregated array relationship"
	profile_user_groups_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_user_groups_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_user_groups_order_by!]
		"filter the rows returned"
		where: users_profile_user_groups_bool_exp
	): users_profile_user_groups_aggregate!
	stamboek: String
	title: String
	updated_at: timestamptz!
	user_id: uuid
	"An object relationship"
	usersByuserId: shared_users
}

"aggregated selection of \"users.profiles\""
type users_profiles_aggregate {
	aggregate: users_profiles_aggregate_fields
	nodes: [users_profiles!]!
}

"aggregate fields of \"users.profiles\""
type users_profiles_aggregate_fields {
	count(columns: [users_profiles_select_column!], distinct: Boolean): Int
	max: users_profiles_max_fields
	min: users_profiles_min_fields
}

"aggregate max on columns"
type users_profiles_max_fields {
	alias: String
	alternative_email: String
	avatar: String
	bio: String
	business_category: String
	company_id: String
	created_at: timestamptz
	id: uuid
	stamboek: String
	title: String
	updated_at: timestamptz
	user_id: uuid
}

"aggregate min on columns"
type users_profiles_min_fields {
	alias: String
	alternative_email: String
	avatar: String
	bio: String
	business_category: String
	company_id: String
	created_at: timestamptz
	id: uuid
	stamboek: String
	title: String
	updated_at: timestamptz
	user_id: uuid
}

"response of any mutation on the table \"users.profiles\""
type users_profiles_mutation_response {
	"number of affected rows by the mutation"
	affected_rows: Int!
	"data of the affected rows by the mutation"
	returning: [users_profiles!]!
}

"columns and relationships of \"users.summary_view\""
type users_summary_view {
	acc_created_at: timestamptz
	acc_updated_at: timestamptz
	"An array relationship"
	assignments(
		"distinct select on columns"
		distinct_on: [app_assignments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_order_by!]
		"filter the rows returned"
		where: app_assignments_bool_exp
	): [app_assignments!]!
	"An aggregated array relationship"
	assignments_aggregate(
		"distinct select on columns"
		distinct_on: [app_assignments_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_assignments_order_by!]
		"filter the rows returned"
		where: app_assignments_bool_exp
	): app_assignments_aggregate!
	"An array relationship"
	audits(
		"distinct select on columns"
		distinct_on: [users_audit_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_audit_log_order_by!]
		"filter the rows returned"
		where: users_audit_log_bool_exp
	): [users_audit_log!]!
	"An aggregated array relationship"
	audits_aggregate(
		"distinct select on columns"
		distinct_on: [users_audit_log_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_audit_log_order_by!]
		"filter the rows returned"
		where: users_audit_log_bool_exp
	): users_audit_log_aggregate!
	"An object relationship"
	blocked_at: shared_user_last_blocked
	business_category: String
	"An array relationship"
	classifications(
		"distinct select on columns"
		distinct_on: [users_profile_classifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_classifications_order_by!]
		"filter the rows returned"
		where: users_profile_classifications_bool_exp
	): [users_profile_classifications!]!
	"An aggregated array relationship"
	classifications_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_classifications_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_classifications_order_by!]
		"filter the rows returned"
		where: users_profile_classifications_bool_exp
	): users_profile_classifications_aggregate!
	"An array relationship"
	collections(
		"distinct select on columns"
		distinct_on: [app_collections_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collections_order_by!]
		"filter the rows returned"
		where: app_collections_bool_exp
	): [app_collections!]!
	"An aggregated array relationship"
	collections_aggregate(
		"distinct select on columns"
		distinct_on: [app_collections_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [app_collections_order_by!]
		"filter the rows returned"
		where: app_collections_bool_exp
	): app_collections_aggregate!
	company_id: String
	company_name: String
	"An array relationship"
	contexts(
		"distinct select on columns"
		distinct_on: [users_profile_contexts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_contexts_order_by!]
		"filter the rows returned"
		where: users_profile_contexts_bool_exp
	): [users_profile_contexts!]!
	"An aggregated array relationship"
	contexts_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_contexts_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_contexts_order_by!]
		"filter the rows returned"
		where: users_profile_contexts_bool_exp
	): users_profile_contexts_aggregate!
	first_name: String
	first_name_lower: String
	full_name: String
	group_id: Int
	group_name: String
	"An array relationship"
	idps(
		"distinct select on columns"
		distinct_on: [users_idp_map_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_idp_map_order_by!]
		"filter the rows returned"
		where: users_idp_map_bool_exp
	): [users_idp_map!]!
	"An aggregated array relationship"
	idps_aggregate(
		"distinct select on columns"
		distinct_on: [users_idp_map_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_idp_map_order_by!]
		"filter the rows returned"
		where: users_idp_map_bool_exp
	): users_idp_map_aggregate!
	is_blocked: Boolean
	is_deleted: Boolean
	is_exception: Boolean
	last_access_at: timestamptz
	last_name: String
	last_name_lower: String
	mail: String
	"An array relationship"
	organisations(
		"distinct select on columns"
		distinct_on: [users_profile_organizations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_organizations_order_by!]
		"filter the rows returned"
		where: users_profile_organizations_bool_exp
	): [users_profile_organizations!]!
	"An aggregated array relationship"
	organisations_aggregate(
		"distinct select on columns"
		distinct_on: [users_profile_organizations_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_profile_organizations_order_by!]
		"filter the rows returned"
		where: users_profile_organizations_bool_exp
	): users_profile_organizations_aggregate!
	"An array relationship"
	permissions(
		"distinct select on columns"
		distinct_on: [users_permission_matrix_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_matrix_view_order_by!]
		"filter the rows returned"
		where: users_permission_matrix_view_bool_exp
	): [users_permission_matrix_view!]!
	"An aggregated array relationship"
	permissions_aggregate(
		"distinct select on columns"
		distinct_on: [users_permission_matrix_view_select_column!]
		"limit the number of rows returned"
		limit: Int
		"skip the first n rows. Use only with order_by"
		offset: Int
		"sort the rows by one or more columns"
		order_by: [users_permission_matrix_view_order_by!]
		"filter the rows returned"
		where: users_permission_matrix_view_bool_exp
	): users_permission_matrix_view_aggregate!
	pro_created_at: timestamptz
	pro_updated_at: timestamptz
	"An object relationship"
	profile: users_profiles
	profile_id: uuid
	role_id: Int
	role_name: String
	stamboek: String
	"An object relationship"
	unblocked_at: shared_user_last_unblocked
	"An object relationship"
	user: shared_users
	user_id: uuid
}

"aggregated selection of \"users.summary_view\""
type users_summary_view_aggregate {
	aggregate: users_summary_view_aggregate_fields
	nodes: [users_summary_view!]!
}

"aggregate fields of \"users.summary_view\""
type users_summary_view_aggregate_fields {
	avg: users_summary_view_avg_fields
	count(columns: [users_summary_view_select_column!], distinct: Boolean): Int
	max: users_summary_view_max_fields
	min: users_summary_view_min_fields
	stddev: users_summary_view_stddev_fields
	stddev_pop: users_summary_view_stddev_pop_fields
	stddev_samp: users_summary_view_stddev_samp_fields
	sum: users_summary_view_sum_fields
	var_pop: users_summary_view_var_pop_fields
	var_samp: users_summary_view_var_samp_fields
	variance: users_summary_view_variance_fields
}

"aggregate avg on columns"
type users_summary_view_avg_fields {
	group_id: Float
	role_id: Float
}

"aggregate max on columns"
type users_summary_view_max_fields {
	acc_created_at: timestamptz
	acc_updated_at: timestamptz
	business_category: String
	company_id: String
	company_name: String
	first_name: String
	first_name_lower: String
	full_name: String
	group_id: Int
	group_name: String
	last_access_at: timestamptz
	last_name: String
	last_name_lower: String
	mail: String
	pro_created_at: timestamptz
	pro_updated_at: timestamptz
	profile_id: uuid
	role_id: Int
	role_name: String
	stamboek: String
	user_id: uuid
}

"aggregate min on columns"
type users_summary_view_min_fields {
	acc_created_at: timestamptz
	acc_updated_at: timestamptz
	business_category: String
	company_id: String
	company_name: String
	first_name: String
	first_name_lower: String
	full_name: String
	group_id: Int
	group_name: String
	last_access_at: timestamptz
	last_name: String
	last_name_lower: String
	mail: String
	pro_created_at: timestamptz
	pro_updated_at: timestamptz
	profile_id: uuid
	role_id: Int
	role_name: String
	stamboek: String
	user_id: uuid
}

"aggregate stddev on columns"
type users_summary_view_stddev_fields {
	group_id: Float
	role_id: Float
}

"aggregate stddev_pop on columns"
type users_summary_view_stddev_pop_fields {
	group_id: Float
	role_id: Float
}

"aggregate stddev_samp on columns"
type users_summary_view_stddev_samp_fields {
	group_id: Float
	role_id: Float
}

"aggregate sum on columns"
type users_summary_view_sum_fields {
	group_id: Int
	role_id: Int
}

"aggregate var_pop on columns"
type users_summary_view_var_pop_fields {
	group_id: Float
	role_id: Float
}

"aggregate var_samp on columns"
type users_summary_view_var_samp_fields {
	group_id: Float
	role_id: Float
}

"aggregate variance on columns"
type users_summary_view_variance_fields {
	group_id: Float
	role_id: Float
}

"unique or primary key constraints on table \"app.assignment_assignment_tags\""
enum app_assignment_assignment_tags_constraint {
	"unique or primary key constraint"
	assignment_asiignment_tags_pkey
	"unique or primary key constraint"
	assignment_assignment_tags_assignment_uuid_assignment_tag_id_ke
}

"select columns of table \"app.assignment_assignment_tags\""
enum app_assignment_assignment_tags_select_column {
	"column name"
	assignment_tag_id
	"column name"
	assignment_uuid
	"column name"
	id
}

"update columns of table \"app.assignment_assignment_tags\""
enum app_assignment_assignment_tags_update_column {
	"column name"
	assignment_tag_id
	"column name"
	assignment_uuid
	"column name"
	id
}

"unique or primary key constraints on table \"app.assignment_blocks_v2\""
enum app_assignment_blocks_v2_constraint {
	"unique or primary key constraint"
	assignment_blocks_v2_pkey
}

"select columns of table \"app.assignment_blocks_v2\""
enum app_assignment_blocks_v2_select_column {
	"column name"
	assignment_id
	"column name"
	created_at
	"column name"
	custom_description
	"column name"
	custom_title
	"column name"
	end_oc
	"column name"
	fragment_id
	"column name"
	id
	"column name"
	is_deleted
	"column name"
	original_description
	"column name"
	original_title
	"column name"
	position
	"column name"
	start_oc
	"column name"
	thumbnail_path
	"column name"
	type
	"column name"
	updated_at
	"column name"
	use_custom_fields
}

"update columns of table \"app.assignment_blocks_v2\""
enum app_assignment_blocks_v2_update_column {
	"column name"
	assignment_id
	"column name"
	created_at
	"column name"
	custom_description
	"column name"
	custom_title
	"column name"
	end_oc
	"column name"
	fragment_id
	"column name"
	id
	"column name"
	is_deleted
	"column name"
	original_description
	"column name"
	original_title
	"column name"
	position
	"column name"
	start_oc
	"column name"
	thumbnail_path
	"column name"
	type
	"column name"
	updated_at
	"column name"
	use_custom_fields
}

"unique or primary key constraints on table \"app.assignment_labels\""
enum app_assignment_labels_constraint {
	"unique or primary key constraint"
	assignment_tags_pkey
}

"select columns of table \"app.assignment_labels\""
enum app_assignment_labels_select_column {
	"column name"
	color_enum_value
	"column name"
	color_override
	"column name"
	id
	"column name"
	label
	"column name"
	owner_profile_id
}

"update columns of table \"app.assignment_labels\""
enum app_assignment_labels_update_column {
	"column name"
	color_enum_value
	"column name"
	color_override
	"column name"
	id
	"column name"
	label
	"column name"
	owner_profile_id
}

"unique or primary key constraints on table \"app.assignment_labels_v2\""
enum app_assignment_labels_v2_constraint {
	"unique or primary key constraint"
	assignment_labels_v2_pkey
}

"select columns of table \"app.assignment_labels_v2\""
enum app_assignment_labels_v2_select_column {
	"column name"
	color_enum_value
	"column name"
	color_override
	"column name"
	id
	"column name"
	label
	"column name"
	owner_profile_id
	"column name"
	type
}

"update columns of table \"app.assignment_labels_v2\""
enum app_assignment_labels_v2_update_column {
	"column name"
	color_enum_value
	"column name"
	color_override
	"column name"
	id
	"column name"
	label
	"column name"
	owner_profile_id
	"column name"
	type
}

"unique or primary key constraints on table \"app.assignment_responses\""
enum app_assignment_responses_constraint {
	"unique or primary key constraint"
	assignment_responses_pkey
}

"select columns of table \"app.assignment_responses\""
enum app_assignment_responses_select_column {
	"column name"
	assignment_uuid
	"column name"
	collection_uuid
	"column name"
	created_at
	"column name"
	id
	"column name"
	is_archived
	"column name"
	owner_profile_ids
	"column name"
	submitted_at
	"column name"
	updated_at
}

"update columns of table \"app.assignment_responses\""
enum app_assignment_responses_update_column {
	"column name"
	assignment_uuid
	"column name"
	collection_uuid
	"column name"
	created_at
	"column name"
	id
	"column name"
	is_archived
	"column name"
	owner_profile_ids
	"column name"
	submitted_at
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.assignment_responses_v2\""
enum app_assignment_responses_v2_constraint {
	"unique or primary key constraint"
	assignment_responses_v2_pkey
}

"select columns of table \"app.assignment_responses_v2\""
enum app_assignment_responses_v2_select_column {
	"column name"
	assignment_id
	"column name"
	collection_title
	"column name"
	created_at
	"column name"
	id
	"column name"
	owner_profile_id
	"column name"
	updated_at
}

"update columns of table \"app.assignment_responses_v2\""
enum app_assignment_responses_v2_update_column {
	"column name"
	assignment_id
	"column name"
	collection_title
	"column name"
	created_at
	"column name"
	id
	"column name"
	owner_profile_id
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.assignment_v2_views\""
enum app_assignment_v2_views_constraint {
	"unique or primary key constraint"
	assignment_v2_views_assignment_uuid_key
	"unique or primary key constraint"
	assignment_v2_views_pkey
}

"select columns of table \"app.assignment_v2_views\""
enum app_assignment_v2_views_select_column {
	"column name"
	assignment_uuid
	"column name"
	count
	"column name"
	created_at
	"column name"
	id
	"column name"
	updated_at
}

"update columns of table \"app.assignment_v2_views\""
enum app_assignment_v2_views_update_column {
	"column name"
	assignment_uuid
	"column name"
	count
	"column name"
	created_at
	"column name"
	id
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.assignments\""
enum app_assignments_constraint {
	"unique or primary key constraint"
	assignments_pkey
	"unique or primary key constraint"
	assignments_uuid_key
}

"select columns of table \"app.assignments\""
enum app_assignments_select_column {
	"column name"
	answer_url
	"column name"
	assignment_type
	"column name"
	available_at
	"column name"
	class_room
	"column name"
	content_id
	"column name"
	content_label
	"column name"
	content_layout
	"column name"
	created_at
	"column name"
	deadline_at
	"column name"
	description
	"column name"
	id
	"column name"
	is_archived
	"column name"
	is_collaborative
	"column name"
	is_deleted
	"column name"
	owner_profile_id
	"column name"
	title
	"column name"
	updated_at
	"column name"
	uuid
}

"update columns of table \"app.assignments\""
enum app_assignments_update_column {
	"column name"
	answer_url
	"column name"
	assignment_type
	"column name"
	available_at
	"column name"
	class_room
	"column name"
	content_id
	"column name"
	content_label
	"column name"
	content_layout
	"column name"
	created_at
	"column name"
	deadline_at
	"column name"
	description
	"column name"
	id
	"column name"
	is_archived
	"column name"
	is_collaborative
	"column name"
	is_deleted
	"column name"
	owner_profile_id
	"column name"
	title
	"column name"
	updated_at
	"column name"
	uuid
}

"unique or primary key constraints on table \"app.assignments_v2_assignment_labels_v2\""
enum app_assignments_v2_assignment_labels_v2_constraint {
	"unique or primary key constraint"
	assignments_v2_assignment_lab_assignment_id_assignment_labe_key
	"unique or primary key constraint"
	assignments_v2_assignment_labels_v2_pkey
}

"select columns of table \"app.assignments_v2_assignment_labels_v2\""
enum app_assignments_v2_assignment_labels_v2_select_column {
	"column name"
	assignment_id
	"column name"
	assignment_label_id
	"column name"
	id
}

"update columns of table \"app.assignments_v2_assignment_labels_v2\""
enum app_assignments_v2_assignment_labels_v2_update_column {
	"column name"
	assignment_id
	"column name"
	assignment_label_id
	"column name"
	id
}

"unique or primary key constraints on table \"app.assignments_v2\""
enum app_assignments_v2_constraint {
	"unique or primary key constraint"
	assignments_v2_pkey
}

"select columns of table \"app.assignments_v2\""
enum app_assignments_v2_select_column {
	"column name"
	answer_url
	"column name"
	assignment_type
	"column name"
	available_at
	"column name"
	created_at
	"column name"
	deadline_at
	"column name"
	description
	"column name"
	id
	"column name"
	is_collaborative
	"column name"
	is_deleted
	"column name"
	owner_profile_id
	"column name"
	title
	"column name"
	updated_at
}

"update columns of table \"app.assignments_v2\""
enum app_assignments_v2_update_column {
	"column name"
	answer_url
	"column name"
	assignment_type
	"column name"
	available_at
	"column name"
	created_at
	"column name"
	deadline_at
	"column name"
	description
	"column name"
	id
	"column name"
	is_collaborative
	"column name"
	is_deleted
	"column name"
	owner_profile_id
	"column name"
	title
	"column name"
	updated_at
}

"select columns of table \"app.collection_actualisation_overview\""
enum app_collection_actualisation_overview_select_column {
	"column name"
	collection_id
	"column name"
	created_at
	"column name"
	is_public
	"column name"
	lom_classification
	"column name"
	lom_context
	"column name"
	mgmt_created_at
	"column name"
	mgmt_current_status
	"column name"
	mgmt_last_eindcheck_date
	"column name"
	mgmt_manager_profile_id
	"column name"
	mgmt_status_expires_at
	"column name"
	mgmt_updated_at
	"column name"
	owner_profile_id
	"column name"
	title
	"column name"
	type_id
	"column name"
	updated_at
	"column name"
	updated_by_profile_id
}

"unique or primary key constraints on table \"app.collection_bookmarks\""
enum app_collection_bookmarks_constraint {
	"unique or primary key constraint"
	collection_bookmarks_pkey
	"unique or primary key constraint"
	collection_bookmarks_profile_id_collection_uuid_key
}

"select columns of table \"app.collection_bookmarks\""
enum app_collection_bookmarks_select_column {
	"column name"
	collection_uuid
	"column name"
	created_at
	"column name"
	id
	"column name"
	profile_id
	"column name"
	updated_at
}

"update columns of table \"app.collection_bookmarks\""
enum app_collection_bookmarks_update_column {
	"column name"
	collection_uuid
	"column name"
	created_at
	"column name"
	id
	"column name"
	profile_id
	"column name"
	updated_at
}

"select columns of table \"app.collection_counts\""
enum app_collection_counts_select_column {
	"column name"
	bookmarks
	"column name"
	collection_uuid
	"column name"
	copies
	"column name"
	fragments
	"column name"
	in_assignment
	"column name"
	in_collection
	"column name"
	plays
	"column name"
	quick_lane_links
	"column name"
	views
}

"unique or primary key constraints on table \"app.collection_fragments\""
enum app_collection_fragments_constraint {
	"unique or primary key constraint"
	collection_fragments_pkey
}

"select columns of table \"app.collection_fragments\""
enum app_collection_fragments_select_column {
	"column name"
	collection_id
	"column name"
	collection_uuid
	"column name"
	created_at
	"column name"
	custom_description
	"column name"
	custom_title
	"column name"
	end_oc
	"column name"
	external_id
	"column name"
	id
	"column name"
	is_copy_of
	"column name"
	is_deleted
	"column name"
	position
	"column name"
	start_oc
	"column name"
	thumbnail_path
	"column name"
	type
	"column name"
	updated_at
	"column name"
	use_custom_fields
}

"update columns of table \"app.collection_fragments\""
enum app_collection_fragments_update_column {
	"column name"
	collection_id
	"column name"
	collection_uuid
	"column name"
	created_at
	"column name"
	custom_description
	"column name"
	custom_title
	"column name"
	end_oc
	"column name"
	external_id
	"column name"
	id
	"column name"
	is_copy_of
	"column name"
	is_deleted
	"column name"
	position
	"column name"
	start_oc
	"column name"
	thumbnail_path
	"column name"
	type
	"column name"
	updated_at
	"column name"
	use_custom_fields
}

"unique or primary key constraints on table \"app.collection_labels\""
enum app_collection_labels_constraint {
	"unique or primary key constraint"
	collection_labels_pkey
}

"select columns of table \"app.collection_labels\""
enum app_collection_labels_select_column {
	"column name"
	collection_uuid
	"column name"
	created_at
	"column name"
	id
	"column name"
	label
	"column name"
	updated_at
}

"update columns of table \"app.collection_labels\""
enum app_collection_labels_update_column {
	"column name"
	collection_uuid
	"column name"
	created_at
	"column name"
	id
	"column name"
	label
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.collection_management_QC\""
enum app_collection_management_QC_constraint {
	"unique or primary key constraint"
	collection_management_QC_pkey
}

"select columns of table \"app.collection_management_QC\""
enum app_collection_management_QC_select_column {
	"column name"
	assignee_profile_id
	"column name"
	collection_id
	"column name"
	comment
	"column name"
	created_at
	"column name"
	id
	"column name"
	qc_label
	"column name"
	qc_status
	"column name"
	updated_at
}

"update columns of table \"app.collection_management_QC\""
enum app_collection_management_QC_update_column {
	"column name"
	assignee_profile_id
	"column name"
	collection_id
	"column name"
	comment
	"column name"
	created_at
	"column name"
	id
	"column name"
	qc_label
	"column name"
	qc_status
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.collection_management\""
enum app_collection_management_constraint {
	"unique or primary key constraint"
	collection_management_collection_id_key
	"unique or primary key constraint"
	collection_management_pkey
}

"select columns of table \"app.collection_management\""
enum app_collection_management_select_column {
	"column name"
	collection_id
	"column name"
	created_at
	"column name"
	current_status
	"column name"
	id
	"column name"
	manager_profile_id
	"column name"
	note
	"column name"
	status_valid_until
	"column name"
	updated_at
}

"update columns of table \"app.collection_management\""
enum app_collection_management_update_column {
	"column name"
	collection_id
	"column name"
	created_at
	"column name"
	current_status
	"column name"
	id
	"column name"
	manager_profile_id
	"column name"
	note
	"column name"
	status_valid_until
	"column name"
	updated_at
}

"select columns of table \"app.collection_marcom_klascement_view\""
enum app_collection_marcom_klascement_view_select_column {
	"column name"
	collection_id
	"column name"
	count
}

"unique or primary key constraints on table \"app.collection_marcom_log\""
enum app_collection_marcom_log_constraint {
	"unique or primary key constraint"
	collection_marcom_log_pkey
}

"select columns of table \"app.collection_marcom_log\""
enum app_collection_marcom_log_select_column {
	"column name"
	channel_name
	"column name"
	channel_type
	"column name"
	collection_id
	"column name"
	created_at
	"column name"
	external_link
	"column name"
	id
	"column name"
	parent_collection_id
	"column name"
	publish_date
	"column name"
	updated_at
}

"update columns of table \"app.collection_marcom_log\""
enum app_collection_marcom_log_update_column {
	"column name"
	channel_name
	"column name"
	channel_type
	"column name"
	collection_id
	"column name"
	created_at
	"column name"
	external_link
	"column name"
	id
	"column name"
	parent_collection_id
	"column name"
	publish_date
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.collection_marcom_notes\""
enum app_collection_marcom_notes_constraint {
	"unique or primary key constraint"
	collection_marcom_notes_id_key
	"unique or primary key constraint"
	collection_marcom_notes_pkey
}

"select columns of table \"app.collection_marcom_notes\""
enum app_collection_marcom_notes_select_column {
	"column name"
	collection_id
	"column name"
	created_at
	"column name"
	id
	"column name"
	note
	"column name"
	updated_at
}

"update columns of table \"app.collection_marcom_notes\""
enum app_collection_marcom_notes_update_column {
	"column name"
	collection_id
	"column name"
	created_at
	"column name"
	id
	"column name"
	note
	"column name"
	updated_at
}

"select columns of table \"app.collection_marcom_overview\""
enum app_collection_marcom_overview_select_column {
	"column name"
	channel_name
	"column name"
	channel_type
	"column name"
	collection_id
	"column name"
	created_at
	"column name"
	is_public
	"column name"
	klascement
	"column name"
	last_marcom_date
	"column name"
	lom_classification
	"column name"
	lom_context
	"column name"
	owner_profile_id
	"column name"
	parent_collection_id
	"column name"
	title
	"column name"
	type_id
	"column name"
	updated_at
	"column name"
	updated_by_profile_id
}

"unique or primary key constraints on table \"app.collection_plays\""
enum app_collection_plays_constraint {
	"unique or primary key constraint"
	collection_plays_collection_uuid_key
	"unique or primary key constraint"
	collection_plays_pkey
}

"select columns of table \"app.collection_plays\""
enum app_collection_plays_select_column {
	"column name"
	collection_uuid
	"column name"
	count
	"column name"
	created_at
	"column name"
	id
	"column name"
	updated_at
}

"update columns of table \"app.collection_plays\""
enum app_collection_plays_update_column {
	"column name"
	collection_uuid
	"column name"
	count
	"column name"
	created_at
	"column name"
	id
	"column name"
	updated_at
}

"select columns of table \"app.collection_qc_overview\""
enum app_collection_qc_overview_select_column {
	"column name"
	collection_id
	"column name"
	created_at
	"column name"
	is_public
	"column name"
	lom_classification
	"column name"
	lom_context
	"column name"
	mgmt_eind_check_date
	"column name"
	mgmt_language_check
	"column name"
	mgmt_quality_check
	"column name"
	owner_profile_id
	"column name"
	title
	"column name"
	type_id
	"column name"
	updated_at
	"column name"
	updated_by_profile_id
}

"unique or primary key constraints on table \"app.collection_relations\""
enum app_collection_relations_constraint {
	"unique or primary key constraint"
	collection_relations_pkey
	"unique or primary key constraint"
	collection_relations_subject_predicate_object_key
}

"select columns of table \"app.collection_relations\""
enum app_collection_relations_select_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	object
	"column name"
	predicate
	"column name"
	subject
	"column name"
	updated_at
}

"update columns of table \"app.collection_relations\""
enum app_collection_relations_update_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	object
	"column name"
	predicate
	"column name"
	subject
	"column name"
	updated_at
}

"select columns of table \"app.collection_relations_view\""
enum app_collection_relations_view_select_column {
	"column name"
	object
	"column name"
	predicate
	"column name"
	subject
}

"unique or primary key constraints on table \"app.collection_views\""
enum app_collection_views_constraint {
	"unique or primary key constraint"
	collection_views_collection_uuid_key
	"unique or primary key constraint"
	collection_views_pkey
}

"select columns of table \"app.collection_views\""
enum app_collection_views_select_column {
	"column name"
	collection_uuid
	"column name"
	count
	"column name"
	created_at
	"column name"
	id
	"column name"
	updated_at
}

"update columns of table \"app.collection_views\""
enum app_collection_views_update_column {
	"column name"
	collection_uuid
	"column name"
	count
	"column name"
	created_at
	"column name"
	id
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.collections\""
enum app_collections_constraint {
	"unique or primary key constraint"
	collections_avo1_id_key
	"unique or primary key constraint"
	collections_id_key
	"unique or primary key constraint"
	collections_pkey
}

"select columns of table \"app.collections\""
enum app_collections_select_column {
	"column name"
	author_external_uid
	"column name"
	author_uid
	"column name"
	avo1_id
	"column name"
	briefing_id
	"column name"
	collection_fragment_ids
	"column name"
	created_at
	"column name"
	depublish_at
	"column name"
	description
	"column name"
	description_long
	"column name"
	external_id
	"column name"
	id
	"column name"
	is_deleted
	"column name"
	is_managed
	"column name"
	is_public
	"column name"
	lom_classification
	"column name"
	lom_context
	"column name"
	lom_intendedenduserrole
	"column name"
	lom_keywords
	"column name"
	lom_languages
	"column name"
	lom_typicalagerange
	"column name"
	note
	"column name"
	organisation_id
	"column name"
	owner_profile_id
	"column name"
	publish_at
	"column name"
	published_at
	"column name"
	seo_image_path
	"column name"
	thumbnail_path
	"column name"
	title
	"column name"
	type_id
	"column name"
	updated_at
	"column name"
	updated_by_profile_id
}

"update columns of table \"app.collections\""
enum app_collections_update_column {
	"column name"
	author_external_uid
	"column name"
	author_uid
	"column name"
	avo1_id
	"column name"
	briefing_id
	"column name"
	collection_fragment_ids
	"column name"
	created_at
	"column name"
	depublish_at
	"column name"
	description
	"column name"
	description_long
	"column name"
	external_id
	"column name"
	id
	"column name"
	is_deleted
	"column name"
	is_managed
	"column name"
	is_public
	"column name"
	lom_classification
	"column name"
	lom_context
	"column name"
	lom_intendedenduserrole
	"column name"
	lom_keywords
	"column name"
	lom_languages
	"column name"
	lom_typicalagerange
	"column name"
	note
	"column name"
	organisation_id
	"column name"
	owner_profile_id
	"column name"
	publish_at
	"column name"
	published_at
	"column name"
	seo_image_path
	"column name"
	thumbnail_path
	"column name"
	title
	"column name"
	type_id
	"column name"
	updated_at
	"column name"
	updated_by_profile_id
}

"unique or primary key constraints on table \"app.content_assets\""
enum app_content_assets_constraint {
	"unique or primary key constraint"
	content_assets_label_key
	"unique or primary key constraint"
	content_assets_path_key
	"unique or primary key constraint"
	content_assets_pkey
}

"select columns of table \"app.content_assets\""
enum app_content_assets_select_column {
	"column name"
	content_asset_type_id
	"column name"
	created_at
	"column name"
	description
	"column name"
	id
	"column name"
	label
	"column name"
	owner_id
	"column name"
	path
	"column name"
	updated_at
}

"update columns of table \"app.content_assets\""
enum app_content_assets_update_column {
	"column name"
	content_asset_type_id
	"column name"
	created_at
	"column name"
	description
	"column name"
	id
	"column name"
	label
	"column name"
	owner_id
	"column name"
	path
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.content_blocks\""
enum app_content_blocks_constraint {
	"unique or primary key constraint"
	content_blocks_pkey
}

"select columns of table \"app.content_blocks\""
enum app_content_blocks_select_column {
	"column name"
	content_block_type
	"column name"
	content_id
	"column name"
	created_at
	"column name"
	id
	"column name"
	position
	"column name"
	updated_at
	"column name"
	variables
}

"update columns of table \"app.content_blocks\""
enum app_content_blocks_update_column {
	"column name"
	content_block_type
	"column name"
	content_id
	"column name"
	created_at
	"column name"
	id
	"column name"
	position
	"column name"
	updated_at
	"column name"
	variables
}

"unique or primary key constraints on table \"app.content\""
enum app_content_constraint {
	"unique or primary key constraint"
	content_path_key
	"unique or primary key constraint"
	content_pkey
}

"unique or primary key constraints on table \"app.content_content_labels\""
enum app_content_content_labels_constraint {
	"unique or primary key constraint"
	content_content_labels_pkey
}

"select columns of table \"app.content_content_labels\""
enum app_content_content_labels_select_column {
	"column name"
	content_id
	"column name"
	created_at
	"column name"
	id
	"column name"
	label_id
	"column name"
	updated_at
}

"update columns of table \"app.content_content_labels\""
enum app_content_content_labels_update_column {
	"column name"
	content_id
	"column name"
	created_at
	"column name"
	id
	"column name"
	label_id
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.content_labels\""
enum app_content_labels_constraint {
	"unique or primary key constraint"
	content_labels_label_content_type_key
	"unique or primary key constraint"
	content_labels_pkey
}

"select columns of table \"app.content_labels\""
enum app_content_labels_select_column {
	"column name"
	content_type
	"column name"
	created_at
	"column name"
	id
	"column name"
	label
	"column name"
	link_to
	"column name"
	updated_at
}

"update columns of table \"app.content_labels\""
enum app_content_labels_update_column {
	"column name"
	content_type
	"column name"
	created_at
	"column name"
	id
	"column name"
	label
	"column name"
	link_to
	"column name"
	updated_at
}

"select columns of table \"app.content_lower_title\""
enum app_content_lower_title_select_column {
	"column name"
	id
	"column name"
	title_lower
}

"unique or primary key constraints on table \"app.content_nav_elements\""
enum app_content_nav_elements_constraint {
	"unique or primary key constraint"
	content_nav_elements_pkey
}

"select columns of table \"app.content_nav_elements\""
enum app_content_nav_elements_select_column {
	"column name"
	content_id
	"column name"
	content_path
	"column name"
	content_type
	"column name"
	created_at
	"column name"
	description
	"column name"
	icon_name
	"column name"
	id
	"column name"
	label
	"column name"
	link_target
	"column name"
	placement
	"column name"
	position
	"column name"
	tooltip
	"column name"
	updated_at
	"column name"
	user_group_ids
}

"update columns of table \"app.content_nav_elements\""
enum app_content_nav_elements_update_column {
	"column name"
	content_id
	"column name"
	content_path
	"column name"
	content_type
	"column name"
	created_at
	"column name"
	description
	"column name"
	icon_name
	"column name"
	id
	"column name"
	label
	"column name"
	link_target
	"column name"
	placement
	"column name"
	position
	"column name"
	tooltip
	"column name"
	updated_at
	"column name"
	user_group_ids
}

"select columns of table \"app.content\""
enum app_content_select_column {
	"column name"
	content_type
	"column name"
	content_width
	"column name"
	created_at
	"column name"
	depublish_at
	"column name"
	description
	"column name"
	header_path
	"column name"
	id
	"column name"
	is_deleted
	"column name"
	is_protected
	"column name"
	is_public
	"column name"
	meta_description
	"column name"
	path
	"column name"
	publish_at
	"column name"
	published_at
	"column name"
	seo_description
	"column name"
	seo_image_path
	"column name"
	seo_keywords
	"column name"
	seo_title
	"column name"
	thumbnail_path
	"column name"
	title
	"column name"
	updated_at
	"column name"
	updated_by_profile_id
	"column name"
	user_group_ids
	"column name"
	user_profile_id
}

"update columns of table \"app.content\""
enum app_content_update_column {
	"column name"
	content_type
	"column name"
	content_width
	"column name"
	created_at
	"column name"
	depublish_at
	"column name"
	description
	"column name"
	header_path
	"column name"
	id
	"column name"
	is_deleted
	"column name"
	is_protected
	"column name"
	is_public
	"column name"
	meta_description
	"column name"
	path
	"column name"
	publish_at
	"column name"
	published_at
	"column name"
	seo_description
	"column name"
	seo_image_path
	"column name"
	seo_keywords
	"column name"
	seo_title
	"column name"
	thumbnail_path
	"column name"
	title
	"column name"
	updated_at
	"column name"
	updated_by_profile_id
	"column name"
	user_group_ids
	"column name"
	user_profile_id
}

"unique or primary key constraints on table \"app.interactive_tour\""
enum app_interactive_tour_constraint {
	"unique or primary key constraint"
	interactive_tour_name_key
	"unique or primary key constraint"
	interactive_tour_pkey
}

"select columns of table \"app.interactive_tour\""
enum app_interactive_tour_select_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	name
	"column name"
	page
	"column name"
	steps
	"column name"
	updated_at
}

"update columns of table \"app.interactive_tour\""
enum app_interactive_tour_update_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	name
	"column name"
	page
	"column name"
	steps
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.item_bookmarks\""
enum app_item_bookmarks_constraint {
	"unique or primary key constraint"
	item_bookmarks_pkey
	"unique or primary key constraint"
	item_bookmarks_profile_id_item_id_key
}

"select columns of table \"app.item_bookmarks\""
enum app_item_bookmarks_select_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	item_id
	"column name"
	profile_id
	"column name"
	updated_at
}

"update columns of table \"app.item_bookmarks\""
enum app_item_bookmarks_update_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	item_id
	"column name"
	profile_id
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.item_collateral\""
enum app_item_collateral_constraint {
	"unique or primary key constraint"
	item_collateral_pkey
}

"select columns of table \"app.item_collateral\""
enum app_item_collateral_select_column {
	"column name"
	created_at
	"column name"
	description
	"column name"
	external_id
	"column name"
	format
	"column name"
	item_external_id
	"column name"
	path
	"column name"
	updated_at
}

"update columns of table \"app.item_collateral\""
enum app_item_collateral_update_column {
	"column name"
	created_at
	"column name"
	description
	"column name"
	external_id
	"column name"
	format
	"column name"
	item_external_id
	"column name"
	path
	"column name"
	updated_at
}

"select columns of table \"app.item_counts\""
enum app_item_counts_select_column {
	"column name"
	bookmarks
	"column name"
	in_assignment
	"column name"
	in_collection
	"column name"
	item_uuid
	"column name"
	plays
	"column name"
	quick_lane_links
	"column name"
	views
}

"unique or primary key constraints on table \"app.item_meta\""
enum app_item_meta_constraint {
	"unique or primary key constraint"
	item_meta_avo1_id_key
	"unique or primary key constraint"
	item_meta_uid_key
	"unique or primary key constraint"
	item_summary_item_id_key
	"unique or primary key constraint"
	item_summary_pkey
}

"select columns of table \"app.item_meta\""
enum app_item_meta_select_column {
	"column name"
	archived_at
	"column name"
	avo1_id
	"column name"
	browse_path
	"column name"
	created_at
	"column name"
	depublish_at
	"column name"
	depublish_reason
	"column name"
	description
	"column name"
	duration
	"column name"
	expiry_date
	"column name"
	external_id
	"column name"
	id
	"column name"
	is_deleted
	"column name"
	is_orphaned
	"column name"
	is_published
	"column name"
	issued
	"column name"
	issued_edtf
	"column name"
	lom_classification
	"column name"
	lom_context
	"column name"
	lom_intendedenduserrole
	"column name"
	lom_keywords
	"column name"
	lom_languages
	"column name"
	lom_thema
	"column name"
	lom_typicalagerange
	"column name"
	note
	"column name"
	org_id
	"column name"
	original_pid
	"column name"
	publish_at
	"column name"
	published_at
	"column name"
	seo_image_path
	"column name"
	series
	"column name"
	thumbnail_path
	"column name"
	title
	"column name"
	type_id
	"column name"
	uid
	"column name"
	updated_at
}

"update columns of table \"app.item_meta\""
enum app_item_meta_update_column {
	"column name"
	archived_at
	"column name"
	avo1_id
	"column name"
	browse_path
	"column name"
	created_at
	"column name"
	depublish_at
	"column name"
	depublish_reason
	"column name"
	description
	"column name"
	duration
	"column name"
	expiry_date
	"column name"
	external_id
	"column name"
	id
	"column name"
	is_deleted
	"column name"
	is_orphaned
	"column name"
	is_published
	"column name"
	issued
	"column name"
	issued_edtf
	"column name"
	lom_classification
	"column name"
	lom_context
	"column name"
	lom_intendedenduserrole
	"column name"
	lom_keywords
	"column name"
	lom_languages
	"column name"
	lom_thema
	"column name"
	lom_typicalagerange
	"column name"
	note
	"column name"
	org_id
	"column name"
	original_pid
	"column name"
	publish_at
	"column name"
	published_at
	"column name"
	seo_image_path
	"column name"
	series
	"column name"
	thumbnail_path
	"column name"
	title
	"column name"
	type_id
	"column name"
	uid
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.item_plays\""
enum app_item_plays_constraint {
	"unique or primary key constraint"
	item_plays_item_id_key
	"unique or primary key constraint"
	item_plays_pkey
}

"select columns of table \"app.item_plays\""
enum app_item_plays_select_column {
	"column name"
	count
	"column name"
	created_at
	"column name"
	id
	"column name"
	item_id
	"column name"
	updated_at
}

"update columns of table \"app.item_plays\""
enum app_item_plays_update_column {
	"column name"
	count
	"column name"
	created_at
	"column name"
	id
	"column name"
	item_id
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.item_relations\""
enum app_item_relations_constraint {
	"unique or primary key constraint"
	item_relations_pkey
	"unique or primary key constraint"
	item_relations_subject_predicate_object_key
}

"select columns of table \"app.item_relations\""
enum app_item_relations_select_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	object
	"column name"
	predicate
	"column name"
	subject
	"column name"
	updated_at
}

"update columns of table \"app.item_relations\""
enum app_item_relations_update_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	object
	"column name"
	predicate
	"column name"
	subject
	"column name"
	updated_at
}

"select columns of table \"app.item_relations_view\""
enum app_item_relations_view_select_column {
	"column name"
	created_at
	"column name"
	object
	"column name"
	predicate
	"column name"
	subject
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.item_score\""
enum app_item_score_constraint {
	"unique or primary key constraint"
	item_score_item_id_key
	"unique or primary key constraint"
	item_score_pkey
}

"select columns of table \"app.item_score\""
enum app_item_score_select_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	item_id
	"column name"
	score
	"column name"
	updated_at
}

"update columns of table \"app.item_score\""
enum app_item_score_update_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	item_id
	"column name"
	score
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.item_views\""
enum app_item_views_constraint {
	"unique or primary key constraint"
	item_views_item_id_key
	"unique or primary key constraint"
	item_views_pkey
}

"select columns of table \"app.item_views\""
enum app_item_views_select_column {
	"column name"
	count
	"column name"
	created_at
	"column name"
	id
	"column name"
	item_id
	"column name"
	updated_at
}

"update columns of table \"app.item_views\""
enum app_item_views_update_column {
	"column name"
	count
	"column name"
	created_at
	"column name"
	id
	"column name"
	item_id
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.pupil_collection_blocks\""
enum app_pupil_collection_blocks_constraint {
	"unique or primary key constraint"
	pupil_collection_blocks_pkey
}

"select columns of table \"app.pupil_collection_blocks\""
enum app_pupil_collection_blocks_select_column {
	"column name"
	assignment_response_id
	"column name"
	created_at
	"column name"
	custom_description
	"column name"
	custom_title
	"column name"
	end_oc
	"column name"
	fragment_id
	"column name"
	id
	"column name"
	is_deleted
	"column name"
	position
	"column name"
	start_oc
	"column name"
	thumbnail_path
	"column name"
	type
	"column name"
	updated_at
	"column name"
	use_custom_fields
}

"update columns of table \"app.pupil_collection_blocks\""
enum app_pupil_collection_blocks_update_column {
	"column name"
	assignment_response_id
	"column name"
	created_at
	"column name"
	custom_description
	"column name"
	custom_title
	"column name"
	end_oc
	"column name"
	fragment_id
	"column name"
	id
	"column name"
	is_deleted
	"column name"
	position
	"column name"
	start_oc
	"column name"
	thumbnail_path
	"column name"
	type
	"column name"
	updated_at
	"column name"
	use_custom_fields
}

"unique or primary key constraints on table \"app.quick_lanes\""
enum app_quick_lanes_constraint {
	"unique or primary key constraint"
	quick_lanes_pkey
}

"select columns of table \"app.quick_lanes_overview\""
enum app_quick_lanes_overview_select_column {
	"column name"
	company_id
	"column name"
	company_name
	"column name"
	content_id
	"column name"
	content_label
	"column name"
	created_at
	"column name"
	id
	"column name"
	owner_first_name
	"column name"
	owner_full_name
	"column name"
	owner_last_name
	"column name"
	owner_profile_id
	"column name"
	title
	"column name"
	updated_at
	"column name"
	view_mode
}

"select columns of table \"app.quick_lanes\""
enum app_quick_lanes_select_column {
	"column name"
	content_id
	"column name"
	content_label
	"column name"
	created_at
	"column name"
	id
	"column name"
	owner_profile_id
	"column name"
	title
	"column name"
	updated_at
	"column name"
	view_mode
}

"update columns of table \"app.quick_lanes\""
enum app_quick_lanes_update_column {
	"column name"
	content_id
	"column name"
	content_label
	"column name"
	created_at
	"column name"
	id
	"column name"
	owner_profile_id
	"column name"
	title
	"column name"
	updated_at
	"column name"
	view_mode
}

"unique or primary key constraints on table \"app.search_bookmarks\""
enum app_search_bookmarks_constraint {
	"unique or primary key constraint"
	search_bookmarks_pkey
	"unique or primary key constraint"
	search_bookmarks_uid_key
}

"select columns of table \"app.search_bookmarks\""
enum app_search_bookmarks_select_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	label
	"column name"
	profile_owner_id
	"column name"
	search_params
	"column name"
	updated_at
}

"update columns of table \"app.search_bookmarks\""
enum app_search_bookmarks_update_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	label
	"column name"
	profile_owner_id
	"column name"
	search_params
	"column name"
	updated_at
}

"unique or primary key constraints on table \"app.site_variables\""
enum app_site_variables_constraint {
	"unique or primary key constraint"
	site_variables_pkey
}

"select columns of table \"app.site_variables\""
enum app_site_variables_select_column {
	"column name"
	created_at
	"column name"
	name
	"column name"
	updated_at
	"column name"
	value
}

"update columns of table \"app.site_variables\""
enum app_site_variables_update_column {
	"column name"
	created_at
	"column name"
	name
	"column name"
	updated_at
	"column name"
	value
}

"select columns of table \"app.usage_counts\""
enum app_usage_counts_select_column {
	"column name"
	count
	"column name"
	id
	"column name"
	type
	"column name"
	usage
}

"unique or primary key constraints on table \"lookup.enum_assignment_content_labels\""
enum lookup_enum_assignment_content_labels_constraint {
	"unique or primary key constraint"
	enum_assignment_content_label_pkey
}

enum lookup_enum_assignment_content_labels_enum {
	"Een gebruikerscollectie."
	COLLECTIE
	"Een video- of audiofragment"
	ITEM
	"Een opgeslagen zoekopdracht."
	ZOEKOPDRACHT
}

"select columns of table \"lookup.enum_assignment_content_labels\""
enum lookup_enum_assignment_content_labels_select_column {
	"column name"
	label
	"column name"
	value
}

"update columns of table \"lookup.enum_assignment_content_labels\""
enum lookup_enum_assignment_content_labels_update_column {
	"column name"
	label
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_assignment_types\""
enum lookup_enum_assignment_types_constraint {
	"unique or primary key constraint"
	enum_assignment_types_pkey
}

"select columns of table \"lookup.enum_assignment_types\""
enum lookup_enum_assignment_types_select_column {
	"column name"
	label
	"column name"
	value
}

"update columns of table \"lookup.enum_assignment_types\""
enum lookup_enum_assignment_types_update_column {
	"column name"
	label
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_collection_labels\""
enum lookup_enum_collection_labels_constraint {
	"unique or primary key constraint"
	labels_pkey
}

"select columns of table \"lookup.enum_collection_labels\""
enum lookup_enum_collection_labels_select_column {
	"column name"
	description
	"column name"
	value
}

"update columns of table \"lookup.enum_collection_labels\""
enum lookup_enum_collection_labels_update_column {
	"column name"
	description
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_collection_management_qc_label\""
enum lookup_enum_collection_management_qc_label_constraint {
	"unique or primary key constraint"
	enum_collection_management_qc_label_pkey
}

enum lookup_enum_collection_management_qc_label_enum {
	"Volledig nazicht en feitelijke goedkeuring."
	EINDCHECK
	"Inhoudelijke en kwalititatieve controle."
	KWALITEITSCHECK
	"Redactionele taal- en spellingscontrole."
	TAALCHECK
}

"select columns of table \"lookup.enum_collection_management_qc_label\""
enum lookup_enum_collection_management_qc_label_select_column {
	"column name"
	description
	"column name"
	value
}

"update columns of table \"lookup.enum_collection_management_qc_label\""
enum lookup_enum_collection_management_qc_label_update_column {
	"column name"
	description
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_collection_management_status\""
enum lookup_enum_collection_management_status_constraint {
	"unique or primary key constraint"
	enum_collection_management_status_pkey
}

"select columns of table \"lookup.enum_collection_management_status\""
enum lookup_enum_collection_management_status_select_column {
	"column name"
	description
	"column name"
	value
}

"update columns of table \"lookup.enum_collection_management_status\""
enum lookup_enum_collection_management_status_update_column {
	"column name"
	description
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_colors\""
enum lookup_enum_colors_constraint {
	"unique or primary key constraint"
	enum_colors_label_key
	"unique or primary key constraint"
	enum_colors_pkey
}

enum lookup_enum_colors_enum {
	"#D03F06"
	DARK_ORANGE
	"#F33F67"
	FRENCH_ROSE
	"#9DB410"
	GREEN
	"#678588"
	JUNIPER
	"#57C2A0"
	OCEAN_GREEN
	"#DBDBDB"
	SILVER
	"#8AC1CE"
	SOFT_BLUE
	"#B75B99"
	TAPESTRY
	"#98485C"
	WINE_RED
	"#F3AA2E"
	YELLOW
}

"select columns of table \"lookup.enum_colors\""
enum lookup_enum_colors_select_column {
	"column name"
	label
	"column name"
	value
}

"update columns of table \"lookup.enum_colors\""
enum lookup_enum_colors_update_column {
	"column name"
	label
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_content_block_types\""
enum lookup_enum_content_block_types_constraint {
	"unique or primary key constraint"
	enum_content_block_types_pkey
}

enum lookup_enum_content_block_types_enum {
	ACCORDIONS
	ANCHOR_LINKS
	BUTTONS
	CONTENT_PAGE_META
	CTAS
	EVENTBRITE
	HEADING
	HERO
	IFRAME
	IMAGE
	IMAGE_GRID
	INTRO
	KLAAR
	LINKS
	LOGO_GRID
	MEDIA_GRID
	MEDIA_PLAYER
	MEDIA_PLAYER_TITLE_TEXT_BUTTON
	PAGE_OVERVIEW
	PROJECTS_SPOTLIGHT
	QUOTE
	RICH_TEXT
	RICH_TEXT_TWO_COLUMNS
	SEARCH
	SPOTLIGHT
	SUBTITLE
	TITLE
	TITLE_IMAGE_TEXT
	TITLE_IMAGE_TEXT_BUTTON
	USP_GRID
	VIDEO
	VIDEO_TITLE_TEXT_BUTTON
}

"select columns of table \"lookup.enum_content_block_types\""
enum lookup_enum_content_block_types_select_column {
	"column name"
	description
	"column name"
	value
}

"update columns of table \"lookup.enum_content_block_types\""
enum lookup_enum_content_block_types_update_column {
	"column name"
	description
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_content_types\""
enum lookup_enum_content_types_constraint {
	"unique or primary key constraint"
	enum_content_types_pkey
}

enum lookup_enum_content_types_enum {
	"Domein detail"
	DOMEIN_DETAIL
	"Event detail"
	EVENT_DETAIL
	"FAQ-vraag"
	FAQ_ITEM
	"Nieuws item"
	NIEUWS_ITEM
	"Overzicht"
	OVERZICHT
	"Pagina"
	PAGINA
	"Project"
	PROJECT
	"Hulpfilmpje"
	SCREENCAST
}

"select columns of table \"lookup.enum_content_types\""
enum lookup_enum_content_types_select_column {
	"column name"
	description
	"column name"
	value
}

"update columns of table \"lookup.enum_content_types\""
enum lookup_enum_content_types_update_column {
	"column name"
	description
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_input_types\""
enum lookup_enum_input_types_constraint {
	"unique or primary key constraint"
	enum_input_types_pkey
}

"select columns of table \"lookup.enum_input_types\""
enum lookup_enum_input_types_select_column {
	"column name"
	description
	"column name"
	value
}

"update columns of table \"lookup.enum_input_types\""
enum lookup_enum_input_types_update_column {
	"column name"
	description
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_lom_classification\""
enum lookup_enum_lom_classification_constraint {
	"unique or primary key constraint"
	enum_lom_classification_pkey
}

"select columns of table \"lookup.enum_lom_classification\""
enum lookup_enum_lom_classification_select_column {
	"column name"
	description
	"column name"
	value
}

"update columns of table \"lookup.enum_lom_classification\""
enum lookup_enum_lom_classification_update_column {
	"column name"
	description
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_lom_context\""
enum lookup_enum_lom_context_constraint {
	"unique or primary key constraint"
	enum_lom_context_pkey
}

"select columns of table \"lookup.enum_lom_context\""
enum lookup_enum_lom_context_select_column {
	"column name"
	description
	"column name"
	value
}

"update columns of table \"lookup.enum_lom_context\""
enum lookup_enum_lom_context_update_column {
	"column name"
	description
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_profile_flags\""
enum lookup_enum_profile_flags_constraint {
	"unique or primary key constraint"
	enum_profile_flags_pkey
}

enum lookup_enum_profile_flags_enum {
	"Flag user for review bij verschil tussen bronnen, voorbeeld wanneer Vlaamse overheid zegt dat een gebruiker geen leerkracht is, maar volgens AVO wel."
	LEERKRACHT_CONFLICT
	"Flag user for review bij verschil tussen bronnen, voorbeeld wanneer Vlaamse overheid een ander stamboeknummer doorgeeft dan wat geregistreerd is in AVO."
	STAMBOEK_CONFLICT
}

"select columns of table \"lookup.enum_profile_flags\""
enum lookup_enum_profile_flags_select_column {
	"column name"
	description
	"column name"
	value
}

"update columns of table \"lookup.enum_profile_flags\""
enum lookup_enum_profile_flags_update_column {
	"column name"
	description
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_profile_preferences_keys\""
enum lookup_enum_profile_preferences_keys_constraint {
	"unique or primary key constraint"
	enum_profile_preferences_keys_pkey
}

enum lookup_enum_profile_preferences_keys_enum {
	"Array van elementen zoals pop-ups en infovensters waarvoor de gebruiker heeft aangegeven dat deze niet meer weergegeven mogen worden."
	DO_NOT_SHOW
}

"select columns of table \"lookup.enum_profile_preferences_keys\""
enum lookup_enum_profile_preferences_keys_select_column {
	"column name"
	description
	"column name"
	value
}

"update columns of table \"lookup.enum_profile_preferences_keys\""
enum lookup_enum_profile_preferences_keys_update_column {
	"column name"
	description
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_relation_types\""
enum lookup_enum_relation_types_constraint {
	"unique or primary key constraint"
	enum_relation_types_pkey
}

enum lookup_enum_relation_types_enum {
	"Collectie of item heeft een kopie."
	HAS_COPY
	"Subject is een kopie van Object"
	IS_COPY_OF
	"Subject is vervangen door Object"
	IS_REPLACED_BY
	"Collectie of item vervangt een andere collectie of item."
	REPLACES
}

"select columns of table \"lookup.enum_relation_types\""
enum lookup_enum_relation_types_select_column {
	"column name"
	description
	"column name"
	value
}

"update columns of table \"lookup.enum_relation_types\""
enum lookup_enum_relation_types_update_column {
	"column name"
	description
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.enum_search_bookmark_types\""
enum lookup_enum_search_bookmark_types_constraint {
	"unique or primary key constraint"
	enum_search_bookmark_type_pkey
}

"select columns of table \"lookup.enum_search_bookmark_types\""
enum lookup_enum_search_bookmark_types_select_column {
	"column name"
	label
	"column name"
	value
}

"update columns of table \"lookup.enum_search_bookmark_types\""
enum lookup_enum_search_bookmark_types_update_column {
	"column name"
	label
	"column name"
	value
}

"unique or primary key constraints on table \"lookup.thesaurus\""
enum lookup_thesaurus_constraint {
	"unique or primary key constraint"
	thesaurus_pkey
}

"select columns of table \"lookup.thesaurus\""
enum lookup_thesaurus_select_column {
	"column name"
	id
	"column name"
	label
	"column name"
	scheme
}

"update columns of table \"lookup.thesaurus\""
enum lookup_thesaurus_update_column {
	"column name"
	id
	"column name"
	label
	"column name"
	scheme
}

"unique or primary key constraints on table \"migrate.original_publishdate\""
enum migrate_original_publishdate_constraint {
	"unique or primary key constraint"
	original_publishdate_pkey
}

"select columns of table \"migrate.original_publishdate\""
enum migrate_original_publishdate_select_column {
	"column name"
	created_at
	"column name"
	external_id
	"column name"
	mediamosa_id
}

"update columns of table \"migrate.original_publishdate\""
enum migrate_original_publishdate_update_column {
	"column name"
	created_at
	"column name"
	external_id
	"column name"
	mediamosa_id
}

"unique or primary key constraints on table \"migrate.reference_ids\""
enum migrate_reference_ids_constraint {
	"unique or primary key constraint"
	reference_ids_mediamosa_id_key
	"unique or primary key constraint"
	reference_ids_pkey
}

"select columns of table \"migrate.reference_ids\""
enum migrate_reference_ids_select_column {
	"column name"
	created_at
	"column name"
	external_id
	"column name"
	id
	"column name"
	mediamosa_id
	"column name"
	type_label
}

"update columns of table \"migrate.reference_ids\""
enum migrate_reference_ids_update_column {
	"column name"
	created_at
	"column name"
	external_id
	"column name"
	id
	"column name"
	mediamosa_id
	"column name"
	type_label
}

"column ordering options"
enum order_by {
	"in the ascending order, nulls last"
	asc
	"in the ascending order, nulls first"
	asc_nulls_first
	"in the ascending order, nulls last"
	asc_nulls_last
	"in the descending order, nulls first"
	desc
	"in the descending order, nulls first"
	desc_nulls_first
	"in the descending order, nulls last"
	desc_nulls_last
}

"unique or primary key constraints on table \"shared.collateral\""
enum shared_collateral_constraint {
	"unique or primary key constraint"
	collateral_external_id_key
	"unique or primary key constraint"
	collateral_pkey
}

"select columns of table \"shared.collateral\""
enum shared_collateral_select_column {
	"column name"
	created_at
	"column name"
	external_id
	"column name"
	id
	"column name"
	json
	"column name"
	pid
	"column name"
	status
	"column name"
	title
	"column name"
	updated_at
}

"update columns of table \"shared.collateral\""
enum shared_collateral_update_column {
	"column name"
	created_at
	"column name"
	external_id
	"column name"
	id
	"column name"
	json
	"column name"
	pid
	"column name"
	status
	"column name"
	title
	"column name"
	updated_at
}

"unique or primary key constraints on table \"shared.items\""
enum shared_items_constraint {
	"unique or primary key constraint"
	external_id_key
	"unique or primary key constraint"
	items_external_id_pid_key
	"unique or primary key constraint"
	items_pkey
}

"select columns of table \"shared.items\""
enum shared_items_select_column {
	"column name"
	created_at
	"column name"
	external_id
	"column name"
	id
	"column name"
	json
	"column name"
	pid
	"column name"
	status
	"column name"
	title
	"column name"
	updated_at
}

"update columns of table \"shared.items\""
enum shared_items_update_column {
	"column name"
	created_at
	"column name"
	external_id
	"column name"
	id
	"column name"
	json
	"column name"
	pid
	"column name"
	status
	"column name"
	title
	"column name"
	updated_at
}

"unique or primary key constraints on table \"shared.ldap_organizations\""
enum shared_ldap_organizations_constraint {
	"unique or primary key constraint"
	ldap_organizations_ldap_entryuuid_key
	"unique or primary key constraint"
	ldap_organizations_organization_id_key
	"unique or primary key constraint"
	ldap_organizations_pkey
}

"select columns of table \"shared.ldap_organizations\""
enum shared_ldap_organizations_select_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	ldap_content
	"column name"
	ldap_description
	"column name"
	ldap_entryuuid
	"column name"
	ldap_modifytimestamp
	"column name"
	organization_id
	"column name"
	type
	"column name"
	updated_at
}

"update columns of table \"shared.ldap_organizations\""
enum shared_ldap_organizations_update_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	ldap_content
	"column name"
	ldap_description
	"column name"
	ldap_entryuuid
	"column name"
	ldap_modifytimestamp
	"column name"
	organization_id
	"column name"
	type
	"column name"
	updated_at
}

"unique or primary key constraints on table \"shared.organisations\""
enum shared_organisations_constraint {
	"unique or primary key constraint"
	organisations_pkey
}

"select columns of table \"shared.organisations\""
enum shared_organisations_select_column {
	"column name"
	data
	"column name"
	description
	"column name"
	logo_url
	"column name"
	name
	"column name"
	or_id
	"column name"
	website
}

"update columns of table \"shared.organisations\""
enum shared_organisations_update_column {
	"column name"
	data
	"column name"
	description
	"column name"
	logo_url
	"column name"
	name
	"column name"
	or_id
	"column name"
	website
}

"select columns of table \"shared.organisations_with_users\""
enum shared_organisations_with_users_select_column {
	"column name"
	company_id
	"column name"
	name
}

"unique or primary key constraints on table \"shared.types\""
enum shared_types_constraint {
	"unique or primary key constraint"
	content_types_pkey
}

"select columns of table \"shared.types\""
enum shared_types_select_column {
	"column name"
	id
	"column name"
	label
}

"update columns of table \"shared.types\""
enum shared_types_update_column {
	"column name"
	id
	"column name"
	label
}

"select columns of table \"shared.user_last_blocked\""
enum shared_user_last_blocked_select_column {
	"column name"
	event
	"column name"
	max
	"column name"
	user_id
}

"select columns of table \"shared.user_last_unblocked\""
enum shared_user_last_unblocked_select_column {
	"column name"
	event
	"column name"
	max
	"column name"
	user_id
}

"select columns of table \"shared.user_names\""
enum shared_user_names_select_column {
	"column name"
	first_name
	"column name"
	full_name
	"column name"
	full_name_lower
	"column name"
	last_name
	"column name"
	mail
	"column name"
	profile_id
	"column name"
	user_id
}

"unique or primary key constraints on table \"shared.user_roles\""
enum shared_user_roles_constraint {
	"unique or primary key constraint"
	user_roles_name_key
	"unique or primary key constraint"
	user_roles_pkey
}

"select columns of table \"shared.user_roles\""
enum shared_user_roles_select_column {
	"column name"
	id
	"column name"
	label
	"column name"
	name
}

"update columns of table \"shared.user_roles\""
enum shared_user_roles_update_column {
	"column name"
	id
	"column name"
	label
	"column name"
	name
}

"unique or primary key constraints on table \"shared.user_temp_access\""
enum shared_user_temp_access_constraint {
	"unique or primary key constraint"
	user_temp_access_pkey
}

"select columns of table \"shared.user_temp_access\""
enum shared_user_temp_access_select_column {
	"column name"
	created_at
	"column name"
	from
	"column name"
	until
	"column name"
	updated_at
	"column name"
	user_id
}

"select columns of table \"shared.user_temp_access_status\""
enum shared_user_temp_access_status_select_column {
	"column name"
	status
	"column name"
	uid
}

"update columns of table \"shared.user_temp_access\""
enum shared_user_temp_access_update_column {
	"column name"
	created_at
	"column name"
	from
	"column name"
	until
	"column name"
	updated_at
	"column name"
	user_id
}

"unique or primary key constraints on table \"shared.users\""
enum shared_users_constraint {
	"unique or primary key constraint"
	users_pkey
}

"select columns of table \"shared.users\""
enum shared_users_select_column {
	"column name"
	created_at
	"column name"
	expires_at
	"column name"
	external_uid
	"column name"
	first_name
	"column name"
	id
	"column name"
	is_blocked
	"column name"
	last_access_at
	"column name"
	last_name
	"column name"
	mail
	"column name"
	role_id
	"column name"
	type_label
	"column name"
	uid
	"column name"
	updated_at
}

"update columns of table \"shared.users\""
enum shared_users_update_column {
	"column name"
	created_at
	"column name"
	expires_at
	"column name"
	external_uid
	"column name"
	first_name
	"column name"
	id
	"column name"
	is_blocked
	"column name"
	last_access_at
	"column name"
	last_name
	"column name"
	mail
	"column name"
	role_id
	"column name"
	type_label
	"column name"
	uid
	"column name"
	updated_at
}

"unique or primary key constraints on table \"users.audit_log\""
enum users_audit_log_constraint {
	"unique or primary key constraint"
	audit_log_pkey
}

"select columns of table \"users.audit_log\""
enum users_audit_log_select_column {
	"column name"
	created_at
	"column name"
	event
	"column name"
	id
	"column name"
	message
	"column name"
	user_id
}

"update columns of table \"users.audit_log\""
enum users_audit_log_update_column {
	"column name"
	created_at
	"column name"
	event
	"column name"
	id
	"column name"
	message
	"column name"
	user_id
}

"unique or primary key constraints on table \"users.email_preferences\""
enum users_email_preferences_constraint {
	"unique or primary key constraint"
	email_preferences_pkey
}

"select columns of table \"users.email_preferences\""
enum users_email_preferences_select_column {
	"column name"
	checked
	"column name"
	id
	"column name"
	key
	"column name"
	profile_id
}

"update columns of table \"users.email_preferences\""
enum users_email_preferences_update_column {
	"column name"
	checked
	"column name"
	id
	"column name"
	key
	"column name"
	profile_id
}

"unique or primary key constraints on table \"users.group_user_permission_groups\""
enum users_group_user_permission_groups_constraint {
	"unique or primary key constraint"
	group_user_permission_groups_user_group_id_user_permission_grou
	"unique or primary key constraint"
	user_group_user_permission_groups_pkey
}

"select columns of table \"users.group_user_permission_groups\""
enum users_group_user_permission_groups_select_column {
	"column name"
	id
	"column name"
	user_group_id
	"column name"
	user_permission_group_id
}

"update columns of table \"users.group_user_permission_groups\""
enum users_group_user_permission_groups_update_column {
	"column name"
	id
	"column name"
	user_group_id
	"column name"
	user_permission_group_id
}

"unique or primary key constraints on table \"users.groups\""
enum users_groups_constraint {
	"unique or primary key constraint"
	user_groups_pkey
}

"select columns of table \"users.groups\""
enum users_groups_select_column {
	"column name"
	created_at
	"column name"
	description
	"column name"
	id
	"column name"
	label
	"column name"
	ldap_role
	"column name"
	updated_at
}

"update columns of table \"users.groups\""
enum users_groups_update_column {
	"column name"
	created_at
	"column name"
	description
	"column name"
	id
	"column name"
	label
	"column name"
	ldap_role
	"column name"
	updated_at
}

"unique or primary key constraints on table \"users.idp_map\""
enum users_idp_map_constraint {
	"unique or primary key constraint"
	idp_map_idp_user_id_key
	"unique or primary key constraint"
	idp_map_pkey
	"unique or primary key constraint"
	local_user_id_idp_idp_user_id
}

"select columns of table \"users.idp_map\""
enum users_idp_map_select_column {
	"column name"
	id
	"column name"
	idp
	"column name"
	idp_user_id
	"column name"
	local_user_id
}

"update columns of table \"users.idp_map\""
enum users_idp_map_update_column {
	"column name"
	id
	"column name"
	idp
	"column name"
	idp_user_id
	"column name"
	local_user_id
}

"unique or primary key constraints on table \"users.idps\""
enum users_idps_constraint {
	"unique or primary key constraint"
	idps_pkey
}

enum users_idps_enum {
	"De B2C idp van VIAA: Hetarchief-account."
	HETARCHIEF
	"OAuth service van Klascement op oauth.klascement.be"
	KLASCEMENT
	"OAuth service van Smartschool op oauth.smartschool.be."
	SMARTSCHOOL
	"OAuth service van de Vlaamse Overheid: ACM-IDM using the ov_account_uuid id of the user"
	VLAAMSEOVERHEID__ACCOUNT_ID
	"OAuth service van de Vlaamse Overheid: ACM-IDM using the sub id of the user"
	VLAAMSEOVERHEID__SUB_ID
}

"select columns of table \"users.idps\""
enum users_idps_select_column {
	"column name"
	description
	"column name"
	value
}

"update columns of table \"users.idps\""
enum users_idps_update_column {
	"column name"
	description
	"column name"
	value
}

"unique or primary key constraints on table \"users.notifications\""
enum users_notifications_constraint {
	"unique or primary key constraint"
	notifications_pkey
	"unique or primary key constraint"
	notifications_profile_id_key_key
}

"select columns of table \"users.notifications\""
enum users_notifications_select_column {
	"column name"
	id
	"column name"
	key
	"column name"
	profile_id
	"column name"
	through_email
	"column name"
	through_platform
}

"update columns of table \"users.notifications\""
enum users_notifications_update_column {
	"column name"
	id
	"column name"
	key
	"column name"
	profile_id
	"column name"
	through_email
	"column name"
	through_platform
}

"unique or primary key constraints on table \"users.permission_group_user_permissions\""
enum users_permission_group_user_permissions_constraint {
	"unique or primary key constraint"
	permission_group_user_permissions_user_permission_group_id_user
	"unique or primary key constraint"
	user_permission_group_user_permissions_pkey
}

"select columns of table \"users.permission_group_user_permissions\""
enum users_permission_group_user_permissions_select_column {
	"column name"
	id
	"column name"
	user_permission_group_id
	"column name"
	user_permission_id
}

"update columns of table \"users.permission_group_user_permissions\""
enum users_permission_group_user_permissions_update_column {
	"column name"
	id
	"column name"
	user_permission_group_id
	"column name"
	user_permission_id
}

"unique or primary key constraints on table \"users.permission_groups\""
enum users_permission_groups_constraint {
	"unique or primary key constraint"
	user_permission_groups_pkey
}

"select columns of table \"users.permission_groups\""
enum users_permission_groups_select_column {
	"column name"
	created_at
	"column name"
	description
	"column name"
	id
	"column name"
	label
	"column name"
	updated_at
}

"update columns of table \"users.permission_groups\""
enum users_permission_groups_update_column {
	"column name"
	created_at
	"column name"
	description
	"column name"
	id
	"column name"
	label
	"column name"
	updated_at
}

"select columns of table \"users.permission_matrix_view\""
enum users_permission_matrix_view_select_column {
	"column name"
	group_id
	"column name"
	permission_group_id
	"column name"
	permission_group_label
	"column name"
	permission_id
	"column name"
	permission_label
}

"unique or primary key constraints on table \"users.permissions\""
enum users_permissions_constraint {
	"unique or primary key constraint"
	user_permissions_pkey
}

"select columns of table \"users.permissions\""
enum users_permissions_select_column {
	"column name"
	created_at
	"column name"
	description
	"column name"
	id
	"column name"
	label
	"column name"
	updated_at
}

"update columns of table \"users.permissions\""
enum users_permissions_update_column {
	"column name"
	created_at
	"column name"
	description
	"column name"
	id
	"column name"
	label
	"column name"
	updated_at
}

"unique or primary key constraints on table \"users.profile_classifications\""
enum users_profile_classifications_constraint {
	"unique or primary key constraint"
	profile_classifications_pkey
}

"select columns of table \"users.profile_classifications\""
enum users_profile_classifications_select_column {
	"column name"
	id
	"column name"
	key
	"column name"
	profile_id
}

"update columns of table \"users.profile_classifications\""
enum users_profile_classifications_update_column {
	"column name"
	id
	"column name"
	key
	"column name"
	profile_id
}

"unique or primary key constraints on table \"users.profile_contexts\""
enum users_profile_contexts_constraint {
	"unique or primary key constraint"
	profile_contexts_pkey
}

"select columns of table \"users.profile_contexts\""
enum users_profile_contexts_select_column {
	"column name"
	id
	"column name"
	key
	"column name"
	profile_id
}

"update columns of table \"users.profile_contexts\""
enum users_profile_contexts_update_column {
	"column name"
	id
	"column name"
	key
	"column name"
	profile_id
}

"unique or primary key constraints on table \"users.profile_flags\""
enum users_profile_flags_constraint {
	"unique or primary key constraint"
	profile_flags_pkey
	"unique or primary key constraint"
	profile_flags_profile_id_key_key
}

"select columns of table \"users.profile_flags\""
enum users_profile_flags_select_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	key
	"column name"
	profile_id
	"column name"
	updated_at
}

"update columns of table \"users.profile_flags\""
enum users_profile_flags_update_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	key
	"column name"
	profile_id
	"column name"
	updated_at
}

"unique or primary key constraints on table \"users.profile_organizations\""
enum users_profile_organizations_constraint {
	"unique or primary key constraint"
	profile_organizations_pkey
	"unique or primary key constraint"
	profile_organizations_profile_id_organization_id_unit_id_key
}

"select columns of table \"users.profile_organizations\""
enum users_profile_organizations_select_column {
	"column name"
	id
	"column name"
	organization_id
	"column name"
	profile_id
	"column name"
	unit_id
}

"update columns of table \"users.profile_organizations\""
enum users_profile_organizations_update_column {
	"column name"
	id
	"column name"
	organization_id
	"column name"
	profile_id
	"column name"
	unit_id
}

"unique or primary key constraints on table \"users.profile_preferences\""
enum users_profile_preferences_constraint {
	"unique or primary key constraint"
	profile_preferences_pkey
	"unique or primary key constraint"
	profile_preferences_profile_id_key_key
}

"select columns of table \"users.profile_preferences\""
enum users_profile_preferences_select_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	key
	"column name"
	profile_id
	"column name"
	updated_at
	"column name"
	values
}

"update columns of table \"users.profile_preferences\""
enum users_profile_preferences_update_column {
	"column name"
	created_at
	"column name"
	id
	"column name"
	key
	"column name"
	profile_id
	"column name"
	updated_at
	"column name"
	values
}

"unique or primary key constraints on table \"users.profile_user_groups\""
enum users_profile_user_groups_constraint {
	"unique or primary key constraint"
	profile_user_groups_id_key
	"unique or primary key constraint"
	profile_user_groups_pkey
	"unique or primary key constraint"
	profile_user_groups_user_group_id_user_profile_id_key
}

"select columns of table \"users.profile_user_groups\""
enum users_profile_user_groups_select_column {
	"column name"
	id
	"column name"
	user_group_id
	"column name"
	user_profile_id
}

"update columns of table \"users.profile_user_groups\""
enum users_profile_user_groups_update_column {
	"column name"
	id
	"column name"
	user_group_id
	"column name"
	user_profile_id
}

"unique or primary key constraints on table \"users.profiles\""
enum users_profiles_constraint {
	"unique or primary key constraint"
	profiles_p_id_key
	"unique or primary key constraint"
	profiles_pkey
	"unique or primary key constraint"
	user_profiles_alias_key
}

"select columns of table \"users.profiles\""
enum users_profiles_select_column {
	"column name"
	alias
	"column name"
	alternative_email
	"column name"
	avatar
	"column name"
	bio
	"column name"
	business_category
	"column name"
	company_id
	"column name"
	created_at
	"column name"
	id
	"column name"
	is_deleted
	"column name"
	is_exception
	"column name"
	stamboek
	"column name"
	title
	"column name"
	updated_at
	"column name"
	user_id
}

"update columns of table \"users.profiles\""
enum users_profiles_update_column {
	"column name"
	alias
	"column name"
	alternative_email
	"column name"
	avatar
	"column name"
	bio
	"column name"
	business_category
	"column name"
	company_id
	"column name"
	created_at
	"column name"
	id
	"column name"
	is_deleted
	"column name"
	is_exception
	"column name"
	stamboek
	"column name"
	title
	"column name"
	updated_at
	"column name"
	user_id
}

"select columns of table \"users.summary_view\""
enum users_summary_view_select_column {
	"column name"
	acc_created_at
	"column name"
	acc_updated_at
	"column name"
	business_category
	"column name"
	company_id
	"column name"
	company_name
	"column name"
	first_name
	"column name"
	first_name_lower
	"column name"
	full_name
	"column name"
	group_id
	"column name"
	group_name
	"column name"
	is_blocked
	"column name"
	is_deleted
	"column name"
	is_exception
	"column name"
	last_access_at
	"column name"
	last_name
	"column name"
	last_name_lower
	"column name"
	mail
	"column name"
	pro_created_at
	"column name"
	pro_updated_at
	"column name"
	profile_id
	"column name"
	role_id
	"column name"
	role_name
	"column name"
	stamboek
	"column name"
	user_id
}

scalar bigint

scalar bpchar

scalar date

scalar item_publishing_status

scalar jsonb

scalar time

scalar timestamp

scalar timestamptz

scalar uuid

"expression to compare columns of type Boolean. All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
	_eq: Boolean
	_gt: Boolean
	_gte: Boolean
	_in: [Boolean!]
	_is_null: Boolean
	_lt: Boolean
	_lte: Boolean
	_neq: Boolean
	_nin: [Boolean!]
}

"expression to compare columns of type Int. All fields are combined with logical 'AND'."
input Int_comparison_exp {
	_eq: Int
	_gt: Int
	_gte: Int
	_in: [Int!]
	_is_null: Boolean
	_lt: Int
	_lte: Int
	_neq: Int
	_nin: [Int!]
}

"expression to compare columns of type String. All fields are combined with logical 'AND'."
input String_comparison_exp {
	_eq: String
	_gt: String
	_gte: String
	_ilike: String
	_in: [String!]
	_is_null: Boolean
	_like: String
	_lt: String
	_lte: String
	_neq: String
	_nilike: String
	_nin: [String!]
	_nlike: String
	_nsimilar: String
	_similar: String
}

"order by aggregate values of table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_aggregate_order_by {
	avg: app_assignment_assignment_tags_avg_order_by
	count: order_by
	max: app_assignment_assignment_tags_max_order_by
	min: app_assignment_assignment_tags_min_order_by
	stddev: app_assignment_assignment_tags_stddev_order_by
	stddev_pop: app_assignment_assignment_tags_stddev_pop_order_by
	stddev_samp: app_assignment_assignment_tags_stddev_samp_order_by
	sum: app_assignment_assignment_tags_sum_order_by
	var_pop: app_assignment_assignment_tags_var_pop_order_by
	var_samp: app_assignment_assignment_tags_var_samp_order_by
	variance: app_assignment_assignment_tags_variance_order_by
}

"input type for inserting array relation for remote table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_arr_rel_insert_input {
	data: [app_assignment_assignment_tags_insert_input!]!
	on_conflict: app_assignment_assignment_tags_on_conflict
}

"order by avg() on columns of table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_avg_order_by {
	assignment_tag_id: order_by
	id: order_by
}

"Boolean expression to filter rows from the table \"app.assignment_assignment_tags\". All fields are combined with a logical 'AND'."
input app_assignment_assignment_tags_bool_exp {
	_and: [app_assignment_assignment_tags_bool_exp]
	_not: app_assignment_assignment_tags_bool_exp
	_or: [app_assignment_assignment_tags_bool_exp]
	assignment: app_assignments_bool_exp
	assignment_tag: app_assignment_labels_bool_exp
	assignment_tag_id: Int_comparison_exp
	assignment_uuid: uuid_comparison_exp
	id: Int_comparison_exp
}

"input type for incrementing integer column in table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_inc_input {
	assignment_tag_id: Int
	id: Int
}

"input type for inserting data into table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_insert_input {
	assignment: app_assignments_obj_rel_insert_input
	assignment_tag: app_assignment_labels_obj_rel_insert_input
	assignment_tag_id: Int
	assignment_uuid: uuid
	id: Int
}

"order by max() on columns of table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_max_order_by {
	assignment_tag_id: order_by
	assignment_uuid: order_by
	id: order_by
}

"order by min() on columns of table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_min_order_by {
	assignment_tag_id: order_by
	assignment_uuid: order_by
	id: order_by
}

"input type for inserting object relation for remote table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_obj_rel_insert_input {
	data: app_assignment_assignment_tags_insert_input!
	on_conflict: app_assignment_assignment_tags_on_conflict
}

"on conflict condition type for table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_on_conflict {
	constraint: app_assignment_assignment_tags_constraint!
	update_columns: [app_assignment_assignment_tags_update_column!]!
	where: app_assignment_assignment_tags_bool_exp
}

"ordering options when selecting data from \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_order_by {
	assignment: app_assignments_order_by
	assignment_tag: app_assignment_labels_order_by
	assignment_tag_id: order_by
	assignment_uuid: order_by
	id: order_by
}

"primary key columns input for table: \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_set_input {
	assignment_tag_id: Int
	assignment_uuid: uuid
	id: Int
}

"order by stddev() on columns of table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_stddev_order_by {
	assignment_tag_id: order_by
	id: order_by
}

"order by stddev_pop() on columns of table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_stddev_pop_order_by {
	assignment_tag_id: order_by
	id: order_by
}

"order by stddev_samp() on columns of table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_stddev_samp_order_by {
	assignment_tag_id: order_by
	id: order_by
}

"order by sum() on columns of table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_sum_order_by {
	assignment_tag_id: order_by
	id: order_by
}

"order by var_pop() on columns of table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_var_pop_order_by {
	assignment_tag_id: order_by
	id: order_by
}

"order by var_samp() on columns of table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_var_samp_order_by {
	assignment_tag_id: order_by
	id: order_by
}

"order by variance() on columns of table \"app.assignment_assignment_tags\""
input app_assignment_assignment_tags_variance_order_by {
	assignment_tag_id: order_by
	id: order_by
}

"order by aggregate values of table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_aggregate_order_by {
	avg: app_assignment_blocks_v2_avg_order_by
	count: order_by
	max: app_assignment_blocks_v2_max_order_by
	min: app_assignment_blocks_v2_min_order_by
	stddev: app_assignment_blocks_v2_stddev_order_by
	stddev_pop: app_assignment_blocks_v2_stddev_pop_order_by
	stddev_samp: app_assignment_blocks_v2_stddev_samp_order_by
	sum: app_assignment_blocks_v2_sum_order_by
	var_pop: app_assignment_blocks_v2_var_pop_order_by
	var_samp: app_assignment_blocks_v2_var_samp_order_by
	variance: app_assignment_blocks_v2_variance_order_by
}

"input type for inserting array relation for remote table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_arr_rel_insert_input {
	data: [app_assignment_blocks_v2_insert_input!]!
	on_conflict: app_assignment_blocks_v2_on_conflict
}

"order by avg() on columns of table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_avg_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"Boolean expression to filter rows from the table \"app.assignment_blocks_v2\". All fields are combined with a logical 'AND'."
input app_assignment_blocks_v2_bool_exp {
	_and: [app_assignment_blocks_v2_bool_exp]
	_not: app_assignment_blocks_v2_bool_exp
	_or: [app_assignment_blocks_v2_bool_exp]
	assignment: app_assignments_v2_bool_exp
	assignment_id: uuid_comparison_exp
	created_at: timestamptz_comparison_exp
	custom_description: String_comparison_exp
	custom_title: String_comparison_exp
	end_oc: Int_comparison_exp
	fragment_id: String_comparison_exp
	id: uuid_comparison_exp
	is_deleted: Boolean_comparison_exp
	original_description: String_comparison_exp
	original_title: String_comparison_exp
	position: Int_comparison_exp
	start_oc: Int_comparison_exp
	thumbnail_path: String_comparison_exp
	type: String_comparison_exp
	updated_at: timestamptz_comparison_exp
	use_custom_fields: Boolean_comparison_exp
}

"input type for incrementing integer column in table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_inc_input {
	end_oc: Int
	position: Int
	start_oc: Int
}

"input type for inserting data into table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_insert_input {
	assignment: app_assignments_v2_obj_rel_insert_input
	assignment_id: uuid
	created_at: timestamptz
	custom_description: String
	custom_title: String
	end_oc: Int
	fragment_id: String
	id: uuid
	is_deleted: Boolean
	original_description: String
	original_title: String
	position: Int
	start_oc: Int
	thumbnail_path: String
	type: String
	updated_at: timestamptz
	use_custom_fields: Boolean
}

"order by max() on columns of table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_max_order_by {
	assignment_id: order_by
	created_at: order_by
	custom_description: order_by
	custom_title: order_by
	end_oc: order_by
	fragment_id: order_by
	id: order_by
	original_description: order_by
	original_title: order_by
	position: order_by
	start_oc: order_by
	thumbnail_path: order_by
	type: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_min_order_by {
	assignment_id: order_by
	created_at: order_by
	custom_description: order_by
	custom_title: order_by
	end_oc: order_by
	fragment_id: order_by
	id: order_by
	original_description: order_by
	original_title: order_by
	position: order_by
	start_oc: order_by
	thumbnail_path: order_by
	type: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_obj_rel_insert_input {
	data: app_assignment_blocks_v2_insert_input!
	on_conflict: app_assignment_blocks_v2_on_conflict
}

"on conflict condition type for table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_on_conflict {
	constraint: app_assignment_blocks_v2_constraint!
	update_columns: [app_assignment_blocks_v2_update_column!]!
	where: app_assignment_blocks_v2_bool_exp
}

"ordering options when selecting data from \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_order_by {
	assignment: app_assignments_v2_order_by
	assignment_id: order_by
	created_at: order_by
	custom_description: order_by
	custom_title: order_by
	end_oc: order_by
	fragment_id: order_by
	id: order_by
	is_deleted: order_by
	original_description: order_by
	original_title: order_by
	position: order_by
	start_oc: order_by
	thumbnail_path: order_by
	type: order_by
	updated_at: order_by
	use_custom_fields: order_by
}

"primary key columns input for table: \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_pk_columns_input {
	id: uuid!
}

"input type for updating data in table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_set_input {
	assignment_id: uuid
	created_at: timestamptz
	custom_description: String
	custom_title: String
	end_oc: Int
	fragment_id: String
	id: uuid
	is_deleted: Boolean
	original_description: String
	original_title: String
	position: Int
	start_oc: Int
	thumbnail_path: String
	type: String
	updated_at: timestamptz
	use_custom_fields: Boolean
}

"order by stddev() on columns of table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_stddev_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by stddev_pop() on columns of table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_stddev_pop_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by stddev_samp() on columns of table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_stddev_samp_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by sum() on columns of table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_sum_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by var_pop() on columns of table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_var_pop_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by var_samp() on columns of table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_var_samp_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by variance() on columns of table \"app.assignment_blocks_v2\""
input app_assignment_blocks_v2_variance_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by aggregate values of table \"app.assignment_labels\""
input app_assignment_labels_aggregate_order_by {
	avg: app_assignment_labels_avg_order_by
	count: order_by
	max: app_assignment_labels_max_order_by
	min: app_assignment_labels_min_order_by
	stddev: app_assignment_labels_stddev_order_by
	stddev_pop: app_assignment_labels_stddev_pop_order_by
	stddev_samp: app_assignment_labels_stddev_samp_order_by
	sum: app_assignment_labels_sum_order_by
	var_pop: app_assignment_labels_var_pop_order_by
	var_samp: app_assignment_labels_var_samp_order_by
	variance: app_assignment_labels_variance_order_by
}

"input type for inserting array relation for remote table \"app.assignment_labels\""
input app_assignment_labels_arr_rel_insert_input {
	data: [app_assignment_labels_insert_input!]!
	on_conflict: app_assignment_labels_on_conflict
}

"order by avg() on columns of table \"app.assignment_labels\""
input app_assignment_labels_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.assignment_labels\". All fields are combined with a logical 'AND'."
input app_assignment_labels_bool_exp {
	_and: [app_assignment_labels_bool_exp]
	_not: app_assignment_labels_bool_exp
	_or: [app_assignment_labels_bool_exp]
	color_enum_value: lookup_enum_colors_enum_comparison_exp
	color_override: String_comparison_exp
	enum_color: lookup_enum_colors_bool_exp
	id: Int_comparison_exp
	label: String_comparison_exp
	owner_profile_id: uuid_comparison_exp
	profile: users_profiles_bool_exp
	tags: app_assignment_assignment_tags_bool_exp
}

"input type for incrementing integer column in table \"app.assignment_labels\""
input app_assignment_labels_inc_input {
	id: Int
}

"input type for inserting data into table \"app.assignment_labels\""
input app_assignment_labels_insert_input {
	color_enum_value: lookup_enum_colors_enum
	color_override: String
	enum_color: lookup_enum_colors_obj_rel_insert_input
	id: Int
	label: String
	owner_profile_id: uuid
	profile: users_profiles_obj_rel_insert_input
	tags: app_assignment_assignment_tags_arr_rel_insert_input
}

"order by max() on columns of table \"app.assignment_labels\""
input app_assignment_labels_max_order_by {
	color_override: order_by
	id: order_by
	label: order_by
	owner_profile_id: order_by
}

"order by min() on columns of table \"app.assignment_labels\""
input app_assignment_labels_min_order_by {
	color_override: order_by
	id: order_by
	label: order_by
	owner_profile_id: order_by
}

"input type for inserting object relation for remote table \"app.assignment_labels\""
input app_assignment_labels_obj_rel_insert_input {
	data: app_assignment_labels_insert_input!
	on_conflict: app_assignment_labels_on_conflict
}

"on conflict condition type for table \"app.assignment_labels\""
input app_assignment_labels_on_conflict {
	constraint: app_assignment_labels_constraint!
	update_columns: [app_assignment_labels_update_column!]!
	where: app_assignment_labels_bool_exp
}

"ordering options when selecting data from \"app.assignment_labels\""
input app_assignment_labels_order_by {
	color_enum_value: order_by
	color_override: order_by
	enum_color: lookup_enum_colors_order_by
	id: order_by
	label: order_by
	owner_profile_id: order_by
	profile: users_profiles_order_by
	tags_aggregate: app_assignment_assignment_tags_aggregate_order_by
}

"primary key columns input for table: \"app.assignment_labels\""
input app_assignment_labels_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.assignment_labels\""
input app_assignment_labels_set_input {
	color_enum_value: lookup_enum_colors_enum
	color_override: String
	id: Int
	label: String
	owner_profile_id: uuid
}

"order by stddev() on columns of table \"app.assignment_labels\""
input app_assignment_labels_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.assignment_labels\""
input app_assignment_labels_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.assignment_labels\""
input app_assignment_labels_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.assignment_labels\""
input app_assignment_labels_sum_order_by {
	id: order_by
}

"order by aggregate values of table \"app.assignment_labels_v2\""
input app_assignment_labels_v2_aggregate_order_by {
	count: order_by
	max: app_assignment_labels_v2_max_order_by
	min: app_assignment_labels_v2_min_order_by
}

"input type for inserting array relation for remote table \"app.assignment_labels_v2\""
input app_assignment_labels_v2_arr_rel_insert_input {
	data: [app_assignment_labels_v2_insert_input!]!
	on_conflict: app_assignment_labels_v2_on_conflict
}

"Boolean expression to filter rows from the table \"app.assignment_labels_v2\". All fields are combined with a logical 'AND'."
input app_assignment_labels_v2_bool_exp {
	_and: [app_assignment_labels_v2_bool_exp]
	_not: app_assignment_labels_v2_bool_exp
	_or: [app_assignment_labels_v2_bool_exp]
	color_enum_value: lookup_enum_colors_enum_comparison_exp
	color_override: String_comparison_exp
	enum_color: lookup_enum_colors_bool_exp
	id: uuid_comparison_exp
	label: String_comparison_exp
	owner_profile_id: uuid_comparison_exp
	profile: users_profiles_bool_exp
	type: String_comparison_exp
}

"input type for inserting data into table \"app.assignment_labels_v2\""
input app_assignment_labels_v2_insert_input {
	color_enum_value: lookup_enum_colors_enum
	color_override: String
	enum_color: lookup_enum_colors_obj_rel_insert_input
	id: uuid
	label: String
	owner_profile_id: uuid
	profile: users_profiles_obj_rel_insert_input
	type: String
}

"order by max() on columns of table \"app.assignment_labels_v2\""
input app_assignment_labels_v2_max_order_by {
	color_override: order_by
	id: order_by
	label: order_by
	owner_profile_id: order_by
	type: order_by
}

"order by min() on columns of table \"app.assignment_labels_v2\""
input app_assignment_labels_v2_min_order_by {
	color_override: order_by
	id: order_by
	label: order_by
	owner_profile_id: order_by
	type: order_by
}

"input type for inserting object relation for remote table \"app.assignment_labels_v2\""
input app_assignment_labels_v2_obj_rel_insert_input {
	data: app_assignment_labels_v2_insert_input!
	on_conflict: app_assignment_labels_v2_on_conflict
}

"on conflict condition type for table \"app.assignment_labels_v2\""
input app_assignment_labels_v2_on_conflict {
	constraint: app_assignment_labels_v2_constraint!
	update_columns: [app_assignment_labels_v2_update_column!]!
	where: app_assignment_labels_v2_bool_exp
}

"ordering options when selecting data from \"app.assignment_labels_v2\""
input app_assignment_labels_v2_order_by {
	color_enum_value: order_by
	color_override: order_by
	enum_color: lookup_enum_colors_order_by
	id: order_by
	label: order_by
	owner_profile_id: order_by
	profile: users_profiles_order_by
	type: order_by
}

"primary key columns input for table: \"app.assignment_labels_v2\""
input app_assignment_labels_v2_pk_columns_input {
	id: uuid!
}

"input type for updating data in table \"app.assignment_labels_v2\""
input app_assignment_labels_v2_set_input {
	color_enum_value: lookup_enum_colors_enum
	color_override: String
	id: uuid
	label: String
	owner_profile_id: uuid
	type: String
}

"order by var_pop() on columns of table \"app.assignment_labels\""
input app_assignment_labels_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.assignment_labels\""
input app_assignment_labels_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.assignment_labels\""
input app_assignment_labels_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.assignment_responses\""
input app_assignment_responses_aggregate_order_by {
	avg: app_assignment_responses_avg_order_by
	count: order_by
	max: app_assignment_responses_max_order_by
	min: app_assignment_responses_min_order_by
	stddev: app_assignment_responses_stddev_order_by
	stddev_pop: app_assignment_responses_stddev_pop_order_by
	stddev_samp: app_assignment_responses_stddev_samp_order_by
	sum: app_assignment_responses_sum_order_by
	var_pop: app_assignment_responses_var_pop_order_by
	var_samp: app_assignment_responses_var_samp_order_by
	variance: app_assignment_responses_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_assignment_responses_append_input {
	owner_profile_ids: jsonb
}

"input type for inserting array relation for remote table \"app.assignment_responses\""
input app_assignment_responses_arr_rel_insert_input {
	data: [app_assignment_responses_insert_input!]!
	on_conflict: app_assignment_responses_on_conflict
}

"order by avg() on columns of table \"app.assignment_responses\""
input app_assignment_responses_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.assignment_responses\". All fields are combined with a logical 'AND'."
input app_assignment_responses_bool_exp {
	_and: [app_assignment_responses_bool_exp]
	_not: app_assignment_responses_bool_exp
	_or: [app_assignment_responses_bool_exp]
	assignment: app_assignments_bool_exp
	assignment_uuid: uuid_comparison_exp
	collection: app_collections_bool_exp
	collection_uuid: uuid_comparison_exp
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	is_archived: Boolean_comparison_exp
	owner_profile_ids: jsonb_comparison_exp
	submitted_at: timestamptz_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_assignment_responses_delete_at_path_input {
	owner_profile_ids: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_assignment_responses_delete_elem_input {
	owner_profile_ids: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_assignment_responses_delete_key_input {
	owner_profile_ids: String
}

"input type for incrementing integer column in table \"app.assignment_responses\""
input app_assignment_responses_inc_input {
	id: Int
}

"input type for inserting data into table \"app.assignment_responses\""
input app_assignment_responses_insert_input {
	assignment: app_assignments_obj_rel_insert_input
	assignment_uuid: uuid
	collection: app_collections_obj_rel_insert_input
	collection_uuid: uuid
	created_at: timestamptz
	id: Int
	is_archived: Boolean
	owner_profile_ids: jsonb
	submitted_at: timestamptz
	updated_at: timestamptz
}

"order by max() on columns of table \"app.assignment_responses\""
input app_assignment_responses_max_order_by {
	assignment_uuid: order_by
	collection_uuid: order_by
	created_at: order_by
	id: order_by
	submitted_at: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.assignment_responses\""
input app_assignment_responses_min_order_by {
	assignment_uuid: order_by
	collection_uuid: order_by
	created_at: order_by
	id: order_by
	submitted_at: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.assignment_responses\""
input app_assignment_responses_obj_rel_insert_input {
	data: app_assignment_responses_insert_input!
	on_conflict: app_assignment_responses_on_conflict
}

"on conflict condition type for table \"app.assignment_responses\""
input app_assignment_responses_on_conflict {
	constraint: app_assignment_responses_constraint!
	update_columns: [app_assignment_responses_update_column!]!
	where: app_assignment_responses_bool_exp
}

"ordering options when selecting data from \"app.assignment_responses\""
input app_assignment_responses_order_by {
	assignment: app_assignments_order_by
	assignment_uuid: order_by
	collection: app_collections_order_by
	collection_uuid: order_by
	created_at: order_by
	id: order_by
	is_archived: order_by
	owner_profile_ids: order_by
	submitted_at: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.assignment_responses\""
input app_assignment_responses_pk_columns_input {
	id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_assignment_responses_prepend_input {
	owner_profile_ids: jsonb
}

"input type for updating data in table \"app.assignment_responses\""
input app_assignment_responses_set_input {
	assignment_uuid: uuid
	collection_uuid: uuid
	created_at: timestamptz
	id: Int
	is_archived: Boolean
	owner_profile_ids: jsonb
	submitted_at: timestamptz
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.assignment_responses\""
input app_assignment_responses_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.assignment_responses\""
input app_assignment_responses_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.assignment_responses\""
input app_assignment_responses_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.assignment_responses\""
input app_assignment_responses_sum_order_by {
	id: order_by
}

"order by aggregate values of table \"app.assignment_responses_v2\""
input app_assignment_responses_v2_aggregate_order_by {
	count: order_by
	max: app_assignment_responses_v2_max_order_by
	min: app_assignment_responses_v2_min_order_by
}

"input type for inserting array relation for remote table \"app.assignment_responses_v2\""
input app_assignment_responses_v2_arr_rel_insert_input {
	data: [app_assignment_responses_v2_insert_input!]!
	on_conflict: app_assignment_responses_v2_on_conflict
}

"Boolean expression to filter rows from the table \"app.assignment_responses_v2\". All fields are combined with a logical 'AND'."
input app_assignment_responses_v2_bool_exp {
	_and: [app_assignment_responses_v2_bool_exp]
	_not: app_assignment_responses_v2_bool_exp
	_or: [app_assignment_responses_v2_bool_exp]
	assignment: app_assignments_v2_bool_exp
	assignment_id: uuid_comparison_exp
	collection_title: String_comparison_exp
	created_at: timestamptz_comparison_exp
	id: uuid_comparison_exp
	owner: users_summary_view_bool_exp
	owner_profile_id: uuid_comparison_exp
	profile: users_profiles_bool_exp
	pupil_collection_blocks: app_pupil_collection_blocks_bool_exp
	updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"app.assignment_responses_v2\""
input app_assignment_responses_v2_insert_input {
	assignment: app_assignments_v2_obj_rel_insert_input
	assignment_id: uuid
	collection_title: String
	created_at: timestamptz
	id: uuid
	owner_profile_id: uuid
	profile: users_profiles_obj_rel_insert_input
	pupil_collection_blocks: app_pupil_collection_blocks_arr_rel_insert_input
	updated_at: timestamptz
}

"order by max() on columns of table \"app.assignment_responses_v2\""
input app_assignment_responses_v2_max_order_by {
	assignment_id: order_by
	collection_title: order_by
	created_at: order_by
	id: order_by
	owner_profile_id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.assignment_responses_v2\""
input app_assignment_responses_v2_min_order_by {
	assignment_id: order_by
	collection_title: order_by
	created_at: order_by
	id: order_by
	owner_profile_id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.assignment_responses_v2\""
input app_assignment_responses_v2_obj_rel_insert_input {
	data: app_assignment_responses_v2_insert_input!
	on_conflict: app_assignment_responses_v2_on_conflict
}

"on conflict condition type for table \"app.assignment_responses_v2\""
input app_assignment_responses_v2_on_conflict {
	constraint: app_assignment_responses_v2_constraint!
	update_columns: [app_assignment_responses_v2_update_column!]!
	where: app_assignment_responses_v2_bool_exp
}

"ordering options when selecting data from \"app.assignment_responses_v2\""
input app_assignment_responses_v2_order_by {
	assignment: app_assignments_v2_order_by
	assignment_id: order_by
	collection_title: order_by
	created_at: order_by
	id: order_by
	owner: users_summary_view_order_by
	owner_profile_id: order_by
	profile: users_profiles_order_by
	pupil_collection_blocks_aggregate: app_pupil_collection_blocks_aggregate_order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.assignment_responses_v2\""
input app_assignment_responses_v2_pk_columns_input {
	id: uuid!
}

"input type for updating data in table \"app.assignment_responses_v2\""
input app_assignment_responses_v2_set_input {
	assignment_id: uuid
	collection_title: String
	created_at: timestamptz
	id: uuid
	owner_profile_id: uuid
	updated_at: timestamptz
}

"order by var_pop() on columns of table \"app.assignment_responses\""
input app_assignment_responses_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.assignment_responses\""
input app_assignment_responses_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.assignment_responses\""
input app_assignment_responses_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.assignment_v2_views\""
input app_assignment_v2_views_aggregate_order_by {
	avg: app_assignment_v2_views_avg_order_by
	count: order_by
	max: app_assignment_v2_views_max_order_by
	min: app_assignment_v2_views_min_order_by
	stddev: app_assignment_v2_views_stddev_order_by
	stddev_pop: app_assignment_v2_views_stddev_pop_order_by
	stddev_samp: app_assignment_v2_views_stddev_samp_order_by
	sum: app_assignment_v2_views_sum_order_by
	var_pop: app_assignment_v2_views_var_pop_order_by
	var_samp: app_assignment_v2_views_var_samp_order_by
	variance: app_assignment_v2_views_variance_order_by
}

"input type for inserting array relation for remote table \"app.assignment_v2_views\""
input app_assignment_v2_views_arr_rel_insert_input {
	data: [app_assignment_v2_views_insert_input!]!
	on_conflict: app_assignment_v2_views_on_conflict
}

"order by avg() on columns of table \"app.assignment_v2_views\""
input app_assignment_v2_views_avg_order_by {
	count: order_by
}

"Boolean expression to filter rows from the table \"app.assignment_v2_views\". All fields are combined with a logical 'AND'."
input app_assignment_v2_views_bool_exp {
	_and: [app_assignment_v2_views_bool_exp]
	_not: app_assignment_v2_views_bool_exp
	_or: [app_assignment_v2_views_bool_exp]
	assignment_uuid: uuid_comparison_exp
	count: Int_comparison_exp
	created_at: timestamptz_comparison_exp
	id: uuid_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.assignment_v2_views\""
input app_assignment_v2_views_inc_input {
	count: Int
}

"input type for inserting data into table \"app.assignment_v2_views\""
input app_assignment_v2_views_insert_input {
	assignment_uuid: uuid
	count: Int
	created_at: timestamptz
	id: uuid
	updated_at: timestamptz
}

"order by max() on columns of table \"app.assignment_v2_views\""
input app_assignment_v2_views_max_order_by {
	assignment_uuid: order_by
	count: order_by
	created_at: order_by
	id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.assignment_v2_views\""
input app_assignment_v2_views_min_order_by {
	assignment_uuid: order_by
	count: order_by
	created_at: order_by
	id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.assignment_v2_views\""
input app_assignment_v2_views_obj_rel_insert_input {
	data: app_assignment_v2_views_insert_input!
	on_conflict: app_assignment_v2_views_on_conflict
}

"on conflict condition type for table \"app.assignment_v2_views\""
input app_assignment_v2_views_on_conflict {
	constraint: app_assignment_v2_views_constraint!
	update_columns: [app_assignment_v2_views_update_column!]!
	where: app_assignment_v2_views_bool_exp
}

"ordering options when selecting data from \"app.assignment_v2_views\""
input app_assignment_v2_views_order_by {
	assignment_uuid: order_by
	count: order_by
	created_at: order_by
	id: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.assignment_v2_views\""
input app_assignment_v2_views_pk_columns_input {
	id: uuid!
}

"input type for updating data in table \"app.assignment_v2_views\""
input app_assignment_v2_views_set_input {
	assignment_uuid: uuid
	count: Int
	created_at: timestamptz
	id: uuid
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.assignment_v2_views\""
input app_assignment_v2_views_stddev_order_by {
	count: order_by
}

"order by stddev_pop() on columns of table \"app.assignment_v2_views\""
input app_assignment_v2_views_stddev_pop_order_by {
	count: order_by
}

"order by stddev_samp() on columns of table \"app.assignment_v2_views\""
input app_assignment_v2_views_stddev_samp_order_by {
	count: order_by
}

"order by sum() on columns of table \"app.assignment_v2_views\""
input app_assignment_v2_views_sum_order_by {
	count: order_by
}

"order by var_pop() on columns of table \"app.assignment_v2_views\""
input app_assignment_v2_views_var_pop_order_by {
	count: order_by
}

"order by var_samp() on columns of table \"app.assignment_v2_views\""
input app_assignment_v2_views_var_samp_order_by {
	count: order_by
}

"order by variance() on columns of table \"app.assignment_v2_views\""
input app_assignment_v2_views_variance_order_by {
	count: order_by
}

"order by aggregate values of table \"app.assignments\""
input app_assignments_aggregate_order_by {
	avg: app_assignments_avg_order_by
	count: order_by
	max: app_assignments_max_order_by
	min: app_assignments_min_order_by
	stddev: app_assignments_stddev_order_by
	stddev_pop: app_assignments_stddev_pop_order_by
	stddev_samp: app_assignments_stddev_samp_order_by
	sum: app_assignments_sum_order_by
	var_pop: app_assignments_var_pop_order_by
	var_samp: app_assignments_var_samp_order_by
	variance: app_assignments_variance_order_by
}

"input type for inserting array relation for remote table \"app.assignments\""
input app_assignments_arr_rel_insert_input {
	data: [app_assignments_insert_input!]!
	on_conflict: app_assignments_on_conflict
}

"order by avg() on columns of table \"app.assignments\""
input app_assignments_avg_order_by {
	content_layout: order_by
	id: order_by
}

"Boolean expression to filter rows from the table \"app.assignments\". All fields are combined with a logical 'AND'."
input app_assignments_bool_exp {
	_and: [app_assignments_bool_exp]
	_not: app_assignments_bool_exp
	_or: [app_assignments_bool_exp]
	answer_url: String_comparison_exp
	assignment_type: String_comparison_exp
	available_at: timestamptz_comparison_exp
	class_room: String_comparison_exp
	content_id: String_comparison_exp
	content_label: lookup_enum_assignment_content_labels_enum_comparison_exp
	content_layout: Int_comparison_exp
	created_at: timestamptz_comparison_exp
	deadline_at: timestamptz_comparison_exp
	description: String_comparison_exp
	enum_assignment_content_label: lookup_enum_assignment_content_labels_bool_exp
	id: Int_comparison_exp
	is_archived: Boolean_comparison_exp
	is_collaborative: Boolean_comparison_exp
	is_deleted: Boolean_comparison_exp
	owner: users_summary_view_bool_exp
	owner_profile_id: uuid_comparison_exp
	profile: users_profiles_bool_exp
	responses: app_assignment_responses_bool_exp
	tags: app_assignment_assignment_tags_bool_exp
	title: String_comparison_exp
	updated_at: timestamptz_comparison_exp
	uuid: uuid_comparison_exp
}

"input type for incrementing integer column in table \"app.assignments\""
input app_assignments_inc_input {
	content_layout: Int
	id: Int
}

"input type for inserting data into table \"app.assignments\""
input app_assignments_insert_input {
	answer_url: String
	assignment_type: String
	available_at: timestamptz
	class_room: String
	content_id: String
	content_label: lookup_enum_assignment_content_labels_enum
	content_layout: Int
	created_at: timestamptz
	deadline_at: timestamptz
	description: String
	enum_assignment_content_label: lookup_enum_assignment_content_labels_obj_rel_insert_input
	id: Int
	is_archived: Boolean
	is_collaborative: Boolean
	is_deleted: Boolean
	owner_profile_id: uuid
	profile: users_profiles_obj_rel_insert_input
	responses: app_assignment_responses_arr_rel_insert_input
	tags: app_assignment_assignment_tags_arr_rel_insert_input
	title: String
	updated_at: timestamptz
	uuid: uuid
}

"order by max() on columns of table \"app.assignments\""
input app_assignments_max_order_by {
	answer_url: order_by
	assignment_type: order_by
	available_at: order_by
	class_room: order_by
	content_id: order_by
	content_layout: order_by
	created_at: order_by
	deadline_at: order_by
	description: order_by
	id: order_by
	owner_profile_id: order_by
	title: order_by
	updated_at: order_by
	uuid: order_by
}

"order by min() on columns of table \"app.assignments\""
input app_assignments_min_order_by {
	answer_url: order_by
	assignment_type: order_by
	available_at: order_by
	class_room: order_by
	content_id: order_by
	content_layout: order_by
	created_at: order_by
	deadline_at: order_by
	description: order_by
	id: order_by
	owner_profile_id: order_by
	title: order_by
	updated_at: order_by
	uuid: order_by
}

"input type for inserting object relation for remote table \"app.assignments\""
input app_assignments_obj_rel_insert_input {
	data: app_assignments_insert_input!
	on_conflict: app_assignments_on_conflict
}

"on conflict condition type for table \"app.assignments\""
input app_assignments_on_conflict {
	constraint: app_assignments_constraint!
	update_columns: [app_assignments_update_column!]!
	where: app_assignments_bool_exp
}

"ordering options when selecting data from \"app.assignments\""
input app_assignments_order_by {
	answer_url: order_by
	assignment_type: order_by
	available_at: order_by
	class_room: order_by
	content_id: order_by
	content_label: order_by
	content_layout: order_by
	created_at: order_by
	deadline_at: order_by
	description: order_by
	enum_assignment_content_label: lookup_enum_assignment_content_labels_order_by
	id: order_by
	is_archived: order_by
	is_collaborative: order_by
	is_deleted: order_by
	owner: users_summary_view_order_by
	owner_profile_id: order_by
	profile: users_profiles_order_by
	responses_aggregate: app_assignment_responses_aggregate_order_by
	tags_aggregate: app_assignment_assignment_tags_aggregate_order_by
	title: order_by
	updated_at: order_by
	uuid: order_by
}

"primary key columns input for table: \"app.assignments\""
input app_assignments_pk_columns_input {
	uuid: uuid!
}

"input type for updating data in table \"app.assignments\""
input app_assignments_set_input {
	answer_url: String
	assignment_type: String
	available_at: timestamptz
	class_room: String
	content_id: String
	content_label: lookup_enum_assignment_content_labels_enum
	content_layout: Int
	created_at: timestamptz
	deadline_at: timestamptz
	description: String
	id: Int
	is_archived: Boolean
	is_collaborative: Boolean
	is_deleted: Boolean
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
	uuid: uuid
}

"order by stddev() on columns of table \"app.assignments\""
input app_assignments_stddev_order_by {
	content_layout: order_by
	id: order_by
}

"order by stddev_pop() on columns of table \"app.assignments\""
input app_assignments_stddev_pop_order_by {
	content_layout: order_by
	id: order_by
}

"order by stddev_samp() on columns of table \"app.assignments\""
input app_assignments_stddev_samp_order_by {
	content_layout: order_by
	id: order_by
}

"order by sum() on columns of table \"app.assignments\""
input app_assignments_sum_order_by {
	content_layout: order_by
	id: order_by
}

"order by aggregate values of table \"app.assignments_v2\""
input app_assignments_v2_aggregate_order_by {
	count: order_by
	max: app_assignments_v2_max_order_by
	min: app_assignments_v2_min_order_by
}

"input type for inserting array relation for remote table \"app.assignments_v2\""
input app_assignments_v2_arr_rel_insert_input {
	data: [app_assignments_v2_insert_input!]!
	on_conflict: app_assignments_v2_on_conflict
}

"order by aggregate values of table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_aggregate_order_by {
	avg: app_assignments_v2_assignment_labels_v2_avg_order_by
	count: order_by
	max: app_assignments_v2_assignment_labels_v2_max_order_by
	min: app_assignments_v2_assignment_labels_v2_min_order_by
	stddev: app_assignments_v2_assignment_labels_v2_stddev_order_by
	stddev_pop: app_assignments_v2_assignment_labels_v2_stddev_pop_order_by
	stddev_samp: app_assignments_v2_assignment_labels_v2_stddev_samp_order_by
	sum: app_assignments_v2_assignment_labels_v2_sum_order_by
	var_pop: app_assignments_v2_assignment_labels_v2_var_pop_order_by
	var_samp: app_assignments_v2_assignment_labels_v2_var_samp_order_by
	variance: app_assignments_v2_assignment_labels_v2_variance_order_by
}

"input type for inserting array relation for remote table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_arr_rel_insert_input {
	data: [app_assignments_v2_assignment_labels_v2_insert_input!]!
	on_conflict: app_assignments_v2_assignment_labels_v2_on_conflict
}

"order by avg() on columns of table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.assignments_v2_assignment_labels_v2\". All fields are combined with a logical 'AND'."
input app_assignments_v2_assignment_labels_v2_bool_exp {
	_and: [app_assignments_v2_assignment_labels_v2_bool_exp]
	_not: app_assignments_v2_assignment_labels_v2_bool_exp
	_or: [app_assignments_v2_assignment_labels_v2_bool_exp]
	assignment: app_assignments_v2_bool_exp
	assignment_id: uuid_comparison_exp
	assignment_label: app_assignment_labels_v2_bool_exp
	assignment_label_id: uuid_comparison_exp
	id: Int_comparison_exp
}

"input type for incrementing integer column in table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_inc_input {
	id: Int
}

"input type for inserting data into table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_insert_input {
	assignment: app_assignments_v2_obj_rel_insert_input
	assignment_id: uuid
	assignment_label: app_assignment_labels_v2_obj_rel_insert_input
	assignment_label_id: uuid
	id: Int
}

"order by max() on columns of table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_max_order_by {
	assignment_id: order_by
	assignment_label_id: order_by
	id: order_by
}

"order by min() on columns of table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_min_order_by {
	assignment_id: order_by
	assignment_label_id: order_by
	id: order_by
}

"input type for inserting object relation for remote table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_obj_rel_insert_input {
	data: app_assignments_v2_assignment_labels_v2_insert_input!
	on_conflict: app_assignments_v2_assignment_labels_v2_on_conflict
}

"on conflict condition type for table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_on_conflict {
	constraint: app_assignments_v2_assignment_labels_v2_constraint!
	update_columns: [app_assignments_v2_assignment_labels_v2_update_column!]!
	where: app_assignments_v2_assignment_labels_v2_bool_exp
}

"ordering options when selecting data from \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_order_by {
	assignment: app_assignments_v2_order_by
	assignment_id: order_by
	assignment_label: app_assignment_labels_v2_order_by
	assignment_label_id: order_by
	id: order_by
}

"primary key columns input for table: \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_set_input {
	assignment_id: uuid
	assignment_label_id: uuid
	id: Int
}

"order by stddev() on columns of table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.assignments_v2_assignment_labels_v2\""
input app_assignments_v2_assignment_labels_v2_variance_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.assignments_v2\". All fields are combined with a logical 'AND'."
input app_assignments_v2_bool_exp {
	_and: [app_assignments_v2_bool_exp]
	_not: app_assignments_v2_bool_exp
	_or: [app_assignments_v2_bool_exp]
	answer_url: String_comparison_exp
	assignment_type: String_comparison_exp
	available_at: timestamptz_comparison_exp
	blocks: app_assignment_blocks_v2_bool_exp
	created_at: timestamptz_comparison_exp
	deadline_at: timestamptz_comparison_exp
	description: String_comparison_exp
	id: uuid_comparison_exp
	is_collaborative: Boolean_comparison_exp
	is_deleted: Boolean_comparison_exp
	labels: app_assignments_v2_assignment_labels_v2_bool_exp
	owner: users_summary_view_bool_exp
	owner_profile_id: uuid_comparison_exp
	profile: users_profiles_bool_exp
	responses: app_assignment_responses_v2_bool_exp
	title: String_comparison_exp
	updated_at: timestamptz_comparison_exp
	view_count: app_assignment_v2_views_bool_exp
}

"input type for inserting data into table \"app.assignments_v2\""
input app_assignments_v2_insert_input {
	answer_url: String
	assignment_type: String
	available_at: timestamptz
	blocks: app_assignment_blocks_v2_arr_rel_insert_input
	created_at: timestamptz
	deadline_at: timestamptz
	description: String
	id: uuid
	is_collaborative: Boolean
	is_deleted: Boolean
	labels: app_assignments_v2_assignment_labels_v2_arr_rel_insert_input
	owner_profile_id: uuid
	profile: users_profiles_obj_rel_insert_input
	responses: app_assignment_responses_v2_arr_rel_insert_input
	title: String
	updated_at: timestamptz
	view_count: app_assignment_v2_views_obj_rel_insert_input
}

"order by max() on columns of table \"app.assignments_v2\""
input app_assignments_v2_max_order_by {
	answer_url: order_by
	assignment_type: order_by
	available_at: order_by
	created_at: order_by
	deadline_at: order_by
	description: order_by
	id: order_by
	owner_profile_id: order_by
	title: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.assignments_v2\""
input app_assignments_v2_min_order_by {
	answer_url: order_by
	assignment_type: order_by
	available_at: order_by
	created_at: order_by
	deadline_at: order_by
	description: order_by
	id: order_by
	owner_profile_id: order_by
	title: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.assignments_v2\""
input app_assignments_v2_obj_rel_insert_input {
	data: app_assignments_v2_insert_input!
	on_conflict: app_assignments_v2_on_conflict
}

"on conflict condition type for table \"app.assignments_v2\""
input app_assignments_v2_on_conflict {
	constraint: app_assignments_v2_constraint!
	update_columns: [app_assignments_v2_update_column!]!
	where: app_assignments_v2_bool_exp
}

"ordering options when selecting data from \"app.assignments_v2\""
input app_assignments_v2_order_by {
	answer_url: order_by
	assignment_type: order_by
	available_at: order_by
	blocks_aggregate: app_assignment_blocks_v2_aggregate_order_by
	created_at: order_by
	deadline_at: order_by
	description: order_by
	id: order_by
	is_collaborative: order_by
	is_deleted: order_by
	labels_aggregate: app_assignments_v2_assignment_labels_v2_aggregate_order_by
	owner: users_summary_view_order_by
	owner_profile_id: order_by
	profile: users_profiles_order_by
	responses_aggregate: app_assignment_responses_v2_aggregate_order_by
	title: order_by
	updated_at: order_by
	view_count: app_assignment_v2_views_order_by
}

"primary key columns input for table: \"app.assignments_v2\""
input app_assignments_v2_pk_columns_input {
	id: uuid!
}

"input type for updating data in table \"app.assignments_v2\""
input app_assignments_v2_set_input {
	answer_url: String
	assignment_type: String
	available_at: timestamptz
	created_at: timestamptz
	deadline_at: timestamptz
	description: String
	id: uuid
	is_collaborative: Boolean
	is_deleted: Boolean
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
}

"order by var_pop() on columns of table \"app.assignments\""
input app_assignments_var_pop_order_by {
	content_layout: order_by
	id: order_by
}

"order by var_samp() on columns of table \"app.assignments\""
input app_assignments_var_samp_order_by {
	content_layout: order_by
	id: order_by
}

"order by variance() on columns of table \"app.assignments\""
input app_assignments_variance_order_by {
	content_layout: order_by
	id: order_by
}

"order by aggregate values of table \"app.collection_actualisation_overview\""
input app_collection_actualisation_overview_aggregate_order_by {
	avg: app_collection_actualisation_overview_avg_order_by
	count: order_by
	max: app_collection_actualisation_overview_max_order_by
	min: app_collection_actualisation_overview_min_order_by
	stddev: app_collection_actualisation_overview_stddev_order_by
	stddev_pop: app_collection_actualisation_overview_stddev_pop_order_by
	stddev_samp: app_collection_actualisation_overview_stddev_samp_order_by
	sum: app_collection_actualisation_overview_sum_order_by
	var_pop: app_collection_actualisation_overview_var_pop_order_by
	var_samp: app_collection_actualisation_overview_var_samp_order_by
	variance: app_collection_actualisation_overview_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_collection_actualisation_overview_append_input {
	lom_classification: jsonb
	lom_context: jsonb
}

"order by avg() on columns of table \"app.collection_actualisation_overview\""
input app_collection_actualisation_overview_avg_order_by {
	type_id: order_by
}

"Boolean expression to filter rows from the table \"app.collection_actualisation_overview\". All fields are combined with a logical 'AND'."
input app_collection_actualisation_overview_bool_exp {
	_and: [app_collection_actualisation_overview_bool_exp]
	_not: app_collection_actualisation_overview_bool_exp
	_or: [app_collection_actualisation_overview_bool_exp]
	collection_id: uuid_comparison_exp
	created_at: timestamptz_comparison_exp
	is_public: Boolean_comparison_exp
	labels: app_collection_labels_bool_exp
	last_editor: shared_user_names_bool_exp
	lom_classification: jsonb_comparison_exp
	lom_context: jsonb_comparison_exp
	manager: shared_user_names_bool_exp
	mgmt_created_at: timestamptz_comparison_exp
	mgmt_current_status: String_comparison_exp
	mgmt_last_eindcheck_date: timestamptz_comparison_exp
	mgmt_manager_profile_id: uuid_comparison_exp
	mgmt_status_expires_at: timestamptz_comparison_exp
	mgmt_updated_at: timestamptz_comparison_exp
	owner: users_summary_view_bool_exp
	owner_profile_id: uuid_comparison_exp
	title: String_comparison_exp
	type_id: Int_comparison_exp
	updated_at: timestamptz_comparison_exp
	updated_by_profile_id: uuid_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_collection_actualisation_overview_delete_at_path_input {
	lom_classification: [String]
	lom_context: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_collection_actualisation_overview_delete_elem_input {
	lom_classification: Int
	lom_context: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_collection_actualisation_overview_delete_key_input {
	lom_classification: String
	lom_context: String
}

"order by max() on columns of table \"app.collection_actualisation_overview\""
input app_collection_actualisation_overview_max_order_by {
	collection_id: order_by
	created_at: order_by
	mgmt_created_at: order_by
	mgmt_current_status: order_by
	mgmt_last_eindcheck_date: order_by
	mgmt_manager_profile_id: order_by
	mgmt_status_expires_at: order_by
	mgmt_updated_at: order_by
	owner_profile_id: order_by
	title: order_by
	type_id: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
}

"order by min() on columns of table \"app.collection_actualisation_overview\""
input app_collection_actualisation_overview_min_order_by {
	collection_id: order_by
	created_at: order_by
	mgmt_created_at: order_by
	mgmt_current_status: order_by
	mgmt_last_eindcheck_date: order_by
	mgmt_manager_profile_id: order_by
	mgmt_status_expires_at: order_by
	mgmt_updated_at: order_by
	owner_profile_id: order_by
	title: order_by
	type_id: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
}

"ordering options when selecting data from \"app.collection_actualisation_overview\""
input app_collection_actualisation_overview_order_by {
	collection_id: order_by
	created_at: order_by
	is_public: order_by
	labels_aggregate: app_collection_labels_aggregate_order_by
	last_editor: shared_user_names_order_by
	lom_classification: order_by
	lom_context: order_by
	manager: shared_user_names_order_by
	mgmt_created_at: order_by
	mgmt_current_status: order_by
	mgmt_last_eindcheck_date: order_by
	mgmt_manager_profile_id: order_by
	mgmt_status_expires_at: order_by
	mgmt_updated_at: order_by
	owner: users_summary_view_order_by
	owner_profile_id: order_by
	title: order_by
	type_id: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_collection_actualisation_overview_prepend_input {
	lom_classification: jsonb
	lom_context: jsonb
}

"order by stddev() on columns of table \"app.collection_actualisation_overview\""
input app_collection_actualisation_overview_stddev_order_by {
	type_id: order_by
}

"order by stddev_pop() on columns of table \"app.collection_actualisation_overview\""
input app_collection_actualisation_overview_stddev_pop_order_by {
	type_id: order_by
}

"order by stddev_samp() on columns of table \"app.collection_actualisation_overview\""
input app_collection_actualisation_overview_stddev_samp_order_by {
	type_id: order_by
}

"order by sum() on columns of table \"app.collection_actualisation_overview\""
input app_collection_actualisation_overview_sum_order_by {
	type_id: order_by
}

"order by var_pop() on columns of table \"app.collection_actualisation_overview\""
input app_collection_actualisation_overview_var_pop_order_by {
	type_id: order_by
}

"order by var_samp() on columns of table \"app.collection_actualisation_overview\""
input app_collection_actualisation_overview_var_samp_order_by {
	type_id: order_by
}

"order by variance() on columns of table \"app.collection_actualisation_overview\""
input app_collection_actualisation_overview_variance_order_by {
	type_id: order_by
}

"order by aggregate values of table \"app.collection_bookmarks\""
input app_collection_bookmarks_aggregate_order_by {
	avg: app_collection_bookmarks_avg_order_by
	count: order_by
	max: app_collection_bookmarks_max_order_by
	min: app_collection_bookmarks_min_order_by
	stddev: app_collection_bookmarks_stddev_order_by
	stddev_pop: app_collection_bookmarks_stddev_pop_order_by
	stddev_samp: app_collection_bookmarks_stddev_samp_order_by
	sum: app_collection_bookmarks_sum_order_by
	var_pop: app_collection_bookmarks_var_pop_order_by
	var_samp: app_collection_bookmarks_var_samp_order_by
	variance: app_collection_bookmarks_variance_order_by
}

"input type for inserting array relation for remote table \"app.collection_bookmarks\""
input app_collection_bookmarks_arr_rel_insert_input {
	data: [app_collection_bookmarks_insert_input!]!
	on_conflict: app_collection_bookmarks_on_conflict
}

"order by avg() on columns of table \"app.collection_bookmarks\""
input app_collection_bookmarks_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.collection_bookmarks\". All fields are combined with a logical 'AND'."
input app_collection_bookmarks_bool_exp {
	_and: [app_collection_bookmarks_bool_exp]
	_not: app_collection_bookmarks_bool_exp
	_or: [app_collection_bookmarks_bool_exp]
	bookmarkedCollection: app_collections_bool_exp
	collection_uuid: uuid_comparison_exp
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	profile: users_profiles_bool_exp
	profile_id: uuid_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.collection_bookmarks\""
input app_collection_bookmarks_inc_input {
	id: Int
}

"input type for inserting data into table \"app.collection_bookmarks\""
input app_collection_bookmarks_insert_input {
	bookmarkedCollection: app_collections_obj_rel_insert_input
	collection_uuid: uuid
	created_at: timestamptz
	id: Int
	profile: users_profiles_obj_rel_insert_input
	profile_id: uuid
	updated_at: timestamptz
}

"order by max() on columns of table \"app.collection_bookmarks\""
input app_collection_bookmarks_max_order_by {
	collection_uuid: order_by
	created_at: order_by
	id: order_by
	profile_id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.collection_bookmarks\""
input app_collection_bookmarks_min_order_by {
	collection_uuid: order_by
	created_at: order_by
	id: order_by
	profile_id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.collection_bookmarks\""
input app_collection_bookmarks_obj_rel_insert_input {
	data: app_collection_bookmarks_insert_input!
	on_conflict: app_collection_bookmarks_on_conflict
}

"on conflict condition type for table \"app.collection_bookmarks\""
input app_collection_bookmarks_on_conflict {
	constraint: app_collection_bookmarks_constraint!
	update_columns: [app_collection_bookmarks_update_column!]!
	where: app_collection_bookmarks_bool_exp
}

"ordering options when selecting data from \"app.collection_bookmarks\""
input app_collection_bookmarks_order_by {
	bookmarkedCollection: app_collections_order_by
	collection_uuid: order_by
	created_at: order_by
	id: order_by
	profile: users_profiles_order_by
	profile_id: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.collection_bookmarks\""
input app_collection_bookmarks_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.collection_bookmarks\""
input app_collection_bookmarks_set_input {
	collection_uuid: uuid
	created_at: timestamptz
	id: Int
	profile_id: uuid
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.collection_bookmarks\""
input app_collection_bookmarks_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.collection_bookmarks\""
input app_collection_bookmarks_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.collection_bookmarks\""
input app_collection_bookmarks_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.collection_bookmarks\""
input app_collection_bookmarks_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.collection_bookmarks\""
input app_collection_bookmarks_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.collection_bookmarks\""
input app_collection_bookmarks_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.collection_bookmarks\""
input app_collection_bookmarks_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.collection_counts\""
input app_collection_counts_aggregate_order_by {
	avg: app_collection_counts_avg_order_by
	count: order_by
	max: app_collection_counts_max_order_by
	min: app_collection_counts_min_order_by
	stddev: app_collection_counts_stddev_order_by
	stddev_pop: app_collection_counts_stddev_pop_order_by
	stddev_samp: app_collection_counts_stddev_samp_order_by
	sum: app_collection_counts_sum_order_by
	var_pop: app_collection_counts_var_pop_order_by
	var_samp: app_collection_counts_var_samp_order_by
	variance: app_collection_counts_variance_order_by
}

"order by avg() on columns of table \"app.collection_counts\""
input app_collection_counts_avg_order_by {
	bookmarks: order_by
	copies: order_by
	fragments: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"Boolean expression to filter rows from the table \"app.collection_counts\". All fields are combined with a logical 'AND'."
input app_collection_counts_bool_exp {
	_and: [app_collection_counts_bool_exp]
	_not: app_collection_counts_bool_exp
	_or: [app_collection_counts_bool_exp]
	bookmarks: bigint_comparison_exp
	collection_uuid: uuid_comparison_exp
	copies: bigint_comparison_exp
	fragments: bigint_comparison_exp
	in_assignment: bigint_comparison_exp
	in_collection: bigint_comparison_exp
	plays: Int_comparison_exp
	quick_lane_links: bigint_comparison_exp
	views: Int_comparison_exp
}

"order by max() on columns of table \"app.collection_counts\""
input app_collection_counts_max_order_by {
	bookmarks: order_by
	collection_uuid: order_by
	copies: order_by
	fragments: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by min() on columns of table \"app.collection_counts\""
input app_collection_counts_min_order_by {
	bookmarks: order_by
	collection_uuid: order_by
	copies: order_by
	fragments: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"ordering options when selecting data from \"app.collection_counts\""
input app_collection_counts_order_by {
	bookmarks: order_by
	collection_uuid: order_by
	copies: order_by
	fragments: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by stddev() on columns of table \"app.collection_counts\""
input app_collection_counts_stddev_order_by {
	bookmarks: order_by
	copies: order_by
	fragments: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by stddev_pop() on columns of table \"app.collection_counts\""
input app_collection_counts_stddev_pop_order_by {
	bookmarks: order_by
	copies: order_by
	fragments: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by stddev_samp() on columns of table \"app.collection_counts\""
input app_collection_counts_stddev_samp_order_by {
	bookmarks: order_by
	copies: order_by
	fragments: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by sum() on columns of table \"app.collection_counts\""
input app_collection_counts_sum_order_by {
	bookmarks: order_by
	copies: order_by
	fragments: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by var_pop() on columns of table \"app.collection_counts\""
input app_collection_counts_var_pop_order_by {
	bookmarks: order_by
	copies: order_by
	fragments: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by var_samp() on columns of table \"app.collection_counts\""
input app_collection_counts_var_samp_order_by {
	bookmarks: order_by
	copies: order_by
	fragments: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by variance() on columns of table \"app.collection_counts\""
input app_collection_counts_variance_order_by {
	bookmarks: order_by
	copies: order_by
	fragments: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by aggregate values of table \"app.collection_fragments\""
input app_collection_fragments_aggregate_order_by {
	avg: app_collection_fragments_avg_order_by
	count: order_by
	max: app_collection_fragments_max_order_by
	min: app_collection_fragments_min_order_by
	stddev: app_collection_fragments_stddev_order_by
	stddev_pop: app_collection_fragments_stddev_pop_order_by
	stddev_samp: app_collection_fragments_stddev_samp_order_by
	sum: app_collection_fragments_sum_order_by
	var_pop: app_collection_fragments_var_pop_order_by
	var_samp: app_collection_fragments_var_samp_order_by
	variance: app_collection_fragments_variance_order_by
}

"input type for inserting array relation for remote table \"app.collection_fragments\""
input app_collection_fragments_arr_rel_insert_input {
	data: [app_collection_fragments_insert_input!]!
	on_conflict: app_collection_fragments_on_conflict
}

"order by avg() on columns of table \"app.collection_fragments\""
input app_collection_fragments_avg_order_by {
	end_oc: order_by
	id: order_by
	position: order_by
	start_oc: order_by
}

"Boolean expression to filter rows from the table \"app.collection_fragments\". All fields are combined with a logical 'AND'."
input app_collection_fragments_bool_exp {
	_and: [app_collection_fragments_bool_exp]
	_not: app_collection_fragments_bool_exp
	_or: [app_collection_fragments_bool_exp]
	collection_id: String_comparison_exp
	collection_uuid: uuid_comparison_exp
	created_at: timestamptz_comparison_exp
	custom_description: String_comparison_exp
	custom_title: String_comparison_exp
	end_oc: Int_comparison_exp
	external_id: String_comparison_exp
	id: Int_comparison_exp
	is_copy_of: uuid_comparison_exp
	is_deleted: Boolean_comparison_exp
	position: Int_comparison_exp
	start_oc: Int_comparison_exp
	thumbnail_path: String_comparison_exp
	type: String_comparison_exp
	updated_at: timestamptz_comparison_exp
	use_custom_fields: Boolean_comparison_exp
}

"input type for incrementing integer column in table \"app.collection_fragments\""
input app_collection_fragments_inc_input {
	end_oc: Int
	id: Int
	position: Int
	start_oc: Int
}

"input type for inserting data into table \"app.collection_fragments\""
input app_collection_fragments_insert_input {
	collection_id: String
	collection_uuid: uuid
	created_at: timestamptz
	custom_description: String
	custom_title: String
	end_oc: Int
	external_id: String
	id: Int
	is_copy_of: uuid
	is_deleted: Boolean
	position: Int
	start_oc: Int
	thumbnail_path: String
	type: String
	updated_at: timestamptz
	use_custom_fields: Boolean
}

"order by max() on columns of table \"app.collection_fragments\""
input app_collection_fragments_max_order_by {
	collection_id: order_by
	collection_uuid: order_by
	created_at: order_by
	custom_description: order_by
	custom_title: order_by
	end_oc: order_by
	external_id: order_by
	id: order_by
	is_copy_of: order_by
	position: order_by
	start_oc: order_by
	thumbnail_path: order_by
	type: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.collection_fragments\""
input app_collection_fragments_min_order_by {
	collection_id: order_by
	collection_uuid: order_by
	created_at: order_by
	custom_description: order_by
	custom_title: order_by
	end_oc: order_by
	external_id: order_by
	id: order_by
	is_copy_of: order_by
	position: order_by
	start_oc: order_by
	thumbnail_path: order_by
	type: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.collection_fragments\""
input app_collection_fragments_obj_rel_insert_input {
	data: app_collection_fragments_insert_input!
	on_conflict: app_collection_fragments_on_conflict
}

"on conflict condition type for table \"app.collection_fragments\""
input app_collection_fragments_on_conflict {
	constraint: app_collection_fragments_constraint!
	update_columns: [app_collection_fragments_update_column!]!
	where: app_collection_fragments_bool_exp
}

"ordering options when selecting data from \"app.collection_fragments\""
input app_collection_fragments_order_by {
	collection_id: order_by
	collection_uuid: order_by
	created_at: order_by
	custom_description: order_by
	custom_title: order_by
	end_oc: order_by
	external_id: order_by
	id: order_by
	is_copy_of: order_by
	is_deleted: order_by
	position: order_by
	start_oc: order_by
	thumbnail_path: order_by
	type: order_by
	updated_at: order_by
	use_custom_fields: order_by
}

"primary key columns input for table: \"app.collection_fragments\""
input app_collection_fragments_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.collection_fragments\""
input app_collection_fragments_set_input {
	collection_id: String
	collection_uuid: uuid
	created_at: timestamptz
	custom_description: String
	custom_title: String
	end_oc: Int
	external_id: String
	id: Int
	is_copy_of: uuid
	is_deleted: Boolean
	position: Int
	start_oc: Int
	thumbnail_path: String
	type: String
	updated_at: timestamptz
	use_custom_fields: Boolean
}

"order by stddev() on columns of table \"app.collection_fragments\""
input app_collection_fragments_stddev_order_by {
	end_oc: order_by
	id: order_by
	position: order_by
	start_oc: order_by
}

"order by stddev_pop() on columns of table \"app.collection_fragments\""
input app_collection_fragments_stddev_pop_order_by {
	end_oc: order_by
	id: order_by
	position: order_by
	start_oc: order_by
}

"order by stddev_samp() on columns of table \"app.collection_fragments\""
input app_collection_fragments_stddev_samp_order_by {
	end_oc: order_by
	id: order_by
	position: order_by
	start_oc: order_by
}

"order by sum() on columns of table \"app.collection_fragments\""
input app_collection_fragments_sum_order_by {
	end_oc: order_by
	id: order_by
	position: order_by
	start_oc: order_by
}

"order by var_pop() on columns of table \"app.collection_fragments\""
input app_collection_fragments_var_pop_order_by {
	end_oc: order_by
	id: order_by
	position: order_by
	start_oc: order_by
}

"order by var_samp() on columns of table \"app.collection_fragments\""
input app_collection_fragments_var_samp_order_by {
	end_oc: order_by
	id: order_by
	position: order_by
	start_oc: order_by
}

"order by variance() on columns of table \"app.collection_fragments\""
input app_collection_fragments_variance_order_by {
	end_oc: order_by
	id: order_by
	position: order_by
	start_oc: order_by
}

"order by aggregate values of table \"app.collection_labels\""
input app_collection_labels_aggregate_order_by {
	avg: app_collection_labels_avg_order_by
	count: order_by
	max: app_collection_labels_max_order_by
	min: app_collection_labels_min_order_by
	stddev: app_collection_labels_stddev_order_by
	stddev_pop: app_collection_labels_stddev_pop_order_by
	stddev_samp: app_collection_labels_stddev_samp_order_by
	sum: app_collection_labels_sum_order_by
	var_pop: app_collection_labels_var_pop_order_by
	var_samp: app_collection_labels_var_samp_order_by
	variance: app_collection_labels_variance_order_by
}

"input type for inserting array relation for remote table \"app.collection_labels\""
input app_collection_labels_arr_rel_insert_input {
	data: [app_collection_labels_insert_input!]!
	on_conflict: app_collection_labels_on_conflict
}

"order by avg() on columns of table \"app.collection_labels\""
input app_collection_labels_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.collection_labels\". All fields are combined with a logical 'AND'."
input app_collection_labels_bool_exp {
	_and: [app_collection_labels_bool_exp]
	_not: app_collection_labels_bool_exp
	_or: [app_collection_labels_bool_exp]
	collection: app_collections_bool_exp
	collection_uuid: uuid_comparison_exp
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	label: String_comparison_exp
	label_enum: lookup_enum_collection_labels_bool_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.collection_labels\""
input app_collection_labels_inc_input {
	id: Int
}

"input type for inserting data into table \"app.collection_labels\""
input app_collection_labels_insert_input {
	collection: app_collections_obj_rel_insert_input
	collection_uuid: uuid
	created_at: timestamptz
	id: Int
	label: String
	label_enum: lookup_enum_collection_labels_arr_rel_insert_input
	updated_at: timestamptz
}

"order by max() on columns of table \"app.collection_labels\""
input app_collection_labels_max_order_by {
	collection_uuid: order_by
	created_at: order_by
	id: order_by
	label: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.collection_labels\""
input app_collection_labels_min_order_by {
	collection_uuid: order_by
	created_at: order_by
	id: order_by
	label: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.collection_labels\""
input app_collection_labels_obj_rel_insert_input {
	data: app_collection_labels_insert_input!
	on_conflict: app_collection_labels_on_conflict
}

"on conflict condition type for table \"app.collection_labels\""
input app_collection_labels_on_conflict {
	constraint: app_collection_labels_constraint!
	update_columns: [app_collection_labels_update_column!]!
	where: app_collection_labels_bool_exp
}

"ordering options when selecting data from \"app.collection_labels\""
input app_collection_labels_order_by {
	collection: app_collections_order_by
	collection_uuid: order_by
	created_at: order_by
	id: order_by
	label: order_by
	label_enum_aggregate: lookup_enum_collection_labels_aggregate_order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.collection_labels\""
input app_collection_labels_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.collection_labels\""
input app_collection_labels_set_input {
	collection_uuid: uuid
	created_at: timestamptz
	id: Int
	label: String
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.collection_labels\""
input app_collection_labels_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.collection_labels\""
input app_collection_labels_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.collection_labels\""
input app_collection_labels_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.collection_labels\""
input app_collection_labels_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.collection_labels\""
input app_collection_labels_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.collection_labels\""
input app_collection_labels_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.collection_labels\""
input app_collection_labels_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.collection_management_QC\""
input app_collection_management_QC_aggregate_order_by {
	avg: app_collection_management_QC_avg_order_by
	count: order_by
	max: app_collection_management_QC_max_order_by
	min: app_collection_management_QC_min_order_by
	stddev: app_collection_management_QC_stddev_order_by
	stddev_pop: app_collection_management_QC_stddev_pop_order_by
	stddev_samp: app_collection_management_QC_stddev_samp_order_by
	sum: app_collection_management_QC_sum_order_by
	var_pop: app_collection_management_QC_var_pop_order_by
	var_samp: app_collection_management_QC_var_samp_order_by
	variance: app_collection_management_QC_variance_order_by
}

"input type for inserting array relation for remote table \"app.collection_management_QC\""
input app_collection_management_QC_arr_rel_insert_input {
	data: [app_collection_management_QC_insert_input!]!
	on_conflict: app_collection_management_QC_on_conflict
}

"order by avg() on columns of table \"app.collection_management_QC\""
input app_collection_management_QC_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.collection_management_QC\". All fields are combined with a logical 'AND'."
input app_collection_management_QC_bool_exp {
	_and: [app_collection_management_QC_bool_exp]
	_not: app_collection_management_QC_bool_exp
	_or: [app_collection_management_QC_bool_exp]
	assignee: shared_user_names_bool_exp
	assignee_profile_id: uuid_comparison_exp
	collection: app_collections_bool_exp
	collection_id: uuid_comparison_exp
	comment: String_comparison_exp
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	label: lookup_enum_collection_management_qc_label_bool_exp
	qc_label: lookup_enum_collection_management_qc_label_enum_comparison_exp
	qc_status: Boolean_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.collection_management_QC\""
input app_collection_management_QC_inc_input {
	id: Int
}

"input type for inserting data into table \"app.collection_management_QC\""
input app_collection_management_QC_insert_input {
	assignee_profile_id: uuid
	collection: app_collections_obj_rel_insert_input
	collection_id: uuid
	comment: String
	created_at: timestamptz
	id: Int
	label: lookup_enum_collection_management_qc_label_obj_rel_insert_input
	qc_label: lookup_enum_collection_management_qc_label_enum
	qc_status: Boolean
	updated_at: timestamptz
}

"order by max() on columns of table \"app.collection_management_QC\""
input app_collection_management_QC_max_order_by {
	assignee_profile_id: order_by
	collection_id: order_by
	comment: order_by
	created_at: order_by
	id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.collection_management_QC\""
input app_collection_management_QC_min_order_by {
	assignee_profile_id: order_by
	collection_id: order_by
	comment: order_by
	created_at: order_by
	id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.collection_management_QC\""
input app_collection_management_QC_obj_rel_insert_input {
	data: app_collection_management_QC_insert_input!
	on_conflict: app_collection_management_QC_on_conflict
}

"on conflict condition type for table \"app.collection_management_QC\""
input app_collection_management_QC_on_conflict {
	constraint: app_collection_management_QC_constraint!
	update_columns: [app_collection_management_QC_update_column!]!
	where: app_collection_management_QC_bool_exp
}

"ordering options when selecting data from \"app.collection_management_QC\""
input app_collection_management_QC_order_by {
	assignee: shared_user_names_order_by
	assignee_profile_id: order_by
	collection: app_collections_order_by
	collection_id: order_by
	comment: order_by
	created_at: order_by
	id: order_by
	label: lookup_enum_collection_management_qc_label_order_by
	qc_label: order_by
	qc_status: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.collection_management_QC\""
input app_collection_management_QC_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.collection_management_QC\""
input app_collection_management_QC_set_input {
	assignee_profile_id: uuid
	collection_id: uuid
	comment: String
	created_at: timestamptz
	id: Int
	qc_label: lookup_enum_collection_management_qc_label_enum
	qc_status: Boolean
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.collection_management_QC\""
input app_collection_management_QC_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.collection_management_QC\""
input app_collection_management_QC_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.collection_management_QC\""
input app_collection_management_QC_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.collection_management_QC\""
input app_collection_management_QC_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.collection_management_QC\""
input app_collection_management_QC_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.collection_management_QC\""
input app_collection_management_QC_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.collection_management_QC\""
input app_collection_management_QC_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.collection_management\""
input app_collection_management_aggregate_order_by {
	avg: app_collection_management_avg_order_by
	count: order_by
	max: app_collection_management_max_order_by
	min: app_collection_management_min_order_by
	stddev: app_collection_management_stddev_order_by
	stddev_pop: app_collection_management_stddev_pop_order_by
	stddev_samp: app_collection_management_stddev_samp_order_by
	sum: app_collection_management_sum_order_by
	var_pop: app_collection_management_var_pop_order_by
	var_samp: app_collection_management_var_samp_order_by
	variance: app_collection_management_variance_order_by
}

"input type for inserting array relation for remote table \"app.collection_management\""
input app_collection_management_arr_rel_insert_input {
	data: [app_collection_management_insert_input!]!
	on_conflict: app_collection_management_on_conflict
}

"order by avg() on columns of table \"app.collection_management\""
input app_collection_management_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.collection_management\". All fields are combined with a logical 'AND'."
input app_collection_management_bool_exp {
	QC: app_collection_management_QC_bool_exp
	_and: [app_collection_management_bool_exp]
	_not: app_collection_management_bool_exp
	_or: [app_collection_management_bool_exp]
	collection: app_collections_bool_exp
	collection_id: uuid_comparison_exp
	created_at: timestamptz_comparison_exp
	current_status: String_comparison_exp
	id: Int_comparison_exp
	manager: users_summary_view_bool_exp
	manager_profile_id: uuid_comparison_exp
	note: String_comparison_exp
	status: lookup_enum_collection_management_status_bool_exp
	status_valid_until: timestamptz_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.collection_management\""
input app_collection_management_inc_input {
	id: Int
}

"input type for inserting data into table \"app.collection_management\""
input app_collection_management_insert_input {
	QC: app_collection_management_QC_arr_rel_insert_input
	collection: app_collections_obj_rel_insert_input
	collection_id: uuid
	created_at: timestamptz
	current_status: String
	id: Int
	manager_profile_id: uuid
	note: String
	status: lookup_enum_collection_management_status_obj_rel_insert_input
	status_valid_until: timestamptz
	updated_at: timestamptz
}

"order by max() on columns of table \"app.collection_management\""
input app_collection_management_max_order_by {
	collection_id: order_by
	created_at: order_by
	current_status: order_by
	id: order_by
	manager_profile_id: order_by
	note: order_by
	status_valid_until: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.collection_management\""
input app_collection_management_min_order_by {
	collection_id: order_by
	created_at: order_by
	current_status: order_by
	id: order_by
	manager_profile_id: order_by
	note: order_by
	status_valid_until: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.collection_management\""
input app_collection_management_obj_rel_insert_input {
	data: app_collection_management_insert_input!
	on_conflict: app_collection_management_on_conflict
}

"on conflict condition type for table \"app.collection_management\""
input app_collection_management_on_conflict {
	constraint: app_collection_management_constraint!
	update_columns: [app_collection_management_update_column!]!
	where: app_collection_management_bool_exp
}

"ordering options when selecting data from \"app.collection_management\""
input app_collection_management_order_by {
	QC_aggregate: app_collection_management_QC_aggregate_order_by
	collection: app_collections_order_by
	collection_id: order_by
	created_at: order_by
	current_status: order_by
	id: order_by
	manager: users_summary_view_order_by
	manager_profile_id: order_by
	note: order_by
	status: lookup_enum_collection_management_status_order_by
	status_valid_until: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.collection_management\""
input app_collection_management_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.collection_management\""
input app_collection_management_set_input {
	collection_id: uuid
	created_at: timestamptz
	current_status: String
	id: Int
	manager_profile_id: uuid
	note: String
	status_valid_until: timestamptz
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.collection_management\""
input app_collection_management_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.collection_management\""
input app_collection_management_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.collection_management\""
input app_collection_management_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.collection_management\""
input app_collection_management_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.collection_management\""
input app_collection_management_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.collection_management\""
input app_collection_management_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.collection_management\""
input app_collection_management_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.collection_marcom_klascement_view\""
input app_collection_marcom_klascement_view_aggregate_order_by {
	avg: app_collection_marcom_klascement_view_avg_order_by
	count: order_by
	max: app_collection_marcom_klascement_view_max_order_by
	min: app_collection_marcom_klascement_view_min_order_by
	stddev: app_collection_marcom_klascement_view_stddev_order_by
	stddev_pop: app_collection_marcom_klascement_view_stddev_pop_order_by
	stddev_samp: app_collection_marcom_klascement_view_stddev_samp_order_by
	sum: app_collection_marcom_klascement_view_sum_order_by
	var_pop: app_collection_marcom_klascement_view_var_pop_order_by
	var_samp: app_collection_marcom_klascement_view_var_samp_order_by
	variance: app_collection_marcom_klascement_view_variance_order_by
}

"order by avg() on columns of table \"app.collection_marcom_klascement_view\""
input app_collection_marcom_klascement_view_avg_order_by {
	count: order_by
}

"Boolean expression to filter rows from the table \"app.collection_marcom_klascement_view\". All fields are combined with a logical 'AND'."
input app_collection_marcom_klascement_view_bool_exp {
	_and: [app_collection_marcom_klascement_view_bool_exp]
	_not: app_collection_marcom_klascement_view_bool_exp
	_or: [app_collection_marcom_klascement_view_bool_exp]
	collection_id: uuid_comparison_exp
	count: bigint_comparison_exp
}

"order by max() on columns of table \"app.collection_marcom_klascement_view\""
input app_collection_marcom_klascement_view_max_order_by {
	collection_id: order_by
	count: order_by
}

"order by min() on columns of table \"app.collection_marcom_klascement_view\""
input app_collection_marcom_klascement_view_min_order_by {
	collection_id: order_by
	count: order_by
}

"ordering options when selecting data from \"app.collection_marcom_klascement_view\""
input app_collection_marcom_klascement_view_order_by {
	collection_id: order_by
	count: order_by
}

"order by stddev() on columns of table \"app.collection_marcom_klascement_view\""
input app_collection_marcom_klascement_view_stddev_order_by {
	count: order_by
}

"order by stddev_pop() on columns of table \"app.collection_marcom_klascement_view\""
input app_collection_marcom_klascement_view_stddev_pop_order_by {
	count: order_by
}

"order by stddev_samp() on columns of table \"app.collection_marcom_klascement_view\""
input app_collection_marcom_klascement_view_stddev_samp_order_by {
	count: order_by
}

"order by sum() on columns of table \"app.collection_marcom_klascement_view\""
input app_collection_marcom_klascement_view_sum_order_by {
	count: order_by
}

"order by var_pop() on columns of table \"app.collection_marcom_klascement_view\""
input app_collection_marcom_klascement_view_var_pop_order_by {
	count: order_by
}

"order by var_samp() on columns of table \"app.collection_marcom_klascement_view\""
input app_collection_marcom_klascement_view_var_samp_order_by {
	count: order_by
}

"order by variance() on columns of table \"app.collection_marcom_klascement_view\""
input app_collection_marcom_klascement_view_variance_order_by {
	count: order_by
}

"order by aggregate values of table \"app.collection_marcom_log\""
input app_collection_marcom_log_aggregate_order_by {
	avg: app_collection_marcom_log_avg_order_by
	count: order_by
	max: app_collection_marcom_log_max_order_by
	min: app_collection_marcom_log_min_order_by
	stddev: app_collection_marcom_log_stddev_order_by
	stddev_pop: app_collection_marcom_log_stddev_pop_order_by
	stddev_samp: app_collection_marcom_log_stddev_samp_order_by
	sum: app_collection_marcom_log_sum_order_by
	var_pop: app_collection_marcom_log_var_pop_order_by
	var_samp: app_collection_marcom_log_var_samp_order_by
	variance: app_collection_marcom_log_variance_order_by
}

"input type for inserting array relation for remote table \"app.collection_marcom_log\""
input app_collection_marcom_log_arr_rel_insert_input {
	data: [app_collection_marcom_log_insert_input!]!
	on_conflict: app_collection_marcom_log_on_conflict
}

"order by avg() on columns of table \"app.collection_marcom_log\""
input app_collection_marcom_log_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.collection_marcom_log\". All fields are combined with a logical 'AND'."
input app_collection_marcom_log_bool_exp {
	_and: [app_collection_marcom_log_bool_exp]
	_not: app_collection_marcom_log_bool_exp
	_or: [app_collection_marcom_log_bool_exp]
	channel_name: String_comparison_exp
	channel_type: String_comparison_exp
	collection: app_collections_bool_exp
	collection_id: uuid_comparison_exp
	created_at: timestamptz_comparison_exp
	external_link: String_comparison_exp
	id: Int_comparison_exp
	parent_collection: app_collections_bool_exp
	parent_collection_id: uuid_comparison_exp
	publish_date: timestamptz_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.collection_marcom_log\""
input app_collection_marcom_log_inc_input {
	id: Int
}

"input type for inserting data into table \"app.collection_marcom_log\""
input app_collection_marcom_log_insert_input {
	channel_name: String
	channel_type: String
	collection: app_collections_obj_rel_insert_input
	collection_id: uuid
	created_at: timestamptz
	external_link: String
	id: Int
	parent_collection: app_collections_obj_rel_insert_input
	parent_collection_id: uuid
	publish_date: timestamptz
	updated_at: timestamptz
}

"order by max() on columns of table \"app.collection_marcom_log\""
input app_collection_marcom_log_max_order_by {
	channel_name: order_by
	channel_type: order_by
	collection_id: order_by
	created_at: order_by
	external_link: order_by
	id: order_by
	parent_collection_id: order_by
	publish_date: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.collection_marcom_log\""
input app_collection_marcom_log_min_order_by {
	channel_name: order_by
	channel_type: order_by
	collection_id: order_by
	created_at: order_by
	external_link: order_by
	id: order_by
	parent_collection_id: order_by
	publish_date: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.collection_marcom_log\""
input app_collection_marcom_log_obj_rel_insert_input {
	data: app_collection_marcom_log_insert_input!
	on_conflict: app_collection_marcom_log_on_conflict
}

"on conflict condition type for table \"app.collection_marcom_log\""
input app_collection_marcom_log_on_conflict {
	constraint: app_collection_marcom_log_constraint!
	update_columns: [app_collection_marcom_log_update_column!]!
	where: app_collection_marcom_log_bool_exp
}

"ordering options when selecting data from \"app.collection_marcom_log\""
input app_collection_marcom_log_order_by {
	channel_name: order_by
	channel_type: order_by
	collection: app_collections_order_by
	collection_id: order_by
	created_at: order_by
	external_link: order_by
	id: order_by
	parent_collection: app_collections_order_by
	parent_collection_id: order_by
	publish_date: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.collection_marcom_log\""
input app_collection_marcom_log_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.collection_marcom_log\""
input app_collection_marcom_log_set_input {
	channel_name: String
	channel_type: String
	collection_id: uuid
	created_at: timestamptz
	external_link: String
	id: Int
	parent_collection_id: uuid
	publish_date: timestamptz
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.collection_marcom_log\""
input app_collection_marcom_log_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.collection_marcom_log\""
input app_collection_marcom_log_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.collection_marcom_log\""
input app_collection_marcom_log_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.collection_marcom_log\""
input app_collection_marcom_log_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.collection_marcom_log\""
input app_collection_marcom_log_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.collection_marcom_log\""
input app_collection_marcom_log_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.collection_marcom_log\""
input app_collection_marcom_log_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_aggregate_order_by {
	avg: app_collection_marcom_notes_avg_order_by
	count: order_by
	max: app_collection_marcom_notes_max_order_by
	min: app_collection_marcom_notes_min_order_by
	stddev: app_collection_marcom_notes_stddev_order_by
	stddev_pop: app_collection_marcom_notes_stddev_pop_order_by
	stddev_samp: app_collection_marcom_notes_stddev_samp_order_by
	sum: app_collection_marcom_notes_sum_order_by
	var_pop: app_collection_marcom_notes_var_pop_order_by
	var_samp: app_collection_marcom_notes_var_samp_order_by
	variance: app_collection_marcom_notes_variance_order_by
}

"input type for inserting array relation for remote table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_arr_rel_insert_input {
	data: [app_collection_marcom_notes_insert_input!]!
	on_conflict: app_collection_marcom_notes_on_conflict
}

"order by avg() on columns of table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.collection_marcom_notes\". All fields are combined with a logical 'AND'."
input app_collection_marcom_notes_bool_exp {
	_and: [app_collection_marcom_notes_bool_exp]
	_not: app_collection_marcom_notes_bool_exp
	_or: [app_collection_marcom_notes_bool_exp]
	collection: app_collections_bool_exp
	collection_id: uuid_comparison_exp
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	note: String_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_inc_input {
	id: Int
}

"input type for inserting data into table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_insert_input {
	collection: app_collections_obj_rel_insert_input
	collection_id: uuid
	created_at: timestamptz
	id: Int
	note: String
	updated_at: timestamptz
}

"order by max() on columns of table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_max_order_by {
	collection_id: order_by
	created_at: order_by
	id: order_by
	note: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_min_order_by {
	collection_id: order_by
	created_at: order_by
	id: order_by
	note: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_obj_rel_insert_input {
	data: app_collection_marcom_notes_insert_input!
	on_conflict: app_collection_marcom_notes_on_conflict
}

"on conflict condition type for table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_on_conflict {
	constraint: app_collection_marcom_notes_constraint!
	update_columns: [app_collection_marcom_notes_update_column!]!
	where: app_collection_marcom_notes_bool_exp
}

"ordering options when selecting data from \"app.collection_marcom_notes\""
input app_collection_marcom_notes_order_by {
	collection: app_collections_order_by
	collection_id: order_by
	created_at: order_by
	id: order_by
	note: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.collection_marcom_notes\""
input app_collection_marcom_notes_pk_columns_input {
	collection_id: uuid!
}

"input type for updating data in table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_set_input {
	collection_id: uuid
	created_at: timestamptz
	id: Int
	note: String
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.collection_marcom_notes\""
input app_collection_marcom_notes_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.collection_marcom_overview\""
input app_collection_marcom_overview_aggregate_order_by {
	avg: app_collection_marcom_overview_avg_order_by
	count: order_by
	max: app_collection_marcom_overview_max_order_by
	min: app_collection_marcom_overview_min_order_by
	stddev: app_collection_marcom_overview_stddev_order_by
	stddev_pop: app_collection_marcom_overview_stddev_pop_order_by
	stddev_samp: app_collection_marcom_overview_stddev_samp_order_by
	sum: app_collection_marcom_overview_sum_order_by
	var_pop: app_collection_marcom_overview_var_pop_order_by
	var_samp: app_collection_marcom_overview_var_samp_order_by
	variance: app_collection_marcom_overview_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_collection_marcom_overview_append_input {
	lom_classification: jsonb
	lom_context: jsonb
}

"order by avg() on columns of table \"app.collection_marcom_overview\""
input app_collection_marcom_overview_avg_order_by {
	type_id: order_by
}

"Boolean expression to filter rows from the table \"app.collection_marcom_overview\". All fields are combined with a logical 'AND'."
input app_collection_marcom_overview_bool_exp {
	_and: [app_collection_marcom_overview_bool_exp]
	_not: app_collection_marcom_overview_bool_exp
	_or: [app_collection_marcom_overview_bool_exp]
	channel_name: String_comparison_exp
	channel_type: String_comparison_exp
	collection_id: uuid_comparison_exp
	created_at: timestamptz_comparison_exp
	is_public: Boolean_comparison_exp
	klascement: Boolean_comparison_exp
	labels: app_collection_labels_bool_exp
	last_editor: shared_user_names_bool_exp
	last_marcom_date: timestamptz_comparison_exp
	lom_classification: jsonb_comparison_exp
	lom_context: jsonb_comparison_exp
	owner: users_summary_view_bool_exp
	owner_profile_id: uuid_comparison_exp
	parent_collection_id: uuid_comparison_exp
	title: String_comparison_exp
	type_id: Int_comparison_exp
	updated_at: timestamptz_comparison_exp
	updated_by_profile_id: uuid_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_collection_marcom_overview_delete_at_path_input {
	lom_classification: [String]
	lom_context: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_collection_marcom_overview_delete_elem_input {
	lom_classification: Int
	lom_context: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_collection_marcom_overview_delete_key_input {
	lom_classification: String
	lom_context: String
}

"order by max() on columns of table \"app.collection_marcom_overview\""
input app_collection_marcom_overview_max_order_by {
	channel_name: order_by
	channel_type: order_by
	collection_id: order_by
	created_at: order_by
	last_marcom_date: order_by
	owner_profile_id: order_by
	parent_collection_id: order_by
	title: order_by
	type_id: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
}

"order by min() on columns of table \"app.collection_marcom_overview\""
input app_collection_marcom_overview_min_order_by {
	channel_name: order_by
	channel_type: order_by
	collection_id: order_by
	created_at: order_by
	last_marcom_date: order_by
	owner_profile_id: order_by
	parent_collection_id: order_by
	title: order_by
	type_id: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
}

"ordering options when selecting data from \"app.collection_marcom_overview\""
input app_collection_marcom_overview_order_by {
	channel_name: order_by
	channel_type: order_by
	collection_id: order_by
	created_at: order_by
	is_public: order_by
	klascement: order_by
	labels_aggregate: app_collection_labels_aggregate_order_by
	last_editor: shared_user_names_order_by
	last_marcom_date: order_by
	lom_classification: order_by
	lom_context: order_by
	owner: users_summary_view_order_by
	owner_profile_id: order_by
	parent_collection_id: order_by
	title: order_by
	type_id: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_collection_marcom_overview_prepend_input {
	lom_classification: jsonb
	lom_context: jsonb
}

"order by stddev() on columns of table \"app.collection_marcom_overview\""
input app_collection_marcom_overview_stddev_order_by {
	type_id: order_by
}

"order by stddev_pop() on columns of table \"app.collection_marcom_overview\""
input app_collection_marcom_overview_stddev_pop_order_by {
	type_id: order_by
}

"order by stddev_samp() on columns of table \"app.collection_marcom_overview\""
input app_collection_marcom_overview_stddev_samp_order_by {
	type_id: order_by
}

"order by sum() on columns of table \"app.collection_marcom_overview\""
input app_collection_marcom_overview_sum_order_by {
	type_id: order_by
}

"order by var_pop() on columns of table \"app.collection_marcom_overview\""
input app_collection_marcom_overview_var_pop_order_by {
	type_id: order_by
}

"order by var_samp() on columns of table \"app.collection_marcom_overview\""
input app_collection_marcom_overview_var_samp_order_by {
	type_id: order_by
}

"order by variance() on columns of table \"app.collection_marcom_overview\""
input app_collection_marcom_overview_variance_order_by {
	type_id: order_by
}

"order by aggregate values of table \"app.collection_plays\""
input app_collection_plays_aggregate_order_by {
	avg: app_collection_plays_avg_order_by
	count: order_by
	max: app_collection_plays_max_order_by
	min: app_collection_plays_min_order_by
	stddev: app_collection_plays_stddev_order_by
	stddev_pop: app_collection_plays_stddev_pop_order_by
	stddev_samp: app_collection_plays_stddev_samp_order_by
	sum: app_collection_plays_sum_order_by
	var_pop: app_collection_plays_var_pop_order_by
	var_samp: app_collection_plays_var_samp_order_by
	variance: app_collection_plays_variance_order_by
}

"input type for inserting array relation for remote table \"app.collection_plays\""
input app_collection_plays_arr_rel_insert_input {
	data: [app_collection_plays_insert_input!]!
	on_conflict: app_collection_plays_on_conflict
}

"order by avg() on columns of table \"app.collection_plays\""
input app_collection_plays_avg_order_by {
	count: order_by
	id: order_by
}

"Boolean expression to filter rows from the table \"app.collection_plays\". All fields are combined with a logical 'AND'."
input app_collection_plays_bool_exp {
	_and: [app_collection_plays_bool_exp]
	_not: app_collection_plays_bool_exp
	_or: [app_collection_plays_bool_exp]
	collection_uuid: uuid_comparison_exp
	count: Int_comparison_exp
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	playedCollection: app_collections_bool_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.collection_plays\""
input app_collection_plays_inc_input {
	count: Int
	id: Int
}

"input type for inserting data into table \"app.collection_plays\""
input app_collection_plays_insert_input {
	collection_uuid: uuid
	count: Int
	created_at: timestamptz
	id: Int
	playedCollection: app_collections_obj_rel_insert_input
	updated_at: timestamptz
}

"order by max() on columns of table \"app.collection_plays\""
input app_collection_plays_max_order_by {
	collection_uuid: order_by
	count: order_by
	created_at: order_by
	id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.collection_plays\""
input app_collection_plays_min_order_by {
	collection_uuid: order_by
	count: order_by
	created_at: order_by
	id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.collection_plays\""
input app_collection_plays_obj_rel_insert_input {
	data: app_collection_plays_insert_input!
	on_conflict: app_collection_plays_on_conflict
}

"on conflict condition type for table \"app.collection_plays\""
input app_collection_plays_on_conflict {
	constraint: app_collection_plays_constraint!
	update_columns: [app_collection_plays_update_column!]!
	where: app_collection_plays_bool_exp
}

"ordering options when selecting data from \"app.collection_plays\""
input app_collection_plays_order_by {
	collection_uuid: order_by
	count: order_by
	created_at: order_by
	id: order_by
	playedCollection: app_collections_order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.collection_plays\""
input app_collection_plays_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.collection_plays\""
input app_collection_plays_set_input {
	collection_uuid: uuid
	count: Int
	created_at: timestamptz
	id: Int
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.collection_plays\""
input app_collection_plays_stddev_order_by {
	count: order_by
	id: order_by
}

"order by stddev_pop() on columns of table \"app.collection_plays\""
input app_collection_plays_stddev_pop_order_by {
	count: order_by
	id: order_by
}

"order by stddev_samp() on columns of table \"app.collection_plays\""
input app_collection_plays_stddev_samp_order_by {
	count: order_by
	id: order_by
}

"order by sum() on columns of table \"app.collection_plays\""
input app_collection_plays_sum_order_by {
	count: order_by
	id: order_by
}

"order by var_pop() on columns of table \"app.collection_plays\""
input app_collection_plays_var_pop_order_by {
	count: order_by
	id: order_by
}

"order by var_samp() on columns of table \"app.collection_plays\""
input app_collection_plays_var_samp_order_by {
	count: order_by
	id: order_by
}

"order by variance() on columns of table \"app.collection_plays\""
input app_collection_plays_variance_order_by {
	count: order_by
	id: order_by
}

"order by aggregate values of table \"app.collection_qc_overview\""
input app_collection_qc_overview_aggregate_order_by {
	avg: app_collection_qc_overview_avg_order_by
	count: order_by
	max: app_collection_qc_overview_max_order_by
	min: app_collection_qc_overview_min_order_by
	stddev: app_collection_qc_overview_stddev_order_by
	stddev_pop: app_collection_qc_overview_stddev_pop_order_by
	stddev_samp: app_collection_qc_overview_stddev_samp_order_by
	sum: app_collection_qc_overview_sum_order_by
	var_pop: app_collection_qc_overview_var_pop_order_by
	var_samp: app_collection_qc_overview_var_samp_order_by
	variance: app_collection_qc_overview_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_collection_qc_overview_append_input {
	lom_classification: jsonb
	lom_context: jsonb
}

"order by avg() on columns of table \"app.collection_qc_overview\""
input app_collection_qc_overview_avg_order_by {
	type_id: order_by
}

"Boolean expression to filter rows from the table \"app.collection_qc_overview\". All fields are combined with a logical 'AND'."
input app_collection_qc_overview_bool_exp {
	_and: [app_collection_qc_overview_bool_exp]
	_not: app_collection_qc_overview_bool_exp
	_or: [app_collection_qc_overview_bool_exp]
	collection_id: uuid_comparison_exp
	created_at: timestamptz_comparison_exp
	is_public: Boolean_comparison_exp
	labels: app_collection_labels_bool_exp
	last_editor: shared_user_names_bool_exp
	lom_classification: jsonb_comparison_exp
	lom_context: jsonb_comparison_exp
	mgmt_eind_check_date: timestamptz_comparison_exp
	mgmt_language_check: Boolean_comparison_exp
	mgmt_quality_check: Boolean_comparison_exp
	owner: users_summary_view_bool_exp
	owner_profile_id: uuid_comparison_exp
	title: String_comparison_exp
	type_id: Int_comparison_exp
	updated_at: timestamptz_comparison_exp
	updated_by_profile_id: uuid_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_collection_qc_overview_delete_at_path_input {
	lom_classification: [String]
	lom_context: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_collection_qc_overview_delete_elem_input {
	lom_classification: Int
	lom_context: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_collection_qc_overview_delete_key_input {
	lom_classification: String
	lom_context: String
}

"order by max() on columns of table \"app.collection_qc_overview\""
input app_collection_qc_overview_max_order_by {
	collection_id: order_by
	created_at: order_by
	mgmt_eind_check_date: order_by
	owner_profile_id: order_by
	title: order_by
	type_id: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
}

"order by min() on columns of table \"app.collection_qc_overview\""
input app_collection_qc_overview_min_order_by {
	collection_id: order_by
	created_at: order_by
	mgmt_eind_check_date: order_by
	owner_profile_id: order_by
	title: order_by
	type_id: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
}

"ordering options when selecting data from \"app.collection_qc_overview\""
input app_collection_qc_overview_order_by {
	collection_id: order_by
	created_at: order_by
	is_public: order_by
	labels_aggregate: app_collection_labels_aggregate_order_by
	last_editor: shared_user_names_order_by
	lom_classification: order_by
	lom_context: order_by
	mgmt_eind_check_date: order_by
	mgmt_language_check: order_by
	mgmt_quality_check: order_by
	owner: users_summary_view_order_by
	owner_profile_id: order_by
	title: order_by
	type_id: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_collection_qc_overview_prepend_input {
	lom_classification: jsonb
	lom_context: jsonb
}

"order by stddev() on columns of table \"app.collection_qc_overview\""
input app_collection_qc_overview_stddev_order_by {
	type_id: order_by
}

"order by stddev_pop() on columns of table \"app.collection_qc_overview\""
input app_collection_qc_overview_stddev_pop_order_by {
	type_id: order_by
}

"order by stddev_samp() on columns of table \"app.collection_qc_overview\""
input app_collection_qc_overview_stddev_samp_order_by {
	type_id: order_by
}

"order by sum() on columns of table \"app.collection_qc_overview\""
input app_collection_qc_overview_sum_order_by {
	type_id: order_by
}

"order by var_pop() on columns of table \"app.collection_qc_overview\""
input app_collection_qc_overview_var_pop_order_by {
	type_id: order_by
}

"order by var_samp() on columns of table \"app.collection_qc_overview\""
input app_collection_qc_overview_var_samp_order_by {
	type_id: order_by
}

"order by variance() on columns of table \"app.collection_qc_overview\""
input app_collection_qc_overview_variance_order_by {
	type_id: order_by
}

"order by aggregate values of table \"app.collection_relations\""
input app_collection_relations_aggregate_order_by {
	avg: app_collection_relations_avg_order_by
	count: order_by
	max: app_collection_relations_max_order_by
	min: app_collection_relations_min_order_by
	stddev: app_collection_relations_stddev_order_by
	stddev_pop: app_collection_relations_stddev_pop_order_by
	stddev_samp: app_collection_relations_stddev_samp_order_by
	sum: app_collection_relations_sum_order_by
	var_pop: app_collection_relations_var_pop_order_by
	var_samp: app_collection_relations_var_samp_order_by
	variance: app_collection_relations_variance_order_by
}

"input type for inserting array relation for remote table \"app.collection_relations\""
input app_collection_relations_arr_rel_insert_input {
	data: [app_collection_relations_insert_input!]!
	on_conflict: app_collection_relations_on_conflict
}

"order by avg() on columns of table \"app.collection_relations\""
input app_collection_relations_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.collection_relations\". All fields are combined with a logical 'AND'."
input app_collection_relations_bool_exp {
	_and: [app_collection_relations_bool_exp]
	_not: app_collection_relations_bool_exp
	_or: [app_collection_relations_bool_exp]
	created_at: timestamptz_comparison_exp
	enum_relation_type: lookup_enum_relation_types_bool_exp
	id: Int_comparison_exp
	object: uuid_comparison_exp
	origin: app_collections_bool_exp
	predicate: lookup_enum_relation_types_enum_comparison_exp
	subject: uuid_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.collection_relations\""
input app_collection_relations_inc_input {
	id: Int
}

"input type for inserting data into table \"app.collection_relations\""
input app_collection_relations_insert_input {
	created_at: timestamptz
	enum_relation_type: lookup_enum_relation_types_obj_rel_insert_input
	id: Int
	object: uuid
	origin: app_collections_obj_rel_insert_input
	predicate: lookup_enum_relation_types_enum
	subject: uuid
	updated_at: timestamptz
}

"order by max() on columns of table \"app.collection_relations\""
input app_collection_relations_max_order_by {
	created_at: order_by
	id: order_by
	object: order_by
	subject: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.collection_relations\""
input app_collection_relations_min_order_by {
	created_at: order_by
	id: order_by
	object: order_by
	subject: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.collection_relations\""
input app_collection_relations_obj_rel_insert_input {
	data: app_collection_relations_insert_input!
	on_conflict: app_collection_relations_on_conflict
}

"on conflict condition type for table \"app.collection_relations\""
input app_collection_relations_on_conflict {
	constraint: app_collection_relations_constraint!
	update_columns: [app_collection_relations_update_column!]!
	where: app_collection_relations_bool_exp
}

"ordering options when selecting data from \"app.collection_relations\""
input app_collection_relations_order_by {
	created_at: order_by
	enum_relation_type: lookup_enum_relation_types_order_by
	id: order_by
	object: order_by
	origin: app_collections_order_by
	predicate: order_by
	subject: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.collection_relations\""
input app_collection_relations_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.collection_relations\""
input app_collection_relations_set_input {
	created_at: timestamptz
	id: Int
	object: uuid
	predicate: lookup_enum_relation_types_enum
	subject: uuid
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.collection_relations\""
input app_collection_relations_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.collection_relations\""
input app_collection_relations_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.collection_relations\""
input app_collection_relations_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.collection_relations\""
input app_collection_relations_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.collection_relations\""
input app_collection_relations_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.collection_relations\""
input app_collection_relations_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.collection_relations\""
input app_collection_relations_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.collection_relations_view\""
input app_collection_relations_view_aggregate_order_by {
	count: order_by
	max: app_collection_relations_view_max_order_by
	min: app_collection_relations_view_min_order_by
}

"Boolean expression to filter rows from the table \"app.collection_relations_view\". All fields are combined with a logical 'AND'."
input app_collection_relations_view_bool_exp {
	_and: [app_collection_relations_view_bool_exp]
	_not: app_collection_relations_view_bool_exp
	_or: [app_collection_relations_view_bool_exp]
	object: uuid_comparison_exp
	object_meta: app_collections_bool_exp
	predicate: String_comparison_exp
	subject: uuid_comparison_exp
}

"order by max() on columns of table \"app.collection_relations_view\""
input app_collection_relations_view_max_order_by {
	object: order_by
	predicate: order_by
	subject: order_by
}

"order by min() on columns of table \"app.collection_relations_view\""
input app_collection_relations_view_min_order_by {
	object: order_by
	predicate: order_by
	subject: order_by
}

"ordering options when selecting data from \"app.collection_relations_view\""
input app_collection_relations_view_order_by {
	object: order_by
	object_meta: app_collections_order_by
	predicate: order_by
	subject: order_by
}

"order by aggregate values of table \"app.collection_views\""
input app_collection_views_aggregate_order_by {
	avg: app_collection_views_avg_order_by
	count: order_by
	max: app_collection_views_max_order_by
	min: app_collection_views_min_order_by
	stddev: app_collection_views_stddev_order_by
	stddev_pop: app_collection_views_stddev_pop_order_by
	stddev_samp: app_collection_views_stddev_samp_order_by
	sum: app_collection_views_sum_order_by
	var_pop: app_collection_views_var_pop_order_by
	var_samp: app_collection_views_var_samp_order_by
	variance: app_collection_views_variance_order_by
}

"input type for inserting array relation for remote table \"app.collection_views\""
input app_collection_views_arr_rel_insert_input {
	data: [app_collection_views_insert_input!]!
	on_conflict: app_collection_views_on_conflict
}

"order by avg() on columns of table \"app.collection_views\""
input app_collection_views_avg_order_by {
	count: order_by
	id: order_by
}

"Boolean expression to filter rows from the table \"app.collection_views\". All fields are combined with a logical 'AND'."
input app_collection_views_bool_exp {
	_and: [app_collection_views_bool_exp]
	_not: app_collection_views_bool_exp
	_or: [app_collection_views_bool_exp]
	collection_uuid: uuid_comparison_exp
	count: Int_comparison_exp
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	updated_at: timestamptz_comparison_exp
	viewedCollection: app_collections_bool_exp
}

"input type for incrementing integer column in table \"app.collection_views\""
input app_collection_views_inc_input {
	count: Int
	id: Int
}

"input type for inserting data into table \"app.collection_views\""
input app_collection_views_insert_input {
	collection_uuid: uuid
	count: Int
	created_at: timestamptz
	id: Int
	updated_at: timestamptz
	viewedCollection: app_collections_obj_rel_insert_input
}

"order by max() on columns of table \"app.collection_views\""
input app_collection_views_max_order_by {
	collection_uuid: order_by
	count: order_by
	created_at: order_by
	id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.collection_views\""
input app_collection_views_min_order_by {
	collection_uuid: order_by
	count: order_by
	created_at: order_by
	id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.collection_views\""
input app_collection_views_obj_rel_insert_input {
	data: app_collection_views_insert_input!
	on_conflict: app_collection_views_on_conflict
}

"on conflict condition type for table \"app.collection_views\""
input app_collection_views_on_conflict {
	constraint: app_collection_views_constraint!
	update_columns: [app_collection_views_update_column!]!
	where: app_collection_views_bool_exp
}

"ordering options when selecting data from \"app.collection_views\""
input app_collection_views_order_by {
	collection_uuid: order_by
	count: order_by
	created_at: order_by
	id: order_by
	updated_at: order_by
	viewedCollection: app_collections_order_by
}

"primary key columns input for table: \"app.collection_views\""
input app_collection_views_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.collection_views\""
input app_collection_views_set_input {
	collection_uuid: uuid
	count: Int
	created_at: timestamptz
	id: Int
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.collection_views\""
input app_collection_views_stddev_order_by {
	count: order_by
	id: order_by
}

"order by stddev_pop() on columns of table \"app.collection_views\""
input app_collection_views_stddev_pop_order_by {
	count: order_by
	id: order_by
}

"order by stddev_samp() on columns of table \"app.collection_views\""
input app_collection_views_stddev_samp_order_by {
	count: order_by
	id: order_by
}

"order by sum() on columns of table \"app.collection_views\""
input app_collection_views_sum_order_by {
	count: order_by
	id: order_by
}

"order by var_pop() on columns of table \"app.collection_views\""
input app_collection_views_var_pop_order_by {
	count: order_by
	id: order_by
}

"order by var_samp() on columns of table \"app.collection_views\""
input app_collection_views_var_samp_order_by {
	count: order_by
	id: order_by
}

"order by variance() on columns of table \"app.collection_views\""
input app_collection_views_variance_order_by {
	count: order_by
	id: order_by
}

"order by aggregate values of table \"app.collections\""
input app_collections_aggregate_order_by {
	avg: app_collections_avg_order_by
	count: order_by
	max: app_collections_max_order_by
	min: app_collections_min_order_by
	stddev: app_collections_stddev_order_by
	stddev_pop: app_collections_stddev_pop_order_by
	stddev_samp: app_collections_stddev_samp_order_by
	sum: app_collections_sum_order_by
	var_pop: app_collections_var_pop_order_by
	var_samp: app_collections_var_samp_order_by
	variance: app_collections_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_collections_append_input {
	collection_fragment_ids: jsonb
	lom_classification: jsonb
	lom_context: jsonb
	lom_intendedenduserrole: jsonb
	lom_keywords: jsonb
	lom_languages: jsonb
	lom_typicalagerange: jsonb
}

"input type for inserting array relation for remote table \"app.collections\""
input app_collections_arr_rel_insert_input {
	data: [app_collections_insert_input!]!
	on_conflict: app_collections_on_conflict
}

"order by avg() on columns of table \"app.collections\""
input app_collections_avg_order_by {
	author_external_uid: order_by
	type_id: order_by
}

"Boolean expression to filter rows from the table \"app.collections\". All fields are combined with a logical 'AND'."
input app_collections_bool_exp {
	QC: app_collection_management_QC_bool_exp
	_and: [app_collections_bool_exp]
	_not: app_collections_bool_exp
	_or: [app_collections_bool_exp]
	author_external_uid: Int_comparison_exp
	author_uid: uuid_comparison_exp
	avo1_id: String_comparison_exp
	briefing_id: String_comparison_exp
	collection_bookmarks: app_collection_bookmarks_bool_exp
	collection_fragment_ids: jsonb_comparison_exp
	collection_fragments: app_collection_fragments_bool_exp
	collection_labels: app_collection_labels_bool_exp
	counts: app_collection_counts_bool_exp
	created_at: timestamptz_comparison_exp
	depublish_at: timestamptz_comparison_exp
	description: String_comparison_exp
	description_long: String_comparison_exp
	external_id: String_comparison_exp
	has_klascement: app_collection_marcom_klascement_view_bool_exp
	id: uuid_comparison_exp
	is_deleted: Boolean_comparison_exp
	is_managed: Boolean_comparison_exp
	is_public: Boolean_comparison_exp
	last_editor: users_summary_view_bool_exp
	lom_classification: jsonb_comparison_exp
	lom_context: jsonb_comparison_exp
	lom_intendedenduserrole: jsonb_comparison_exp
	lom_keywords: jsonb_comparison_exp
	lom_languages: jsonb_comparison_exp
	lom_typicalagerange: jsonb_comparison_exp
	management: app_collection_management_bool_exp
	marcom: app_collection_marcom_log_bool_exp
	marcom_note: app_collection_marcom_notes_bool_exp
	marcom_notes: app_collection_marcom_notes_bool_exp
	note: String_comparison_exp
	organisation: shared_organisations_bool_exp
	organisation_id: String_comparison_exp
	owner: users_summary_view_bool_exp
	owner_profile_id: uuid_comparison_exp
	play_counts: app_collection_plays_bool_exp
	profile: users_profiles_bool_exp
	publish_at: timestamptz_comparison_exp
	published_at: timestamptz_comparison_exp
	relations: app_collection_relations_view_bool_exp
	seo_image_path: String_comparison_exp
	thumbnail_path: String_comparison_exp
	title: String_comparison_exp
	type: shared_types_bool_exp
	type_id: Int_comparison_exp
	updated_at: timestamptz_comparison_exp
	updated_by: users_profiles_bool_exp
	updated_by_profile_id: uuid_comparison_exp
	usage_counts: app_usage_counts_bool_exp
	view_counts: app_collection_views_bool_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_collections_delete_at_path_input {
	collection_fragment_ids: [String]
	lom_classification: [String]
	lom_context: [String]
	lom_intendedenduserrole: [String]
	lom_keywords: [String]
	lom_languages: [String]
	lom_typicalagerange: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_collections_delete_elem_input {
	collection_fragment_ids: Int
	lom_classification: Int
	lom_context: Int
	lom_intendedenduserrole: Int
	lom_keywords: Int
	lom_languages: Int
	lom_typicalagerange: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_collections_delete_key_input {
	collection_fragment_ids: String
	lom_classification: String
	lom_context: String
	lom_intendedenduserrole: String
	lom_keywords: String
	lom_languages: String
	lom_typicalagerange: String
}

"input type for incrementing integer column in table \"app.collections\""
input app_collections_inc_input {
	author_external_uid: Int
	type_id: Int
}

"input type for inserting data into table \"app.collections\""
input app_collections_insert_input {
	QC: app_collection_management_QC_arr_rel_insert_input
	author_external_uid: Int
	author_uid: uuid
	avo1_id: String
	briefing_id: String
	collection_bookmarks: app_collection_bookmarks_arr_rel_insert_input
	collection_fragment_ids: jsonb
	collection_fragments: app_collection_fragments_arr_rel_insert_input
	collection_labels: app_collection_labels_arr_rel_insert_input
	created_at: timestamptz
	depublish_at: timestamptz
	description: String
	description_long: String
	external_id: String
	id: uuid
	is_deleted: Boolean
	is_managed: Boolean
	is_public: Boolean
	lom_classification: jsonb
	lom_context: jsonb
	lom_intendedenduserrole: jsonb
	lom_keywords: jsonb
	lom_languages: jsonb
	lom_typicalagerange: jsonb
	management: app_collection_management_obj_rel_insert_input
	marcom: app_collection_marcom_log_arr_rel_insert_input
	marcom_note: app_collection_marcom_notes_obj_rel_insert_input
	marcom_notes: app_collection_marcom_notes_arr_rel_insert_input
	note: String
	organisation: shared_organisations_obj_rel_insert_input
	organisation_id: String
	owner_profile_id: uuid
	play_counts: app_collection_plays_arr_rel_insert_input
	profile: users_profiles_obj_rel_insert_input
	publish_at: timestamptz
	published_at: timestamptz
	seo_image_path: String
	thumbnail_path: String
	title: String
	type: shared_types_obj_rel_insert_input
	type_id: Int
	updated_at: timestamptz
	updated_by: users_profiles_obj_rel_insert_input
	updated_by_profile_id: uuid
	view_counts: app_collection_views_arr_rel_insert_input
}

"order by max() on columns of table \"app.collections\""
input app_collections_max_order_by {
	author_external_uid: order_by
	author_uid: order_by
	avo1_id: order_by
	briefing_id: order_by
	created_at: order_by
	depublish_at: order_by
	description: order_by
	description_long: order_by
	external_id: order_by
	id: order_by
	note: order_by
	organisation_id: order_by
	owner_profile_id: order_by
	publish_at: order_by
	published_at: order_by
	seo_image_path: order_by
	thumbnail_path: order_by
	title: order_by
	type_id: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
}

"order by min() on columns of table \"app.collections\""
input app_collections_min_order_by {
	author_external_uid: order_by
	author_uid: order_by
	avo1_id: order_by
	briefing_id: order_by
	created_at: order_by
	depublish_at: order_by
	description: order_by
	description_long: order_by
	external_id: order_by
	id: order_by
	note: order_by
	organisation_id: order_by
	owner_profile_id: order_by
	publish_at: order_by
	published_at: order_by
	seo_image_path: order_by
	thumbnail_path: order_by
	title: order_by
	type_id: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
}

"input type for inserting object relation for remote table \"app.collections\""
input app_collections_obj_rel_insert_input {
	data: app_collections_insert_input!
	on_conflict: app_collections_on_conflict
}

"on conflict condition type for table \"app.collections\""
input app_collections_on_conflict {
	constraint: app_collections_constraint!
	update_columns: [app_collections_update_column!]!
	where: app_collections_bool_exp
}

"ordering options when selecting data from \"app.collections\""
input app_collections_order_by {
	QC_aggregate: app_collection_management_QC_aggregate_order_by
	author_external_uid: order_by
	author_uid: order_by
	avo1_id: order_by
	briefing_id: order_by
	collection_bookmarks_aggregate: app_collection_bookmarks_aggregate_order_by
	collection_fragment_ids: order_by
	collection_fragments_aggregate: app_collection_fragments_aggregate_order_by
	collection_labels_aggregate: app_collection_labels_aggregate_order_by
	counts: app_collection_counts_order_by
	created_at: order_by
	depublish_at: order_by
	description: order_by
	description_long: order_by
	external_id: order_by
	has_klascement: app_collection_marcom_klascement_view_order_by
	id: order_by
	is_deleted: order_by
	is_managed: order_by
	is_public: order_by
	last_editor: users_summary_view_order_by
	lom_classification: order_by
	lom_context: order_by
	lom_intendedenduserrole: order_by
	lom_keywords: order_by
	lom_languages: order_by
	lom_typicalagerange: order_by
	management: app_collection_management_order_by
	marcom_aggregate: app_collection_marcom_log_aggregate_order_by
	marcom_note: app_collection_marcom_notes_order_by
	marcom_notes_aggregate: app_collection_marcom_notes_aggregate_order_by
	note: order_by
	organisation: shared_organisations_order_by
	organisation_id: order_by
	owner: users_summary_view_order_by
	owner_profile_id: order_by
	play_counts_aggregate: app_collection_plays_aggregate_order_by
	profile: users_profiles_order_by
	publish_at: order_by
	published_at: order_by
	relations_aggregate: app_collection_relations_view_aggregate_order_by
	seo_image_path: order_by
	thumbnail_path: order_by
	title: order_by
	type: shared_types_order_by
	type_id: order_by
	updated_at: order_by
	updated_by: users_profiles_order_by
	updated_by_profile_id: order_by
	usage_counts_aggregate: app_usage_counts_aggregate_order_by
	view_counts_aggregate: app_collection_views_aggregate_order_by
}

"primary key columns input for table: \"app.collections\""
input app_collections_pk_columns_input {
	id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_collections_prepend_input {
	collection_fragment_ids: jsonb
	lom_classification: jsonb
	lom_context: jsonb
	lom_intendedenduserrole: jsonb
	lom_keywords: jsonb
	lom_languages: jsonb
	lom_typicalagerange: jsonb
}

"input type for updating data in table \"app.collections\""
input app_collections_set_input {
	author_external_uid: Int
	author_uid: uuid
	avo1_id: String
	briefing_id: String
	collection_fragment_ids: jsonb
	created_at: timestamptz
	depublish_at: timestamptz
	description: String
	description_long: String
	external_id: String
	id: uuid
	is_deleted: Boolean
	is_managed: Boolean
	is_public: Boolean
	lom_classification: jsonb
	lom_context: jsonb
	lom_intendedenduserrole: jsonb
	lom_keywords: jsonb
	lom_languages: jsonb
	lom_typicalagerange: jsonb
	note: String
	organisation_id: String
	owner_profile_id: uuid
	publish_at: timestamptz
	published_at: timestamptz
	seo_image_path: String
	thumbnail_path: String
	title: String
	type_id: Int
	updated_at: timestamptz
	updated_by_profile_id: uuid
}

"order by stddev() on columns of table \"app.collections\""
input app_collections_stddev_order_by {
	author_external_uid: order_by
	type_id: order_by
}

"order by stddev_pop() on columns of table \"app.collections\""
input app_collections_stddev_pop_order_by {
	author_external_uid: order_by
	type_id: order_by
}

"order by stddev_samp() on columns of table \"app.collections\""
input app_collections_stddev_samp_order_by {
	author_external_uid: order_by
	type_id: order_by
}

"order by sum() on columns of table \"app.collections\""
input app_collections_sum_order_by {
	author_external_uid: order_by
	type_id: order_by
}

"order by var_pop() on columns of table \"app.collections\""
input app_collections_var_pop_order_by {
	author_external_uid: order_by
	type_id: order_by
}

"order by var_samp() on columns of table \"app.collections\""
input app_collections_var_samp_order_by {
	author_external_uid: order_by
	type_id: order_by
}

"order by variance() on columns of table \"app.collections\""
input app_collections_variance_order_by {
	author_external_uid: order_by
	type_id: order_by
}

"order by aggregate values of table \"app.content\""
input app_content_aggregate_order_by {
	avg: app_content_avg_order_by
	count: order_by
	max: app_content_max_order_by
	min: app_content_min_order_by
	stddev: app_content_stddev_order_by
	stddev_pop: app_content_stddev_pop_order_by
	stddev_samp: app_content_stddev_samp_order_by
	sum: app_content_sum_order_by
	var_pop: app_content_var_pop_order_by
	var_samp: app_content_var_samp_order_by
	variance: app_content_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_content_append_input {
	user_group_ids: jsonb
}

"input type for inserting array relation for remote table \"app.content\""
input app_content_arr_rel_insert_input {
	data: [app_content_insert_input!]!
	on_conflict: app_content_on_conflict
}

"order by aggregate values of table \"app.content_assets\""
input app_content_assets_aggregate_order_by {
	avg: app_content_assets_avg_order_by
	count: order_by
	max: app_content_assets_max_order_by
	min: app_content_assets_min_order_by
	stddev: app_content_assets_stddev_order_by
	stddev_pop: app_content_assets_stddev_pop_order_by
	stddev_samp: app_content_assets_stddev_samp_order_by
	sum: app_content_assets_sum_order_by
	var_pop: app_content_assets_var_pop_order_by
	var_samp: app_content_assets_var_samp_order_by
	variance: app_content_assets_variance_order_by
}

"input type for inserting array relation for remote table \"app.content_assets\""
input app_content_assets_arr_rel_insert_input {
	data: [app_content_assets_insert_input!]!
	on_conflict: app_content_assets_on_conflict
}

"order by avg() on columns of table \"app.content_assets\""
input app_content_assets_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.content_assets\". All fields are combined with a logical 'AND'."
input app_content_assets_bool_exp {
	_and: [app_content_assets_bool_exp]
	_not: app_content_assets_bool_exp
	_or: [app_content_assets_bool_exp]
	content_asset_type_id: String_comparison_exp
	created_at: timestamptz_comparison_exp
	description: String_comparison_exp
	id: Int_comparison_exp
	label: String_comparison_exp
	owner_id: String_comparison_exp
	path: String_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.content_assets\""
input app_content_assets_inc_input {
	id: Int
}

"input type for inserting data into table \"app.content_assets\""
input app_content_assets_insert_input {
	content_asset_type_id: String
	created_at: timestamptz
	description: String
	id: Int
	label: String
	owner_id: String
	path: String
	updated_at: timestamptz
}

"order by max() on columns of table \"app.content_assets\""
input app_content_assets_max_order_by {
	content_asset_type_id: order_by
	created_at: order_by
	description: order_by
	id: order_by
	label: order_by
	owner_id: order_by
	path: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.content_assets\""
input app_content_assets_min_order_by {
	content_asset_type_id: order_by
	created_at: order_by
	description: order_by
	id: order_by
	label: order_by
	owner_id: order_by
	path: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.content_assets\""
input app_content_assets_obj_rel_insert_input {
	data: app_content_assets_insert_input!
	on_conflict: app_content_assets_on_conflict
}

"on conflict condition type for table \"app.content_assets\""
input app_content_assets_on_conflict {
	constraint: app_content_assets_constraint!
	update_columns: [app_content_assets_update_column!]!
	where: app_content_assets_bool_exp
}

"ordering options when selecting data from \"app.content_assets\""
input app_content_assets_order_by {
	content_asset_type_id: order_by
	created_at: order_by
	description: order_by
	id: order_by
	label: order_by
	owner_id: order_by
	path: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.content_assets\""
input app_content_assets_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.content_assets\""
input app_content_assets_set_input {
	content_asset_type_id: String
	created_at: timestamptz
	description: String
	id: Int
	label: String
	owner_id: String
	path: String
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.content_assets\""
input app_content_assets_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.content_assets\""
input app_content_assets_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.content_assets\""
input app_content_assets_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.content_assets\""
input app_content_assets_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.content_assets\""
input app_content_assets_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.content_assets\""
input app_content_assets_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.content_assets\""
input app_content_assets_variance_order_by {
	id: order_by
}

"order by avg() on columns of table \"app.content\""
input app_content_avg_order_by {
	id: order_by
}

"order by aggregate values of table \"app.content_blocks\""
input app_content_blocks_aggregate_order_by {
	avg: app_content_blocks_avg_order_by
	count: order_by
	max: app_content_blocks_max_order_by
	min: app_content_blocks_min_order_by
	stddev: app_content_blocks_stddev_order_by
	stddev_pop: app_content_blocks_stddev_pop_order_by
	stddev_samp: app_content_blocks_stddev_samp_order_by
	sum: app_content_blocks_sum_order_by
	var_pop: app_content_blocks_var_pop_order_by
	var_samp: app_content_blocks_var_samp_order_by
	variance: app_content_blocks_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_content_blocks_append_input {
	variables: jsonb
}

"input type for inserting array relation for remote table \"app.content_blocks\""
input app_content_blocks_arr_rel_insert_input {
	data: [app_content_blocks_insert_input!]!
	on_conflict: app_content_blocks_on_conflict
}

"order by avg() on columns of table \"app.content_blocks\""
input app_content_blocks_avg_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"Boolean expression to filter rows from the table \"app.content_blocks\". All fields are combined with a logical 'AND'."
input app_content_blocks_bool_exp {
	_and: [app_content_blocks_bool_exp]
	_not: app_content_blocks_bool_exp
	_or: [app_content_blocks_bool_exp]
	contentBycontentId: app_content_bool_exp
	content_block_type: lookup_enum_content_block_types_enum_comparison_exp
	content_id: Int_comparison_exp
	created_at: timestamptz_comparison_exp
	enum_content_block_type: lookup_enum_content_block_types_bool_exp
	id: Int_comparison_exp
	position: Int_comparison_exp
	updated_at: timestamptz_comparison_exp
	variables: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_content_blocks_delete_at_path_input {
	variables: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_content_blocks_delete_elem_input {
	variables: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_content_blocks_delete_key_input {
	variables: String
}

"input type for incrementing integer column in table \"app.content_blocks\""
input app_content_blocks_inc_input {
	content_id: Int
	id: Int
	position: Int
}

"input type for inserting data into table \"app.content_blocks\""
input app_content_blocks_insert_input {
	contentBycontentId: app_content_obj_rel_insert_input
	content_block_type: lookup_enum_content_block_types_enum
	content_id: Int
	created_at: timestamptz
	enum_content_block_type: lookup_enum_content_block_types_obj_rel_insert_input
	id: Int
	position: Int
	updated_at: timestamptz
	variables: jsonb
}

"order by max() on columns of table \"app.content_blocks\""
input app_content_blocks_max_order_by {
	content_id: order_by
	created_at: order_by
	id: order_by
	position: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.content_blocks\""
input app_content_blocks_min_order_by {
	content_id: order_by
	created_at: order_by
	id: order_by
	position: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.content_blocks\""
input app_content_blocks_obj_rel_insert_input {
	data: app_content_blocks_insert_input!
	on_conflict: app_content_blocks_on_conflict
}

"on conflict condition type for table \"app.content_blocks\""
input app_content_blocks_on_conflict {
	constraint: app_content_blocks_constraint!
	update_columns: [app_content_blocks_update_column!]!
	where: app_content_blocks_bool_exp
}

"ordering options when selecting data from \"app.content_blocks\""
input app_content_blocks_order_by {
	contentBycontentId: app_content_order_by
	content_block_type: order_by
	content_id: order_by
	created_at: order_by
	enum_content_block_type: lookup_enum_content_block_types_order_by
	id: order_by
	position: order_by
	updated_at: order_by
	variables: order_by
}

"primary key columns input for table: \"app.content_blocks\""
input app_content_blocks_pk_columns_input {
	id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_content_blocks_prepend_input {
	variables: jsonb
}

"input type for updating data in table \"app.content_blocks\""
input app_content_blocks_set_input {
	content_block_type: lookup_enum_content_block_types_enum
	content_id: Int
	created_at: timestamptz
	id: Int
	position: Int
	updated_at: timestamptz
	variables: jsonb
}

"order by stddev() on columns of table \"app.content_blocks\""
input app_content_blocks_stddev_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"order by stddev_pop() on columns of table \"app.content_blocks\""
input app_content_blocks_stddev_pop_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"order by stddev_samp() on columns of table \"app.content_blocks\""
input app_content_blocks_stddev_samp_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"order by sum() on columns of table \"app.content_blocks\""
input app_content_blocks_sum_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"order by var_pop() on columns of table \"app.content_blocks\""
input app_content_blocks_var_pop_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"order by var_samp() on columns of table \"app.content_blocks\""
input app_content_blocks_var_samp_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"order by variance() on columns of table \"app.content_blocks\""
input app_content_blocks_variance_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"Boolean expression to filter rows from the table \"app.content\". All fields are combined with a logical 'AND'."
input app_content_bool_exp {
	_and: [app_content_bool_exp]
	_not: app_content_bool_exp
	_or: [app_content_bool_exp]
	contentBlockssBycontentId: app_content_blocks_bool_exp
	content_content_labels: app_content_content_labels_bool_exp
	content_nav_elements: app_content_nav_elements_bool_exp
	content_type: lookup_enum_content_types_enum_comparison_exp
	content_width: String_comparison_exp
	created_at: timestamptz_comparison_exp
	depublish_at: timestamptz_comparison_exp
	description: String_comparison_exp
	enum_content_type: lookup_enum_content_types_bool_exp
	header_path: String_comparison_exp
	id: Int_comparison_exp
	is_deleted: Boolean_comparison_exp
	is_protected: Boolean_comparison_exp
	is_public: Boolean_comparison_exp
	meta_description: String_comparison_exp
	owner: users_summary_view_bool_exp
	path: String_comparison_exp
	profile: users_profiles_bool_exp
	publish_at: timestamptz_comparison_exp
	published_at: timestamptz_comparison_exp
	seo_description: String_comparison_exp
	seo_image_path: String_comparison_exp
	seo_keywords: String_comparison_exp
	seo_title: String_comparison_exp
	thumbnail_path: String_comparison_exp
	title: String_comparison_exp
	title_lower: app_content_lower_title_bool_exp
	updated_at: timestamptz_comparison_exp
	updated_by: users_summary_view_bool_exp
	updated_by_profile_id: uuid_comparison_exp
	user_group_ids: jsonb_comparison_exp
	user_profile_id: uuid_comparison_exp
}

"order by aggregate values of table \"app.content_content_labels\""
input app_content_content_labels_aggregate_order_by {
	avg: app_content_content_labels_avg_order_by
	count: order_by
	max: app_content_content_labels_max_order_by
	min: app_content_content_labels_min_order_by
	stddev: app_content_content_labels_stddev_order_by
	stddev_pop: app_content_content_labels_stddev_pop_order_by
	stddev_samp: app_content_content_labels_stddev_samp_order_by
	sum: app_content_content_labels_sum_order_by
	var_pop: app_content_content_labels_var_pop_order_by
	var_samp: app_content_content_labels_var_samp_order_by
	variance: app_content_content_labels_variance_order_by
}

"input type for inserting array relation for remote table \"app.content_content_labels\""
input app_content_content_labels_arr_rel_insert_input {
	data: [app_content_content_labels_insert_input!]!
	on_conflict: app_content_content_labels_on_conflict
}

"order by avg() on columns of table \"app.content_content_labels\""
input app_content_content_labels_avg_order_by {
	content_id: order_by
	id: order_by
	label_id: order_by
}

"Boolean expression to filter rows from the table \"app.content_content_labels\". All fields are combined with a logical 'AND'."
input app_content_content_labels_bool_exp {
	_and: [app_content_content_labels_bool_exp]
	_not: app_content_content_labels_bool_exp
	_or: [app_content_content_labels_bool_exp]
	content: app_content_bool_exp
	content_id: Int_comparison_exp
	content_label: app_content_labels_bool_exp
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	label_id: Int_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.content_content_labels\""
input app_content_content_labels_inc_input {
	content_id: Int
	id: Int
	label_id: Int
}

"input type for inserting data into table \"app.content_content_labels\""
input app_content_content_labels_insert_input {
	content: app_content_obj_rel_insert_input
	content_id: Int
	content_label: app_content_labels_obj_rel_insert_input
	created_at: timestamptz
	id: Int
	label_id: Int
	updated_at: timestamptz
}

"order by max() on columns of table \"app.content_content_labels\""
input app_content_content_labels_max_order_by {
	content_id: order_by
	created_at: order_by
	id: order_by
	label_id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.content_content_labels\""
input app_content_content_labels_min_order_by {
	content_id: order_by
	created_at: order_by
	id: order_by
	label_id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.content_content_labels\""
input app_content_content_labels_obj_rel_insert_input {
	data: app_content_content_labels_insert_input!
	on_conflict: app_content_content_labels_on_conflict
}

"on conflict condition type for table \"app.content_content_labels\""
input app_content_content_labels_on_conflict {
	constraint: app_content_content_labels_constraint!
	update_columns: [app_content_content_labels_update_column!]!
	where: app_content_content_labels_bool_exp
}

"ordering options when selecting data from \"app.content_content_labels\""
input app_content_content_labels_order_by {
	content: app_content_order_by
	content_id: order_by
	content_label: app_content_labels_order_by
	created_at: order_by
	id: order_by
	label_id: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.content_content_labels\""
input app_content_content_labels_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.content_content_labels\""
input app_content_content_labels_set_input {
	content_id: Int
	created_at: timestamptz
	id: Int
	label_id: Int
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.content_content_labels\""
input app_content_content_labels_stddev_order_by {
	content_id: order_by
	id: order_by
	label_id: order_by
}

"order by stddev_pop() on columns of table \"app.content_content_labels\""
input app_content_content_labels_stddev_pop_order_by {
	content_id: order_by
	id: order_by
	label_id: order_by
}

"order by stddev_samp() on columns of table \"app.content_content_labels\""
input app_content_content_labels_stddev_samp_order_by {
	content_id: order_by
	id: order_by
	label_id: order_by
}

"order by sum() on columns of table \"app.content_content_labels\""
input app_content_content_labels_sum_order_by {
	content_id: order_by
	id: order_by
	label_id: order_by
}

"order by var_pop() on columns of table \"app.content_content_labels\""
input app_content_content_labels_var_pop_order_by {
	content_id: order_by
	id: order_by
	label_id: order_by
}

"order by var_samp() on columns of table \"app.content_content_labels\""
input app_content_content_labels_var_samp_order_by {
	content_id: order_by
	id: order_by
	label_id: order_by
}

"order by variance() on columns of table \"app.content_content_labels\""
input app_content_content_labels_variance_order_by {
	content_id: order_by
	id: order_by
	label_id: order_by
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_content_delete_at_path_input {
	user_group_ids: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_content_delete_elem_input {
	user_group_ids: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_content_delete_key_input {
	user_group_ids: String
}

"input type for incrementing integer column in table \"app.content\""
input app_content_inc_input {
	id: Int
}

"input type for inserting data into table \"app.content\""
input app_content_insert_input {
	contentBlockssBycontentId: app_content_blocks_arr_rel_insert_input
	content_content_labels: app_content_content_labels_arr_rel_insert_input
	content_nav_elements: app_content_nav_elements_arr_rel_insert_input
	content_type: lookup_enum_content_types_enum
	content_width: String
	created_at: timestamptz
	depublish_at: timestamptz
	description: String
	enum_content_type: lookup_enum_content_types_obj_rel_insert_input
	header_path: String
	id: Int
	is_deleted: Boolean
	is_protected: Boolean
	is_public: Boolean
	meta_description: String
	path: String
	profile: users_profiles_obj_rel_insert_input
	publish_at: timestamptz
	published_at: timestamptz
	seo_description: String
	seo_image_path: String
	seo_keywords: String
	seo_title: String
	thumbnail_path: String
	title: String
	title_lower: app_content_lower_title_obj_rel_insert_input
	updated_at: timestamptz
	updated_by_profile_id: uuid
	user_group_ids: jsonb
	user_profile_id: uuid
}

"order by aggregate values of table \"app.content_labels\""
input app_content_labels_aggregate_order_by {
	avg: app_content_labels_avg_order_by
	count: order_by
	max: app_content_labels_max_order_by
	min: app_content_labels_min_order_by
	stddev: app_content_labels_stddev_order_by
	stddev_pop: app_content_labels_stddev_pop_order_by
	stddev_samp: app_content_labels_stddev_samp_order_by
	sum: app_content_labels_sum_order_by
	var_pop: app_content_labels_var_pop_order_by
	var_samp: app_content_labels_var_samp_order_by
	variance: app_content_labels_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_content_labels_append_input {
	link_to: jsonb
}

"input type for inserting array relation for remote table \"app.content_labels\""
input app_content_labels_arr_rel_insert_input {
	data: [app_content_labels_insert_input!]!
	on_conflict: app_content_labels_on_conflict
}

"order by avg() on columns of table \"app.content_labels\""
input app_content_labels_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.content_labels\". All fields are combined with a logical 'AND'."
input app_content_labels_bool_exp {
	_and: [app_content_labels_bool_exp]
	_not: app_content_labels_bool_exp
	_or: [app_content_labels_bool_exp]
	content_content_labels: app_content_content_labels_bool_exp
	content_type: String_comparison_exp
	created_at: timestamptz_comparison_exp
	enum_content_type: lookup_enum_content_types_bool_exp
	id: Int_comparison_exp
	label: String_comparison_exp
	link_to: jsonb_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_content_labels_delete_at_path_input {
	link_to: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_content_labels_delete_elem_input {
	link_to: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_content_labels_delete_key_input {
	link_to: String
}

"input type for incrementing integer column in table \"app.content_labels\""
input app_content_labels_inc_input {
	id: Int
}

"input type for inserting data into table \"app.content_labels\""
input app_content_labels_insert_input {
	content_content_labels: app_content_content_labels_arr_rel_insert_input
	content_type: String
	created_at: timestamptz
	enum_content_type: lookup_enum_content_types_obj_rel_insert_input
	id: Int
	label: String
	link_to: jsonb
	updated_at: timestamptz
}

"order by max() on columns of table \"app.content_labels\""
input app_content_labels_max_order_by {
	content_type: order_by
	created_at: order_by
	id: order_by
	label: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.content_labels\""
input app_content_labels_min_order_by {
	content_type: order_by
	created_at: order_by
	id: order_by
	label: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.content_labels\""
input app_content_labels_obj_rel_insert_input {
	data: app_content_labels_insert_input!
	on_conflict: app_content_labels_on_conflict
}

"on conflict condition type for table \"app.content_labels\""
input app_content_labels_on_conflict {
	constraint: app_content_labels_constraint!
	update_columns: [app_content_labels_update_column!]!
	where: app_content_labels_bool_exp
}

"ordering options when selecting data from \"app.content_labels\""
input app_content_labels_order_by {
	content_content_labels_aggregate: app_content_content_labels_aggregate_order_by
	content_type: order_by
	created_at: order_by
	enum_content_type: lookup_enum_content_types_order_by
	id: order_by
	label: order_by
	link_to: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.content_labels\""
input app_content_labels_pk_columns_input {
	id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_content_labels_prepend_input {
	link_to: jsonb
}

"input type for updating data in table \"app.content_labels\""
input app_content_labels_set_input {
	content_type: String
	created_at: timestamptz
	id: Int
	label: String
	link_to: jsonb
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.content_labels\""
input app_content_labels_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.content_labels\""
input app_content_labels_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.content_labels\""
input app_content_labels_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.content_labels\""
input app_content_labels_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.content_labels\""
input app_content_labels_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.content_labels\""
input app_content_labels_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.content_labels\""
input app_content_labels_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.content_lower_title\""
input app_content_lower_title_aggregate_order_by {
	avg: app_content_lower_title_avg_order_by
	count: order_by
	max: app_content_lower_title_max_order_by
	min: app_content_lower_title_min_order_by
	stddev: app_content_lower_title_stddev_order_by
	stddev_pop: app_content_lower_title_stddev_pop_order_by
	stddev_samp: app_content_lower_title_stddev_samp_order_by
	sum: app_content_lower_title_sum_order_by
	var_pop: app_content_lower_title_var_pop_order_by
	var_samp: app_content_lower_title_var_samp_order_by
	variance: app_content_lower_title_variance_order_by
}

"input type for inserting array relation for remote table \"app.content_lower_title\""
input app_content_lower_title_arr_rel_insert_input {
	data: [app_content_lower_title_insert_input!]!
}

"order by avg() on columns of table \"app.content_lower_title\""
input app_content_lower_title_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.content_lower_title\". All fields are combined with a logical 'AND'."
input app_content_lower_title_bool_exp {
	_and: [app_content_lower_title_bool_exp]
	_not: app_content_lower_title_bool_exp
	_or: [app_content_lower_title_bool_exp]
	id: Int_comparison_exp
	title_lower: String_comparison_exp
}

"input type for incrementing integer column in table \"app.content_lower_title\""
input app_content_lower_title_inc_input {
	id: Int
}

"input type for inserting data into table \"app.content_lower_title\""
input app_content_lower_title_insert_input {
	id: Int
	title_lower: String
}

"order by max() on columns of table \"app.content_lower_title\""
input app_content_lower_title_max_order_by {
	id: order_by
	title_lower: order_by
}

"order by min() on columns of table \"app.content_lower_title\""
input app_content_lower_title_min_order_by {
	id: order_by
	title_lower: order_by
}

"input type for inserting object relation for remote table \"app.content_lower_title\""
input app_content_lower_title_obj_rel_insert_input {
	data: app_content_lower_title_insert_input!
}

"ordering options when selecting data from \"app.content_lower_title\""
input app_content_lower_title_order_by {
	id: order_by
	title_lower: order_by
}

"input type for updating data in table \"app.content_lower_title\""
input app_content_lower_title_set_input {
	id: Int
	title_lower: String
}

"order by stddev() on columns of table \"app.content_lower_title\""
input app_content_lower_title_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.content_lower_title\""
input app_content_lower_title_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.content_lower_title\""
input app_content_lower_title_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.content_lower_title\""
input app_content_lower_title_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.content_lower_title\""
input app_content_lower_title_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.content_lower_title\""
input app_content_lower_title_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.content_lower_title\""
input app_content_lower_title_variance_order_by {
	id: order_by
}

"order by max() on columns of table \"app.content\""
input app_content_max_order_by {
	content_width: order_by
	created_at: order_by
	depublish_at: order_by
	description: order_by
	header_path: order_by
	id: order_by
	meta_description: order_by
	path: order_by
	publish_at: order_by
	published_at: order_by
	seo_description: order_by
	seo_image_path: order_by
	seo_keywords: order_by
	seo_title: order_by
	thumbnail_path: order_by
	title: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
	user_profile_id: order_by
}

"order by min() on columns of table \"app.content\""
input app_content_min_order_by {
	content_width: order_by
	created_at: order_by
	depublish_at: order_by
	description: order_by
	header_path: order_by
	id: order_by
	meta_description: order_by
	path: order_by
	publish_at: order_by
	published_at: order_by
	seo_description: order_by
	seo_image_path: order_by
	seo_keywords: order_by
	seo_title: order_by
	thumbnail_path: order_by
	title: order_by
	updated_at: order_by
	updated_by_profile_id: order_by
	user_profile_id: order_by
}

"order by aggregate values of table \"app.content_nav_elements\""
input app_content_nav_elements_aggregate_order_by {
	avg: app_content_nav_elements_avg_order_by
	count: order_by
	max: app_content_nav_elements_max_order_by
	min: app_content_nav_elements_min_order_by
	stddev: app_content_nav_elements_stddev_order_by
	stddev_pop: app_content_nav_elements_stddev_pop_order_by
	stddev_samp: app_content_nav_elements_stddev_samp_order_by
	sum: app_content_nav_elements_sum_order_by
	var_pop: app_content_nav_elements_var_pop_order_by
	var_samp: app_content_nav_elements_var_samp_order_by
	variance: app_content_nav_elements_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_content_nav_elements_append_input {
	user_group_ids: jsonb
}

"input type for inserting array relation for remote table \"app.content_nav_elements\""
input app_content_nav_elements_arr_rel_insert_input {
	data: [app_content_nav_elements_insert_input!]!
	on_conflict: app_content_nav_elements_on_conflict
}

"order by avg() on columns of table \"app.content_nav_elements\""
input app_content_nav_elements_avg_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"Boolean expression to filter rows from the table \"app.content_nav_elements\". All fields are combined with a logical 'AND'."
input app_content_nav_elements_bool_exp {
	_and: [app_content_nav_elements_bool_exp]
	_not: app_content_nav_elements_bool_exp
	_or: [app_content_nav_elements_bool_exp]
	content: app_content_bool_exp
	content_id: Int_comparison_exp
	content_path: String_comparison_exp
	content_type: String_comparison_exp
	created_at: timestamptz_comparison_exp
	description: String_comparison_exp
	icon_name: String_comparison_exp
	id: Int_comparison_exp
	label: String_comparison_exp
	link_target: String_comparison_exp
	placement: String_comparison_exp
	position: Int_comparison_exp
	tooltip: String_comparison_exp
	updated_at: timestamptz_comparison_exp
	user_group_ids: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_content_nav_elements_delete_at_path_input {
	user_group_ids: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_content_nav_elements_delete_elem_input {
	user_group_ids: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_content_nav_elements_delete_key_input {
	user_group_ids: String
}

"input type for incrementing integer column in table \"app.content_nav_elements\""
input app_content_nav_elements_inc_input {
	content_id: Int
	id: Int
	position: Int
}

"input type for inserting data into table \"app.content_nav_elements\""
input app_content_nav_elements_insert_input {
	content: app_content_obj_rel_insert_input
	content_id: Int
	content_path: String
	content_type: String
	created_at: timestamptz
	description: String
	icon_name: String
	id: Int
	label: String
	link_target: String
	placement: String
	position: Int
	tooltip: String
	updated_at: timestamptz
	user_group_ids: jsonb
}

"order by max() on columns of table \"app.content_nav_elements\""
input app_content_nav_elements_max_order_by {
	content_id: order_by
	content_path: order_by
	content_type: order_by
	created_at: order_by
	description: order_by
	icon_name: order_by
	id: order_by
	label: order_by
	link_target: order_by
	placement: order_by
	position: order_by
	tooltip: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.content_nav_elements\""
input app_content_nav_elements_min_order_by {
	content_id: order_by
	content_path: order_by
	content_type: order_by
	created_at: order_by
	description: order_by
	icon_name: order_by
	id: order_by
	label: order_by
	link_target: order_by
	placement: order_by
	position: order_by
	tooltip: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.content_nav_elements\""
input app_content_nav_elements_obj_rel_insert_input {
	data: app_content_nav_elements_insert_input!
	on_conflict: app_content_nav_elements_on_conflict
}

"on conflict condition type for table \"app.content_nav_elements\""
input app_content_nav_elements_on_conflict {
	constraint: app_content_nav_elements_constraint!
	update_columns: [app_content_nav_elements_update_column!]!
	where: app_content_nav_elements_bool_exp
}

"ordering options when selecting data from \"app.content_nav_elements\""
input app_content_nav_elements_order_by {
	content: app_content_order_by
	content_id: order_by
	content_path: order_by
	content_type: order_by
	created_at: order_by
	description: order_by
	icon_name: order_by
	id: order_by
	label: order_by
	link_target: order_by
	placement: order_by
	position: order_by
	tooltip: order_by
	updated_at: order_by
	user_group_ids: order_by
}

"primary key columns input for table: \"app.content_nav_elements\""
input app_content_nav_elements_pk_columns_input {
	id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_content_nav_elements_prepend_input {
	user_group_ids: jsonb
}

"input type for updating data in table \"app.content_nav_elements\""
input app_content_nav_elements_set_input {
	content_id: Int
	content_path: String
	content_type: String
	created_at: timestamptz
	description: String
	icon_name: String
	id: Int
	label: String
	link_target: String
	placement: String
	position: Int
	tooltip: String
	updated_at: timestamptz
	user_group_ids: jsonb
}

"order by stddev() on columns of table \"app.content_nav_elements\""
input app_content_nav_elements_stddev_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"order by stddev_pop() on columns of table \"app.content_nav_elements\""
input app_content_nav_elements_stddev_pop_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"order by stddev_samp() on columns of table \"app.content_nav_elements\""
input app_content_nav_elements_stddev_samp_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"order by sum() on columns of table \"app.content_nav_elements\""
input app_content_nav_elements_sum_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"order by var_pop() on columns of table \"app.content_nav_elements\""
input app_content_nav_elements_var_pop_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"order by var_samp() on columns of table \"app.content_nav_elements\""
input app_content_nav_elements_var_samp_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"order by variance() on columns of table \"app.content_nav_elements\""
input app_content_nav_elements_variance_order_by {
	content_id: order_by
	id: order_by
	position: order_by
}

"input type for inserting object relation for remote table \"app.content\""
input app_content_obj_rel_insert_input {
	data: app_content_insert_input!
	on_conflict: app_content_on_conflict
}

"on conflict condition type for table \"app.content\""
input app_content_on_conflict {
	constraint: app_content_constraint!
	update_columns: [app_content_update_column!]!
	where: app_content_bool_exp
}

"ordering options when selecting data from \"app.content\""
input app_content_order_by {
	contentBlockssBycontentId_aggregate: app_content_blocks_aggregate_order_by
	content_content_labels_aggregate: app_content_content_labels_aggregate_order_by
	content_nav_elements_aggregate: app_content_nav_elements_aggregate_order_by
	content_type: order_by
	content_width: order_by
	created_at: order_by
	depublish_at: order_by
	description: order_by
	enum_content_type: lookup_enum_content_types_order_by
	header_path: order_by
	id: order_by
	is_deleted: order_by
	is_protected: order_by
	is_public: order_by
	meta_description: order_by
	owner: users_summary_view_order_by
	path: order_by
	profile: users_profiles_order_by
	publish_at: order_by
	published_at: order_by
	seo_description: order_by
	seo_image_path: order_by
	seo_keywords: order_by
	seo_title: order_by
	thumbnail_path: order_by
	title: order_by
	title_lower: app_content_lower_title_order_by
	updated_at: order_by
	updated_by: users_summary_view_order_by
	updated_by_profile_id: order_by
	user_group_ids: order_by
	user_profile_id: order_by
}

"primary key columns input for table: \"app.content\""
input app_content_pk_columns_input {
	id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_content_prepend_input {
	user_group_ids: jsonb
}

"input type for updating data in table \"app.content\""
input app_content_set_input {
	content_type: lookup_enum_content_types_enum
	content_width: String
	created_at: timestamptz
	depublish_at: timestamptz
	description: String
	header_path: String
	id: Int
	is_deleted: Boolean
	is_protected: Boolean
	is_public: Boolean
	meta_description: String
	path: String
	publish_at: timestamptz
	published_at: timestamptz
	seo_description: String
	seo_image_path: String
	seo_keywords: String
	seo_title: String
	thumbnail_path: String
	title: String
	updated_at: timestamptz
	updated_by_profile_id: uuid
	user_group_ids: jsonb
	user_profile_id: uuid
}

"order by stddev() on columns of table \"app.content\""
input app_content_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.content\""
input app_content_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.content\""
input app_content_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.content\""
input app_content_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.content\""
input app_content_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.content\""
input app_content_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.content\""
input app_content_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.interactive_tour\""
input app_interactive_tour_aggregate_order_by {
	avg: app_interactive_tour_avg_order_by
	count: order_by
	max: app_interactive_tour_max_order_by
	min: app_interactive_tour_min_order_by
	stddev: app_interactive_tour_stddev_order_by
	stddev_pop: app_interactive_tour_stddev_pop_order_by
	stddev_samp: app_interactive_tour_stddev_samp_order_by
	sum: app_interactive_tour_sum_order_by
	var_pop: app_interactive_tour_var_pop_order_by
	var_samp: app_interactive_tour_var_samp_order_by
	variance: app_interactive_tour_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_interactive_tour_append_input {
	steps: jsonb
}

"input type for inserting array relation for remote table \"app.interactive_tour\""
input app_interactive_tour_arr_rel_insert_input {
	data: [app_interactive_tour_insert_input!]!
	on_conflict: app_interactive_tour_on_conflict
}

"order by avg() on columns of table \"app.interactive_tour\""
input app_interactive_tour_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.interactive_tour\". All fields are combined with a logical 'AND'."
input app_interactive_tour_bool_exp {
	_and: [app_interactive_tour_bool_exp]
	_not: app_interactive_tour_bool_exp
	_or: [app_interactive_tour_bool_exp]
	created_at: timestamp_comparison_exp
	id: Int_comparison_exp
	name: String_comparison_exp
	page: String_comparison_exp
	steps: jsonb_comparison_exp
	updated_at: timestamp_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_interactive_tour_delete_at_path_input {
	steps: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_interactive_tour_delete_elem_input {
	steps: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_interactive_tour_delete_key_input {
	steps: String
}

"input type for incrementing integer column in table \"app.interactive_tour\""
input app_interactive_tour_inc_input {
	id: Int
}

"input type for inserting data into table \"app.interactive_tour\""
input app_interactive_tour_insert_input {
	created_at: timestamp
	id: Int
	name: String
	page: String
	steps: jsonb
	updated_at: timestamp
}

"order by max() on columns of table \"app.interactive_tour\""
input app_interactive_tour_max_order_by {
	created_at: order_by
	id: order_by
	name: order_by
	page: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.interactive_tour\""
input app_interactive_tour_min_order_by {
	created_at: order_by
	id: order_by
	name: order_by
	page: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.interactive_tour\""
input app_interactive_tour_obj_rel_insert_input {
	data: app_interactive_tour_insert_input!
	on_conflict: app_interactive_tour_on_conflict
}

"on conflict condition type for table \"app.interactive_tour\""
input app_interactive_tour_on_conflict {
	constraint: app_interactive_tour_constraint!
	update_columns: [app_interactive_tour_update_column!]!
	where: app_interactive_tour_bool_exp
}

"ordering options when selecting data from \"app.interactive_tour\""
input app_interactive_tour_order_by {
	created_at: order_by
	id: order_by
	name: order_by
	page: order_by
	steps: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.interactive_tour\""
input app_interactive_tour_pk_columns_input {
	id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_interactive_tour_prepend_input {
	steps: jsonb
}

"input type for updating data in table \"app.interactive_tour\""
input app_interactive_tour_set_input {
	created_at: timestamp
	id: Int
	name: String
	page: String
	steps: jsonb
	updated_at: timestamp
}

"order by stddev() on columns of table \"app.interactive_tour\""
input app_interactive_tour_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.interactive_tour\""
input app_interactive_tour_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.interactive_tour\""
input app_interactive_tour_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.interactive_tour\""
input app_interactive_tour_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.interactive_tour\""
input app_interactive_tour_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.interactive_tour\""
input app_interactive_tour_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.interactive_tour\""
input app_interactive_tour_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.item_bookmarks\""
input app_item_bookmarks_aggregate_order_by {
	avg: app_item_bookmarks_avg_order_by
	count: order_by
	max: app_item_bookmarks_max_order_by
	min: app_item_bookmarks_min_order_by
	stddev: app_item_bookmarks_stddev_order_by
	stddev_pop: app_item_bookmarks_stddev_pop_order_by
	stddev_samp: app_item_bookmarks_stddev_samp_order_by
	sum: app_item_bookmarks_sum_order_by
	var_pop: app_item_bookmarks_var_pop_order_by
	var_samp: app_item_bookmarks_var_samp_order_by
	variance: app_item_bookmarks_variance_order_by
}

"input type for inserting array relation for remote table \"app.item_bookmarks\""
input app_item_bookmarks_arr_rel_insert_input {
	data: [app_item_bookmarks_insert_input!]!
	on_conflict: app_item_bookmarks_on_conflict
}

"order by avg() on columns of table \"app.item_bookmarks\""
input app_item_bookmarks_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.item_bookmarks\". All fields are combined with a logical 'AND'."
input app_item_bookmarks_bool_exp {
	_and: [app_item_bookmarks_bool_exp]
	_not: app_item_bookmarks_bool_exp
	_or: [app_item_bookmarks_bool_exp]
	bookmarkedItem: app_item_meta_bool_exp
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	item_id: uuid_comparison_exp
	profile: users_profiles_bool_exp
	profile_id: uuid_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.item_bookmarks\""
input app_item_bookmarks_inc_input {
	id: Int
}

"input type for inserting data into table \"app.item_bookmarks\""
input app_item_bookmarks_insert_input {
	bookmarkedItem: app_item_meta_obj_rel_insert_input
	created_at: timestamptz
	id: Int
	item_id: uuid
	profile: users_profiles_obj_rel_insert_input
	profile_id: uuid
	updated_at: timestamptz
}

"order by max() on columns of table \"app.item_bookmarks\""
input app_item_bookmarks_max_order_by {
	created_at: order_by
	id: order_by
	item_id: order_by
	profile_id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.item_bookmarks\""
input app_item_bookmarks_min_order_by {
	created_at: order_by
	id: order_by
	item_id: order_by
	profile_id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.item_bookmarks\""
input app_item_bookmarks_obj_rel_insert_input {
	data: app_item_bookmarks_insert_input!
	on_conflict: app_item_bookmarks_on_conflict
}

"on conflict condition type for table \"app.item_bookmarks\""
input app_item_bookmarks_on_conflict {
	constraint: app_item_bookmarks_constraint!
	update_columns: [app_item_bookmarks_update_column!]!
	where: app_item_bookmarks_bool_exp
}

"ordering options when selecting data from \"app.item_bookmarks\""
input app_item_bookmarks_order_by {
	bookmarkedItem: app_item_meta_order_by
	created_at: order_by
	id: order_by
	item_id: order_by
	profile: users_profiles_order_by
	profile_id: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.item_bookmarks\""
input app_item_bookmarks_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.item_bookmarks\""
input app_item_bookmarks_set_input {
	created_at: timestamptz
	id: Int
	item_id: uuid
	profile_id: uuid
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.item_bookmarks\""
input app_item_bookmarks_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.item_bookmarks\""
input app_item_bookmarks_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.item_bookmarks\""
input app_item_bookmarks_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.item_bookmarks\""
input app_item_bookmarks_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.item_bookmarks\""
input app_item_bookmarks_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.item_bookmarks\""
input app_item_bookmarks_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.item_bookmarks\""
input app_item_bookmarks_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.item_collateral\""
input app_item_collateral_aggregate_order_by {
	count: order_by
	max: app_item_collateral_max_order_by
	min: app_item_collateral_min_order_by
}

"input type for inserting array relation for remote table \"app.item_collateral\""
input app_item_collateral_arr_rel_insert_input {
	data: [app_item_collateral_insert_input!]!
	on_conflict: app_item_collateral_on_conflict
}

"Boolean expression to filter rows from the table \"app.item_collateral\". All fields are combined with a logical 'AND'."
input app_item_collateral_bool_exp {
	_and: [app_item_collateral_bool_exp]
	_not: app_item_collateral_bool_exp
	_or: [app_item_collateral_bool_exp]
	created_at: timestamptz_comparison_exp
	description: String_comparison_exp
	external_id: String_comparison_exp
	format: String_comparison_exp
	item_external_id: String_comparison_exp
	path: String_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"app.item_collateral\""
input app_item_collateral_insert_input {
	created_at: timestamptz
	description: String
	external_id: String
	format: String
	item_external_id: String
	path: String
	updated_at: timestamptz
}

"order by max() on columns of table \"app.item_collateral\""
input app_item_collateral_max_order_by {
	created_at: order_by
	description: order_by
	external_id: order_by
	format: order_by
	item_external_id: order_by
	path: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.item_collateral\""
input app_item_collateral_min_order_by {
	created_at: order_by
	description: order_by
	external_id: order_by
	format: order_by
	item_external_id: order_by
	path: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.item_collateral\""
input app_item_collateral_obj_rel_insert_input {
	data: app_item_collateral_insert_input!
	on_conflict: app_item_collateral_on_conflict
}

"on conflict condition type for table \"app.item_collateral\""
input app_item_collateral_on_conflict {
	constraint: app_item_collateral_constraint!
	update_columns: [app_item_collateral_update_column!]!
	where: app_item_collateral_bool_exp
}

"ordering options when selecting data from \"app.item_collateral\""
input app_item_collateral_order_by {
	created_at: order_by
	description: order_by
	external_id: order_by
	format: order_by
	item_external_id: order_by
	path: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.item_collateral\""
input app_item_collateral_pk_columns_input {
	external_id: String!
}

"input type for updating data in table \"app.item_collateral\""
input app_item_collateral_set_input {
	created_at: timestamptz
	description: String
	external_id: String
	format: String
	item_external_id: String
	path: String
	updated_at: timestamptz
}

"order by aggregate values of table \"app.item_counts\""
input app_item_counts_aggregate_order_by {
	avg: app_item_counts_avg_order_by
	count: order_by
	max: app_item_counts_max_order_by
	min: app_item_counts_min_order_by
	stddev: app_item_counts_stddev_order_by
	stddev_pop: app_item_counts_stddev_pop_order_by
	stddev_samp: app_item_counts_stddev_samp_order_by
	sum: app_item_counts_sum_order_by
	var_pop: app_item_counts_var_pop_order_by
	var_samp: app_item_counts_var_samp_order_by
	variance: app_item_counts_variance_order_by
}

"order by avg() on columns of table \"app.item_counts\""
input app_item_counts_avg_order_by {
	bookmarks: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"Boolean expression to filter rows from the table \"app.item_counts\". All fields are combined with a logical 'AND'."
input app_item_counts_bool_exp {
	_and: [app_item_counts_bool_exp]
	_not: app_item_counts_bool_exp
	_or: [app_item_counts_bool_exp]
	bookmarks: bigint_comparison_exp
	in_assignment: bigint_comparison_exp
	in_collection: bigint_comparison_exp
	item_uuid: uuid_comparison_exp
	plays: Int_comparison_exp
	quick_lane_links: bigint_comparison_exp
	views: Int_comparison_exp
}

"order by max() on columns of table \"app.item_counts\""
input app_item_counts_max_order_by {
	bookmarks: order_by
	in_assignment: order_by
	in_collection: order_by
	item_uuid: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by min() on columns of table \"app.item_counts\""
input app_item_counts_min_order_by {
	bookmarks: order_by
	in_assignment: order_by
	in_collection: order_by
	item_uuid: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"ordering options when selecting data from \"app.item_counts\""
input app_item_counts_order_by {
	bookmarks: order_by
	in_assignment: order_by
	in_collection: order_by
	item_uuid: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by stddev() on columns of table \"app.item_counts\""
input app_item_counts_stddev_order_by {
	bookmarks: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by stddev_pop() on columns of table \"app.item_counts\""
input app_item_counts_stddev_pop_order_by {
	bookmarks: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by stddev_samp() on columns of table \"app.item_counts\""
input app_item_counts_stddev_samp_order_by {
	bookmarks: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by sum() on columns of table \"app.item_counts\""
input app_item_counts_sum_order_by {
	bookmarks: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by var_pop() on columns of table \"app.item_counts\""
input app_item_counts_var_pop_order_by {
	bookmarks: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by var_samp() on columns of table \"app.item_counts\""
input app_item_counts_var_samp_order_by {
	bookmarks: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by variance() on columns of table \"app.item_counts\""
input app_item_counts_variance_order_by {
	bookmarks: order_by
	in_assignment: order_by
	in_collection: order_by
	plays: order_by
	quick_lane_links: order_by
	views: order_by
}

"order by aggregate values of table \"app.item_meta\""
input app_item_meta_aggregate_order_by {
	avg: app_item_meta_avg_order_by
	count: order_by
	max: app_item_meta_max_order_by
	min: app_item_meta_min_order_by
	stddev: app_item_meta_stddev_order_by
	stddev_pop: app_item_meta_stddev_pop_order_by
	stddev_samp: app_item_meta_stddev_samp_order_by
	sum: app_item_meta_sum_order_by
	var_pop: app_item_meta_var_pop_order_by
	var_samp: app_item_meta_var_samp_order_by
	variance: app_item_meta_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_item_meta_append_input {
	lom_classification: jsonb
	lom_context: jsonb
	lom_intendedenduserrole: jsonb
	lom_keywords: jsonb
	lom_languages: jsonb
	lom_thema: jsonb
	lom_typicalagerange: jsonb
}

"input type for inserting array relation for remote table \"app.item_meta\""
input app_item_meta_arr_rel_insert_input {
	data: [app_item_meta_insert_input!]!
	on_conflict: app_item_meta_on_conflict
}

"order by avg() on columns of table \"app.item_meta\""
input app_item_meta_avg_order_by {
	id: order_by
	type_id: order_by
}

"Boolean expression to filter rows from the table \"app.item_meta\". All fields are combined with a logical 'AND'."
input app_item_meta_bool_exp {
	_and: [app_item_meta_bool_exp]
	_not: app_item_meta_bool_exp
	_or: [app_item_meta_bool_exp]
	archived_at: timestamptz_comparison_exp
	avo1_id: String_comparison_exp
	browse_path: String_comparison_exp
	created_at: timestamptz_comparison_exp
	depublish_at: timestamptz_comparison_exp
	depublish_reason: String_comparison_exp
	description: String_comparison_exp
	duration: time_comparison_exp
	expiry_date: timestamptz_comparison_exp
	external_id: bpchar_comparison_exp
	id: Int_comparison_exp
	is_deleted: Boolean_comparison_exp
	is_orphaned: Boolean_comparison_exp
	is_published: Boolean_comparison_exp
	issued: date_comparison_exp
	issued_edtf: String_comparison_exp
	item: shared_items_bool_exp
	item_collaterals: app_item_collateral_bool_exp
	item_counts: app_item_counts_bool_exp
	lom_classification: jsonb_comparison_exp
	lom_context: jsonb_comparison_exp
	lom_intendedenduserrole: jsonb_comparison_exp
	lom_keywords: jsonb_comparison_exp
	lom_languages: jsonb_comparison_exp
	lom_thema: jsonb_comparison_exp
	lom_typicalagerange: jsonb_comparison_exp
	note: String_comparison_exp
	org_id: bpchar_comparison_exp
	organisation: shared_organisations_bool_exp
	original_pid: String_comparison_exp
	play_counts: app_item_plays_bool_exp
	publish_at: timestamptz_comparison_exp
	published_at: timestamptz_comparison_exp
	reference_id: migrate_reference_ids_bool_exp
	relations: app_item_relations_view_bool_exp
	seo_image_path: String_comparison_exp
	series: String_comparison_exp
	thumbnail_path: String_comparison_exp
	title: String_comparison_exp
	type: shared_types_bool_exp
	type_id: Int_comparison_exp
	uid: uuid_comparison_exp
	updated_at: timestamptz_comparison_exp
	view_counts: app_item_views_bool_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_item_meta_delete_at_path_input {
	lom_classification: [String]
	lom_context: [String]
	lom_intendedenduserrole: [String]
	lom_keywords: [String]
	lom_languages: [String]
	lom_thema: [String]
	lom_typicalagerange: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_item_meta_delete_elem_input {
	lom_classification: Int
	lom_context: Int
	lom_intendedenduserrole: Int
	lom_keywords: Int
	lom_languages: Int
	lom_thema: Int
	lom_typicalagerange: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_item_meta_delete_key_input {
	lom_classification: String
	lom_context: String
	lom_intendedenduserrole: String
	lom_keywords: String
	lom_languages: String
	lom_thema: String
	lom_typicalagerange: String
}

"input type for incrementing integer column in table \"app.item_meta\""
input app_item_meta_inc_input {
	id: Int
	type_id: Int
}

"input type for inserting data into table \"app.item_meta\""
input app_item_meta_insert_input {
	archived_at: timestamptz
	avo1_id: String
	browse_path: String
	created_at: timestamptz
	depublish_at: timestamptz
	depublish_reason: String
	description: String
	duration: time
	expiry_date: timestamptz
	external_id: bpchar
	id: Int
	is_deleted: Boolean
	is_orphaned: Boolean
	is_published: Boolean
	issued: date
	issued_edtf: String
	item: shared_items_obj_rel_insert_input
	item_collaterals: app_item_collateral_arr_rel_insert_input
	lom_classification: jsonb
	lom_context: jsonb
	lom_intendedenduserrole: jsonb
	lom_keywords: jsonb
	lom_languages: jsonb
	lom_thema: jsonb
	lom_typicalagerange: jsonb
	note: String
	org_id: bpchar
	organisation: shared_organisations_obj_rel_insert_input
	original_pid: String
	play_counts: app_item_plays_arr_rel_insert_input
	publish_at: timestamptz
	published_at: timestamptz
	reference_id: migrate_reference_ids_obj_rel_insert_input
	seo_image_path: String
	series: String
	thumbnail_path: String
	title: String
	type: shared_types_obj_rel_insert_input
	type_id: Int
	uid: uuid
	updated_at: timestamptz
	view_counts: app_item_views_arr_rel_insert_input
}

"order by max() on columns of table \"app.item_meta\""
input app_item_meta_max_order_by {
	archived_at: order_by
	avo1_id: order_by
	browse_path: order_by
	created_at: order_by
	depublish_at: order_by
	depublish_reason: order_by
	description: order_by
	expiry_date: order_by
	id: order_by
	issued: order_by
	issued_edtf: order_by
	note: order_by
	original_pid: order_by
	publish_at: order_by
	published_at: order_by
	seo_image_path: order_by
	series: order_by
	thumbnail_path: order_by
	title: order_by
	type_id: order_by
	uid: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.item_meta\""
input app_item_meta_min_order_by {
	archived_at: order_by
	avo1_id: order_by
	browse_path: order_by
	created_at: order_by
	depublish_at: order_by
	depublish_reason: order_by
	description: order_by
	expiry_date: order_by
	id: order_by
	issued: order_by
	issued_edtf: order_by
	note: order_by
	original_pid: order_by
	publish_at: order_by
	published_at: order_by
	seo_image_path: order_by
	series: order_by
	thumbnail_path: order_by
	title: order_by
	type_id: order_by
	uid: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.item_meta\""
input app_item_meta_obj_rel_insert_input {
	data: app_item_meta_insert_input!
	on_conflict: app_item_meta_on_conflict
}

"on conflict condition type for table \"app.item_meta\""
input app_item_meta_on_conflict {
	constraint: app_item_meta_constraint!
	update_columns: [app_item_meta_update_column!]!
	where: app_item_meta_bool_exp
}

"ordering options when selecting data from \"app.item_meta\""
input app_item_meta_order_by {
	archived_at: order_by
	avo1_id: order_by
	browse_path: order_by
	created_at: order_by
	depublish_at: order_by
	depublish_reason: order_by
	description: order_by
	duration: order_by
	expiry_date: order_by
	external_id: order_by
	id: order_by
	is_deleted: order_by
	is_orphaned: order_by
	is_published: order_by
	issued: order_by
	issued_edtf: order_by
	item: shared_items_order_by
	item_collaterals_aggregate: app_item_collateral_aggregate_order_by
	item_counts: app_item_counts_order_by
	lom_classification: order_by
	lom_context: order_by
	lom_intendedenduserrole: order_by
	lom_keywords: order_by
	lom_languages: order_by
	lom_thema: order_by
	lom_typicalagerange: order_by
	note: order_by
	org_id: order_by
	organisation: shared_organisations_order_by
	original_pid: order_by
	play_counts_aggregate: app_item_plays_aggregate_order_by
	publish_at: order_by
	published_at: order_by
	reference_id: migrate_reference_ids_order_by
	relations_aggregate: app_item_relations_view_aggregate_order_by
	seo_image_path: order_by
	series: order_by
	thumbnail_path: order_by
	title: order_by
	type: shared_types_order_by
	type_id: order_by
	uid: order_by
	updated_at: order_by
	view_counts_aggregate: app_item_views_aggregate_order_by
}

"primary key columns input for table: \"app.item_meta\""
input app_item_meta_pk_columns_input {
	id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_item_meta_prepend_input {
	lom_classification: jsonb
	lom_context: jsonb
	lom_intendedenduserrole: jsonb
	lom_keywords: jsonb
	lom_languages: jsonb
	lom_thema: jsonb
	lom_typicalagerange: jsonb
}

"input type for updating data in table \"app.item_meta\""
input app_item_meta_set_input {
	archived_at: timestamptz
	avo1_id: String
	browse_path: String
	created_at: timestamptz
	depublish_at: timestamptz
	depublish_reason: String
	description: String
	duration: time
	expiry_date: timestamptz
	external_id: bpchar
	id: Int
	is_deleted: Boolean
	is_orphaned: Boolean
	is_published: Boolean
	issued: date
	issued_edtf: String
	lom_classification: jsonb
	lom_context: jsonb
	lom_intendedenduserrole: jsonb
	lom_keywords: jsonb
	lom_languages: jsonb
	lom_thema: jsonb
	lom_typicalagerange: jsonb
	note: String
	org_id: bpchar
	original_pid: String
	publish_at: timestamptz
	published_at: timestamptz
	seo_image_path: String
	series: String
	thumbnail_path: String
	title: String
	type_id: Int
	uid: uuid
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.item_meta\""
input app_item_meta_stddev_order_by {
	id: order_by
	type_id: order_by
}

"order by stddev_pop() on columns of table \"app.item_meta\""
input app_item_meta_stddev_pop_order_by {
	id: order_by
	type_id: order_by
}

"order by stddev_samp() on columns of table \"app.item_meta\""
input app_item_meta_stddev_samp_order_by {
	id: order_by
	type_id: order_by
}

"order by sum() on columns of table \"app.item_meta\""
input app_item_meta_sum_order_by {
	id: order_by
	type_id: order_by
}

"order by var_pop() on columns of table \"app.item_meta\""
input app_item_meta_var_pop_order_by {
	id: order_by
	type_id: order_by
}

"order by var_samp() on columns of table \"app.item_meta\""
input app_item_meta_var_samp_order_by {
	id: order_by
	type_id: order_by
}

"order by variance() on columns of table \"app.item_meta\""
input app_item_meta_variance_order_by {
	id: order_by
	type_id: order_by
}

"order by aggregate values of table \"app.item_plays\""
input app_item_plays_aggregate_order_by {
	avg: app_item_plays_avg_order_by
	count: order_by
	max: app_item_plays_max_order_by
	min: app_item_plays_min_order_by
	stddev: app_item_plays_stddev_order_by
	stddev_pop: app_item_plays_stddev_pop_order_by
	stddev_samp: app_item_plays_stddev_samp_order_by
	sum: app_item_plays_sum_order_by
	var_pop: app_item_plays_var_pop_order_by
	var_samp: app_item_plays_var_samp_order_by
	variance: app_item_plays_variance_order_by
}

"input type for inserting array relation for remote table \"app.item_plays\""
input app_item_plays_arr_rel_insert_input {
	data: [app_item_plays_insert_input!]!
	on_conflict: app_item_plays_on_conflict
}

"order by avg() on columns of table \"app.item_plays\""
input app_item_plays_avg_order_by {
	count: order_by
	id: order_by
}

"Boolean expression to filter rows from the table \"app.item_plays\". All fields are combined with a logical 'AND'."
input app_item_plays_bool_exp {
	_and: [app_item_plays_bool_exp]
	_not: app_item_plays_bool_exp
	_or: [app_item_plays_bool_exp]
	count: Int_comparison_exp
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	item_id: uuid_comparison_exp
	playedItem: app_item_meta_bool_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.item_plays\""
input app_item_plays_inc_input {
	count: Int
	id: Int
}

"input type for inserting data into table \"app.item_plays\""
input app_item_plays_insert_input {
	count: Int
	created_at: timestamptz
	id: Int
	item_id: uuid
	playedItem: app_item_meta_obj_rel_insert_input
	updated_at: timestamptz
}

"order by max() on columns of table \"app.item_plays\""
input app_item_plays_max_order_by {
	count: order_by
	created_at: order_by
	id: order_by
	item_id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.item_plays\""
input app_item_plays_min_order_by {
	count: order_by
	created_at: order_by
	id: order_by
	item_id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.item_plays\""
input app_item_plays_obj_rel_insert_input {
	data: app_item_plays_insert_input!
	on_conflict: app_item_plays_on_conflict
}

"on conflict condition type for table \"app.item_plays\""
input app_item_plays_on_conflict {
	constraint: app_item_plays_constraint!
	update_columns: [app_item_plays_update_column!]!
	where: app_item_plays_bool_exp
}

"ordering options when selecting data from \"app.item_plays\""
input app_item_plays_order_by {
	count: order_by
	created_at: order_by
	id: order_by
	item_id: order_by
	playedItem: app_item_meta_order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.item_plays\""
input app_item_plays_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.item_plays\""
input app_item_plays_set_input {
	count: Int
	created_at: timestamptz
	id: Int
	item_id: uuid
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.item_plays\""
input app_item_plays_stddev_order_by {
	count: order_by
	id: order_by
}

"order by stddev_pop() on columns of table \"app.item_plays\""
input app_item_plays_stddev_pop_order_by {
	count: order_by
	id: order_by
}

"order by stddev_samp() on columns of table \"app.item_plays\""
input app_item_plays_stddev_samp_order_by {
	count: order_by
	id: order_by
}

"order by sum() on columns of table \"app.item_plays\""
input app_item_plays_sum_order_by {
	count: order_by
	id: order_by
}

"order by var_pop() on columns of table \"app.item_plays\""
input app_item_plays_var_pop_order_by {
	count: order_by
	id: order_by
}

"order by var_samp() on columns of table \"app.item_plays\""
input app_item_plays_var_samp_order_by {
	count: order_by
	id: order_by
}

"order by variance() on columns of table \"app.item_plays\""
input app_item_plays_variance_order_by {
	count: order_by
	id: order_by
}

"order by aggregate values of table \"app.item_relations\""
input app_item_relations_aggregate_order_by {
	avg: app_item_relations_avg_order_by
	count: order_by
	max: app_item_relations_max_order_by
	min: app_item_relations_min_order_by
	stddev: app_item_relations_stddev_order_by
	stddev_pop: app_item_relations_stddev_pop_order_by
	stddev_samp: app_item_relations_stddev_samp_order_by
	sum: app_item_relations_sum_order_by
	var_pop: app_item_relations_var_pop_order_by
	var_samp: app_item_relations_var_samp_order_by
	variance: app_item_relations_variance_order_by
}

"input type for inserting array relation for remote table \"app.item_relations\""
input app_item_relations_arr_rel_insert_input {
	data: [app_item_relations_insert_input!]!
	on_conflict: app_item_relations_on_conflict
}

"order by avg() on columns of table \"app.item_relations\""
input app_item_relations_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"app.item_relations\". All fields are combined with a logical 'AND'."
input app_item_relations_bool_exp {
	_and: [app_item_relations_bool_exp]
	_not: app_item_relations_bool_exp
	_or: [app_item_relations_bool_exp]
	created_at: timestamptz_comparison_exp
	enum_relation_type: lookup_enum_relation_types_bool_exp
	id: Int_comparison_exp
	object: uuid_comparison_exp
	predicate: lookup_enum_relation_types_enum_comparison_exp
	subject: uuid_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.item_relations\""
input app_item_relations_inc_input {
	id: Int
}

"input type for inserting data into table \"app.item_relations\""
input app_item_relations_insert_input {
	created_at: timestamptz
	enum_relation_type: lookup_enum_relation_types_obj_rel_insert_input
	id: Int
	object: uuid
	predicate: lookup_enum_relation_types_enum
	subject: uuid
	updated_at: timestamptz
}

"order by max() on columns of table \"app.item_relations\""
input app_item_relations_max_order_by {
	created_at: order_by
	id: order_by
	object: order_by
	subject: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.item_relations\""
input app_item_relations_min_order_by {
	created_at: order_by
	id: order_by
	object: order_by
	subject: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.item_relations\""
input app_item_relations_obj_rel_insert_input {
	data: app_item_relations_insert_input!
	on_conflict: app_item_relations_on_conflict
}

"on conflict condition type for table \"app.item_relations\""
input app_item_relations_on_conflict {
	constraint: app_item_relations_constraint!
	update_columns: [app_item_relations_update_column!]!
	where: app_item_relations_bool_exp
}

"ordering options when selecting data from \"app.item_relations\""
input app_item_relations_order_by {
	created_at: order_by
	enum_relation_type: lookup_enum_relation_types_order_by
	id: order_by
	object: order_by
	predicate: order_by
	subject: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.item_relations\""
input app_item_relations_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.item_relations\""
input app_item_relations_set_input {
	created_at: timestamptz
	id: Int
	object: uuid
	predicate: lookup_enum_relation_types_enum
	subject: uuid
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.item_relations\""
input app_item_relations_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"app.item_relations\""
input app_item_relations_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"app.item_relations\""
input app_item_relations_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"app.item_relations\""
input app_item_relations_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"app.item_relations\""
input app_item_relations_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"app.item_relations\""
input app_item_relations_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"app.item_relations\""
input app_item_relations_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"app.item_relations_view\""
input app_item_relations_view_aggregate_order_by {
	count: order_by
	max: app_item_relations_view_max_order_by
	min: app_item_relations_view_min_order_by
}

"Boolean expression to filter rows from the table \"app.item_relations_view\". All fields are combined with a logical 'AND'."
input app_item_relations_view_bool_exp {
	_and: [app_item_relations_view_bool_exp]
	_not: app_item_relations_view_bool_exp
	_or: [app_item_relations_view_bool_exp]
	created_at: timestamptz_comparison_exp
	object: uuid_comparison_exp
	predicate: String_comparison_exp
	subject: uuid_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"order by max() on columns of table \"app.item_relations_view\""
input app_item_relations_view_max_order_by {
	created_at: order_by
	object: order_by
	predicate: order_by
	subject: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.item_relations_view\""
input app_item_relations_view_min_order_by {
	created_at: order_by
	object: order_by
	predicate: order_by
	subject: order_by
	updated_at: order_by
}

"ordering options when selecting data from \"app.item_relations_view\""
input app_item_relations_view_order_by {
	created_at: order_by
	object: order_by
	predicate: order_by
	subject: order_by
	updated_at: order_by
}

"order by aggregate values of table \"app.item_score\""
input app_item_score_aggregate_order_by {
	avg: app_item_score_avg_order_by
	count: order_by
	max: app_item_score_max_order_by
	min: app_item_score_min_order_by
	stddev: app_item_score_stddev_order_by
	stddev_pop: app_item_score_stddev_pop_order_by
	stddev_samp: app_item_score_stddev_samp_order_by
	sum: app_item_score_sum_order_by
	var_pop: app_item_score_var_pop_order_by
	var_samp: app_item_score_var_samp_order_by
	variance: app_item_score_variance_order_by
}

"input type for inserting array relation for remote table \"app.item_score\""
input app_item_score_arr_rel_insert_input {
	data: [app_item_score_insert_input!]!
	on_conflict: app_item_score_on_conflict
}

"order by avg() on columns of table \"app.item_score\""
input app_item_score_avg_order_by {
	id: order_by
	score: order_by
}

"Boolean expression to filter rows from the table \"app.item_score\". All fields are combined with a logical 'AND'."
input app_item_score_bool_exp {
	_and: [app_item_score_bool_exp]
	_not: app_item_score_bool_exp
	_or: [app_item_score_bool_exp]
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	item_id: uuid_comparison_exp
	item_metum: app_item_meta_bool_exp
	score: Int_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"app.item_score\""
input app_item_score_inc_input {
	id: Int
	score: Int
}

"input type for inserting data into table \"app.item_score\""
input app_item_score_insert_input {
	created_at: timestamptz
	id: Int
	item_id: uuid
	item_metum: app_item_meta_obj_rel_insert_input
	score: Int
	updated_at: timestamptz
}

"order by max() on columns of table \"app.item_score\""
input app_item_score_max_order_by {
	created_at: order_by
	id: order_by
	item_id: order_by
	score: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.item_score\""
input app_item_score_min_order_by {
	created_at: order_by
	id: order_by
	item_id: order_by
	score: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.item_score\""
input app_item_score_obj_rel_insert_input {
	data: app_item_score_insert_input!
	on_conflict: app_item_score_on_conflict
}

"on conflict condition type for table \"app.item_score\""
input app_item_score_on_conflict {
	constraint: app_item_score_constraint!
	update_columns: [app_item_score_update_column!]!
	where: app_item_score_bool_exp
}

"ordering options when selecting data from \"app.item_score\""
input app_item_score_order_by {
	created_at: order_by
	id: order_by
	item_id: order_by
	item_metum: app_item_meta_order_by
	score: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.item_score\""
input app_item_score_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.item_score\""
input app_item_score_set_input {
	created_at: timestamptz
	id: Int
	item_id: uuid
	score: Int
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.item_score\""
input app_item_score_stddev_order_by {
	id: order_by
	score: order_by
}

"order by stddev_pop() on columns of table \"app.item_score\""
input app_item_score_stddev_pop_order_by {
	id: order_by
	score: order_by
}

"order by stddev_samp() on columns of table \"app.item_score\""
input app_item_score_stddev_samp_order_by {
	id: order_by
	score: order_by
}

"order by sum() on columns of table \"app.item_score\""
input app_item_score_sum_order_by {
	id: order_by
	score: order_by
}

"order by var_pop() on columns of table \"app.item_score\""
input app_item_score_var_pop_order_by {
	id: order_by
	score: order_by
}

"order by var_samp() on columns of table \"app.item_score\""
input app_item_score_var_samp_order_by {
	id: order_by
	score: order_by
}

"order by variance() on columns of table \"app.item_score\""
input app_item_score_variance_order_by {
	id: order_by
	score: order_by
}

"order by aggregate values of table \"app.item_views\""
input app_item_views_aggregate_order_by {
	avg: app_item_views_avg_order_by
	count: order_by
	max: app_item_views_max_order_by
	min: app_item_views_min_order_by
	stddev: app_item_views_stddev_order_by
	stddev_pop: app_item_views_stddev_pop_order_by
	stddev_samp: app_item_views_stddev_samp_order_by
	sum: app_item_views_sum_order_by
	var_pop: app_item_views_var_pop_order_by
	var_samp: app_item_views_var_samp_order_by
	variance: app_item_views_variance_order_by
}

"input type for inserting array relation for remote table \"app.item_views\""
input app_item_views_arr_rel_insert_input {
	data: [app_item_views_insert_input!]!
	on_conflict: app_item_views_on_conflict
}

"order by avg() on columns of table \"app.item_views\""
input app_item_views_avg_order_by {
	count: order_by
	id: order_by
}

"Boolean expression to filter rows from the table \"app.item_views\". All fields are combined with a logical 'AND'."
input app_item_views_bool_exp {
	_and: [app_item_views_bool_exp]
	_not: app_item_views_bool_exp
	_or: [app_item_views_bool_exp]
	count: Int_comparison_exp
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	item_id: uuid_comparison_exp
	updated_at: timestamptz_comparison_exp
	viewedItem: app_item_meta_bool_exp
}

"input type for incrementing integer column in table \"app.item_views\""
input app_item_views_inc_input {
	count: Int
	id: Int
}

"input type for inserting data into table \"app.item_views\""
input app_item_views_insert_input {
	count: Int
	created_at: timestamptz
	id: Int
	item_id: uuid
	updated_at: timestamptz
	viewedItem: app_item_meta_obj_rel_insert_input
}

"order by max() on columns of table \"app.item_views\""
input app_item_views_max_order_by {
	count: order_by
	created_at: order_by
	id: order_by
	item_id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.item_views\""
input app_item_views_min_order_by {
	count: order_by
	created_at: order_by
	id: order_by
	item_id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.item_views\""
input app_item_views_obj_rel_insert_input {
	data: app_item_views_insert_input!
	on_conflict: app_item_views_on_conflict
}

"on conflict condition type for table \"app.item_views\""
input app_item_views_on_conflict {
	constraint: app_item_views_constraint!
	update_columns: [app_item_views_update_column!]!
	where: app_item_views_bool_exp
}

"ordering options when selecting data from \"app.item_views\""
input app_item_views_order_by {
	count: order_by
	created_at: order_by
	id: order_by
	item_id: order_by
	updated_at: order_by
	viewedItem: app_item_meta_order_by
}

"primary key columns input for table: \"app.item_views\""
input app_item_views_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"app.item_views\""
input app_item_views_set_input {
	count: Int
	created_at: timestamptz
	id: Int
	item_id: uuid
	updated_at: timestamptz
}

"order by stddev() on columns of table \"app.item_views\""
input app_item_views_stddev_order_by {
	count: order_by
	id: order_by
}

"order by stddev_pop() on columns of table \"app.item_views\""
input app_item_views_stddev_pop_order_by {
	count: order_by
	id: order_by
}

"order by stddev_samp() on columns of table \"app.item_views\""
input app_item_views_stddev_samp_order_by {
	count: order_by
	id: order_by
}

"order by sum() on columns of table \"app.item_views\""
input app_item_views_sum_order_by {
	count: order_by
	id: order_by
}

"order by var_pop() on columns of table \"app.item_views\""
input app_item_views_var_pop_order_by {
	count: order_by
	id: order_by
}

"order by var_samp() on columns of table \"app.item_views\""
input app_item_views_var_samp_order_by {
	count: order_by
	id: order_by
}

"order by variance() on columns of table \"app.item_views\""
input app_item_views_variance_order_by {
	count: order_by
	id: order_by
}

"order by aggregate values of table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_aggregate_order_by {
	avg: app_pupil_collection_blocks_avg_order_by
	count: order_by
	max: app_pupil_collection_blocks_max_order_by
	min: app_pupil_collection_blocks_min_order_by
	stddev: app_pupil_collection_blocks_stddev_order_by
	stddev_pop: app_pupil_collection_blocks_stddev_pop_order_by
	stddev_samp: app_pupil_collection_blocks_stddev_samp_order_by
	sum: app_pupil_collection_blocks_sum_order_by
	var_pop: app_pupil_collection_blocks_var_pop_order_by
	var_samp: app_pupil_collection_blocks_var_samp_order_by
	variance: app_pupil_collection_blocks_variance_order_by
}

"input type for inserting array relation for remote table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_arr_rel_insert_input {
	data: [app_pupil_collection_blocks_insert_input!]!
	on_conflict: app_pupil_collection_blocks_on_conflict
}

"order by avg() on columns of table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_avg_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"Boolean expression to filter rows from the table \"app.pupil_collection_blocks\". All fields are combined with a logical 'AND'."
input app_pupil_collection_blocks_bool_exp {
	_and: [app_pupil_collection_blocks_bool_exp]
	_not: app_pupil_collection_blocks_bool_exp
	_or: [app_pupil_collection_blocks_bool_exp]
	assignment_response_id: uuid_comparison_exp
	assignment_responses_v2: app_assignment_responses_v2_bool_exp
	created_at: timestamptz_comparison_exp
	custom_description: String_comparison_exp
	custom_title: String_comparison_exp
	end_oc: Int_comparison_exp
	fragment_id: String_comparison_exp
	id: uuid_comparison_exp
	is_deleted: Boolean_comparison_exp
	position: Int_comparison_exp
	start_oc: Int_comparison_exp
	thumbnail_path: String_comparison_exp
	type: String_comparison_exp
	updated_at: timestamptz_comparison_exp
	use_custom_fields: Boolean_comparison_exp
}

"input type for incrementing integer column in table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_inc_input {
	end_oc: Int
	position: Int
	start_oc: Int
}

"input type for inserting data into table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_insert_input {
	assignment_response_id: uuid
	assignment_responses_v2: app_assignment_responses_v2_obj_rel_insert_input
	created_at: timestamptz
	custom_description: String
	custom_title: String
	end_oc: Int
	fragment_id: String
	id: uuid
	is_deleted: Boolean
	position: Int
	start_oc: Int
	thumbnail_path: String
	type: String
	updated_at: timestamptz
	use_custom_fields: Boolean
}

"order by max() on columns of table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_max_order_by {
	assignment_response_id: order_by
	created_at: order_by
	custom_description: order_by
	custom_title: order_by
	end_oc: order_by
	fragment_id: order_by
	id: order_by
	position: order_by
	start_oc: order_by
	thumbnail_path: order_by
	type: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_min_order_by {
	assignment_response_id: order_by
	created_at: order_by
	custom_description: order_by
	custom_title: order_by
	end_oc: order_by
	fragment_id: order_by
	id: order_by
	position: order_by
	start_oc: order_by
	thumbnail_path: order_by
	type: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_obj_rel_insert_input {
	data: app_pupil_collection_blocks_insert_input!
	on_conflict: app_pupil_collection_blocks_on_conflict
}

"on conflict condition type for table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_on_conflict {
	constraint: app_pupil_collection_blocks_constraint!
	update_columns: [app_pupil_collection_blocks_update_column!]!
	where: app_pupil_collection_blocks_bool_exp
}

"ordering options when selecting data from \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_order_by {
	assignment_response_id: order_by
	assignment_responses_v2: app_assignment_responses_v2_order_by
	created_at: order_by
	custom_description: order_by
	custom_title: order_by
	end_oc: order_by
	fragment_id: order_by
	id: order_by
	is_deleted: order_by
	position: order_by
	start_oc: order_by
	thumbnail_path: order_by
	type: order_by
	updated_at: order_by
	use_custom_fields: order_by
}

"primary key columns input for table: \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_pk_columns_input {
	id: uuid!
}

"input type for updating data in table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_set_input {
	assignment_response_id: uuid
	created_at: timestamptz
	custom_description: String
	custom_title: String
	end_oc: Int
	fragment_id: String
	id: uuid
	is_deleted: Boolean
	position: Int
	start_oc: Int
	thumbnail_path: String
	type: String
	updated_at: timestamptz
	use_custom_fields: Boolean
}

"order by stddev() on columns of table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_stddev_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by stddev_pop() on columns of table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_stddev_pop_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by stddev_samp() on columns of table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_stddev_samp_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by sum() on columns of table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_sum_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by var_pop() on columns of table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_var_pop_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by var_samp() on columns of table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_var_samp_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by variance() on columns of table \"app.pupil_collection_blocks\""
input app_pupil_collection_blocks_variance_order_by {
	end_oc: order_by
	position: order_by
	start_oc: order_by
}

"order by aggregate values of table \"app.quick_lanes\""
input app_quick_lanes_aggregate_order_by {
	count: order_by
	max: app_quick_lanes_max_order_by
	min: app_quick_lanes_min_order_by
}

"input type for inserting array relation for remote table \"app.quick_lanes\""
input app_quick_lanes_arr_rel_insert_input {
	data: [app_quick_lanes_insert_input!]!
	on_conflict: app_quick_lanes_on_conflict
}

"Boolean expression to filter rows from the table \"app.quick_lanes\". All fields are combined with a logical 'AND'."
input app_quick_lanes_bool_exp {
	_and: [app_quick_lanes_bool_exp]
	_not: app_quick_lanes_bool_exp
	_or: [app_quick_lanes_bool_exp]
	content_id: uuid_comparison_exp
	content_label: String_comparison_exp
	created_at: timestamptz_comparison_exp
	id: uuid_comparison_exp
	owner: users_profiles_bool_exp
	owner_profile_id: uuid_comparison_exp
	title: String_comparison_exp
	updated_at: timestamptz_comparison_exp
	view_mode: String_comparison_exp
}

"input type for inserting data into table \"app.quick_lanes\""
input app_quick_lanes_insert_input {
	content_id: uuid
	content_label: String
	created_at: timestamptz
	id: uuid
	owner: users_profiles_obj_rel_insert_input
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
	view_mode: String
}

"order by max() on columns of table \"app.quick_lanes\""
input app_quick_lanes_max_order_by {
	content_id: order_by
	content_label: order_by
	created_at: order_by
	id: order_by
	owner_profile_id: order_by
	title: order_by
	updated_at: order_by
	view_mode: order_by
}

"order by min() on columns of table \"app.quick_lanes\""
input app_quick_lanes_min_order_by {
	content_id: order_by
	content_label: order_by
	created_at: order_by
	id: order_by
	owner_profile_id: order_by
	title: order_by
	updated_at: order_by
	view_mode: order_by
}

"input type for inserting object relation for remote table \"app.quick_lanes\""
input app_quick_lanes_obj_rel_insert_input {
	data: app_quick_lanes_insert_input!
	on_conflict: app_quick_lanes_on_conflict
}

"on conflict condition type for table \"app.quick_lanes\""
input app_quick_lanes_on_conflict {
	constraint: app_quick_lanes_constraint!
	update_columns: [app_quick_lanes_update_column!]!
	where: app_quick_lanes_bool_exp
}

"ordering options when selecting data from \"app.quick_lanes\""
input app_quick_lanes_order_by {
	content_id: order_by
	content_label: order_by
	created_at: order_by
	id: order_by
	owner: users_profiles_order_by
	owner_profile_id: order_by
	title: order_by
	updated_at: order_by
	view_mode: order_by
}

"order by aggregate values of table \"app.quick_lanes_overview\""
input app_quick_lanes_overview_aggregate_order_by {
	count: order_by
	max: app_quick_lanes_overview_max_order_by
	min: app_quick_lanes_overview_min_order_by
}

"Boolean expression to filter rows from the table \"app.quick_lanes_overview\". All fields are combined with a logical 'AND'."
input app_quick_lanes_overview_bool_exp {
	_and: [app_quick_lanes_overview_bool_exp]
	_not: app_quick_lanes_overview_bool_exp
	_or: [app_quick_lanes_overview_bool_exp]
	company_id: String_comparison_exp
	company_name: String_comparison_exp
	content_id: uuid_comparison_exp
	content_label: String_comparison_exp
	created_at: timestamptz_comparison_exp
	id: uuid_comparison_exp
	owner_first_name: String_comparison_exp
	owner_full_name: String_comparison_exp
	owner_last_name: String_comparison_exp
	owner_profile_id: uuid_comparison_exp
	title: String_comparison_exp
	updated_at: timestamptz_comparison_exp
	view_mode: String_comparison_exp
}

"order by max() on columns of table \"app.quick_lanes_overview\""
input app_quick_lanes_overview_max_order_by {
	company_id: order_by
	company_name: order_by
	content_id: order_by
	content_label: order_by
	created_at: order_by
	id: order_by
	owner_first_name: order_by
	owner_full_name: order_by
	owner_last_name: order_by
	owner_profile_id: order_by
	title: order_by
	updated_at: order_by
	view_mode: order_by
}

"order by min() on columns of table \"app.quick_lanes_overview\""
input app_quick_lanes_overview_min_order_by {
	company_id: order_by
	company_name: order_by
	content_id: order_by
	content_label: order_by
	created_at: order_by
	id: order_by
	owner_first_name: order_by
	owner_full_name: order_by
	owner_last_name: order_by
	owner_profile_id: order_by
	title: order_by
	updated_at: order_by
	view_mode: order_by
}

"ordering options when selecting data from \"app.quick_lanes_overview\""
input app_quick_lanes_overview_order_by {
	company_id: order_by
	company_name: order_by
	content_id: order_by
	content_label: order_by
	created_at: order_by
	id: order_by
	owner_first_name: order_by
	owner_full_name: order_by
	owner_last_name: order_by
	owner_profile_id: order_by
	title: order_by
	updated_at: order_by
	view_mode: order_by
}

"primary key columns input for table: \"app.quick_lanes\""
input app_quick_lanes_pk_columns_input {
	id: uuid!
}

"input type for updating data in table \"app.quick_lanes\""
input app_quick_lanes_set_input {
	content_id: uuid
	content_label: String
	created_at: timestamptz
	id: uuid
	owner_profile_id: uuid
	title: String
	updated_at: timestamptz
	view_mode: String
}

"order by aggregate values of table \"app.search_bookmarks\""
input app_search_bookmarks_aggregate_order_by {
	count: order_by
	max: app_search_bookmarks_max_order_by
	min: app_search_bookmarks_min_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_search_bookmarks_append_input {
	search_params: jsonb
}

"input type for inserting array relation for remote table \"app.search_bookmarks\""
input app_search_bookmarks_arr_rel_insert_input {
	data: [app_search_bookmarks_insert_input!]!
	on_conflict: app_search_bookmarks_on_conflict
}

"Boolean expression to filter rows from the table \"app.search_bookmarks\". All fields are combined with a logical 'AND'."
input app_search_bookmarks_bool_exp {
	_and: [app_search_bookmarks_bool_exp]
	_not: app_search_bookmarks_bool_exp
	_or: [app_search_bookmarks_bool_exp]
	created_at: timestamptz_comparison_exp
	id: uuid_comparison_exp
	label: String_comparison_exp
	profile_owner_id: uuid_comparison_exp
	search_params: jsonb_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_search_bookmarks_delete_at_path_input {
	search_params: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_search_bookmarks_delete_elem_input {
	search_params: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_search_bookmarks_delete_key_input {
	search_params: String
}

"input type for inserting data into table \"app.search_bookmarks\""
input app_search_bookmarks_insert_input {
	created_at: timestamptz
	id: uuid
	label: String
	profile_owner_id: uuid
	search_params: jsonb
	updated_at: timestamptz
}

"order by max() on columns of table \"app.search_bookmarks\""
input app_search_bookmarks_max_order_by {
	created_at: order_by
	id: order_by
	label: order_by
	profile_owner_id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.search_bookmarks\""
input app_search_bookmarks_min_order_by {
	created_at: order_by
	id: order_by
	label: order_by
	profile_owner_id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.search_bookmarks\""
input app_search_bookmarks_obj_rel_insert_input {
	data: app_search_bookmarks_insert_input!
	on_conflict: app_search_bookmarks_on_conflict
}

"on conflict condition type for table \"app.search_bookmarks\""
input app_search_bookmarks_on_conflict {
	constraint: app_search_bookmarks_constraint!
	update_columns: [app_search_bookmarks_update_column!]!
	where: app_search_bookmarks_bool_exp
}

"ordering options when selecting data from \"app.search_bookmarks\""
input app_search_bookmarks_order_by {
	created_at: order_by
	id: order_by
	label: order_by
	profile_owner_id: order_by
	search_params: order_by
	updated_at: order_by
}

"primary key columns input for table: \"app.search_bookmarks\""
input app_search_bookmarks_pk_columns_input {
	id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_search_bookmarks_prepend_input {
	search_params: jsonb
}

"input type for updating data in table \"app.search_bookmarks\""
input app_search_bookmarks_set_input {
	created_at: timestamptz
	id: uuid
	label: String
	profile_owner_id: uuid
	search_params: jsonb
	updated_at: timestamptz
}

"order by aggregate values of table \"app.site_variables\""
input app_site_variables_aggregate_order_by {
	count: order_by
	max: app_site_variables_max_order_by
	min: app_site_variables_min_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input app_site_variables_append_input {
	value: jsonb
}

"input type for inserting array relation for remote table \"app.site_variables\""
input app_site_variables_arr_rel_insert_input {
	data: [app_site_variables_insert_input!]!
	on_conflict: app_site_variables_on_conflict
}

"Boolean expression to filter rows from the table \"app.site_variables\". All fields are combined with a logical 'AND'."
input app_site_variables_bool_exp {
	_and: [app_site_variables_bool_exp]
	_not: app_site_variables_bool_exp
	_or: [app_site_variables_bool_exp]
	created_at: timestamptz_comparison_exp
	name: String_comparison_exp
	updated_at: timestamptz_comparison_exp
	value: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input app_site_variables_delete_at_path_input {
	value: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input app_site_variables_delete_elem_input {
	value: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input app_site_variables_delete_key_input {
	value: String
}

"input type for inserting data into table \"app.site_variables\""
input app_site_variables_insert_input {
	created_at: timestamptz
	name: String
	updated_at: timestamptz
	value: jsonb
}

"order by max() on columns of table \"app.site_variables\""
input app_site_variables_max_order_by {
	created_at: order_by
	name: order_by
	updated_at: order_by
}

"order by min() on columns of table \"app.site_variables\""
input app_site_variables_min_order_by {
	created_at: order_by
	name: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"app.site_variables\""
input app_site_variables_obj_rel_insert_input {
	data: app_site_variables_insert_input!
	on_conflict: app_site_variables_on_conflict
}

"on conflict condition type for table \"app.site_variables\""
input app_site_variables_on_conflict {
	constraint: app_site_variables_constraint!
	update_columns: [app_site_variables_update_column!]!
	where: app_site_variables_bool_exp
}

"ordering options when selecting data from \"app.site_variables\""
input app_site_variables_order_by {
	created_at: order_by
	name: order_by
	updated_at: order_by
	value: order_by
}

"primary key columns input for table: \"app.site_variables\""
input app_site_variables_pk_columns_input {
	name: String!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input app_site_variables_prepend_input {
	value: jsonb
}

"input type for updating data in table \"app.site_variables\""
input app_site_variables_set_input {
	created_at: timestamptz
	name: String
	updated_at: timestamptz
	value: jsonb
}

"order by aggregate values of table \"app.usage_counts\""
input app_usage_counts_aggregate_order_by {
	avg: app_usage_counts_avg_order_by
	count: order_by
	max: app_usage_counts_max_order_by
	min: app_usage_counts_min_order_by
	stddev: app_usage_counts_stddev_order_by
	stddev_pop: app_usage_counts_stddev_pop_order_by
	stddev_samp: app_usage_counts_stddev_samp_order_by
	sum: app_usage_counts_sum_order_by
	var_pop: app_usage_counts_var_pop_order_by
	var_samp: app_usage_counts_var_samp_order_by
	variance: app_usage_counts_variance_order_by
}

"order by avg() on columns of table \"app.usage_counts\""
input app_usage_counts_avg_order_by {
	count: order_by
}

"Boolean expression to filter rows from the table \"app.usage_counts\". All fields are combined with a logical 'AND'."
input app_usage_counts_bool_exp {
	_and: [app_usage_counts_bool_exp]
	_not: app_usage_counts_bool_exp
	_or: [app_usage_counts_bool_exp]
	count: bigint_comparison_exp
	id: uuid_comparison_exp
	type: String_comparison_exp
	usage: String_comparison_exp
}

"order by max() on columns of table \"app.usage_counts\""
input app_usage_counts_max_order_by {
	count: order_by
	id: order_by
	type: order_by
	usage: order_by
}

"order by min() on columns of table \"app.usage_counts\""
input app_usage_counts_min_order_by {
	count: order_by
	id: order_by
	type: order_by
	usage: order_by
}

"ordering options when selecting data from \"app.usage_counts\""
input app_usage_counts_order_by {
	count: order_by
	id: order_by
	type: order_by
	usage: order_by
}

"order by stddev() on columns of table \"app.usage_counts\""
input app_usage_counts_stddev_order_by {
	count: order_by
}

"order by stddev_pop() on columns of table \"app.usage_counts\""
input app_usage_counts_stddev_pop_order_by {
	count: order_by
}

"order by stddev_samp() on columns of table \"app.usage_counts\""
input app_usage_counts_stddev_samp_order_by {
	count: order_by
}

"order by sum() on columns of table \"app.usage_counts\""
input app_usage_counts_sum_order_by {
	count: order_by
}

"order by var_pop() on columns of table \"app.usage_counts\""
input app_usage_counts_var_pop_order_by {
	count: order_by
}

"order by var_samp() on columns of table \"app.usage_counts\""
input app_usage_counts_var_samp_order_by {
	count: order_by
}

"order by variance() on columns of table \"app.usage_counts\""
input app_usage_counts_variance_order_by {
	count: order_by
}

"expression to compare columns of type bigint. All fields are combined with logical 'AND'."
input bigint_comparison_exp {
	_eq: bigint
	_gt: bigint
	_gte: bigint
	_in: [bigint!]
	_is_null: Boolean
	_lt: bigint
	_lte: bigint
	_neq: bigint
	_nin: [bigint!]
}

"expression to compare columns of type bpchar. All fields are combined with logical 'AND'."
input bpchar_comparison_exp {
	_eq: bpchar
	_gt: bpchar
	_gte: bpchar
	_in: [bpchar!]
	_is_null: Boolean
	_lt: bpchar
	_lte: bpchar
	_neq: bpchar
	_nin: [bpchar!]
}

"expression to compare columns of type date. All fields are combined with logical 'AND'."
input date_comparison_exp {
	_eq: date
	_gt: date
	_gte: date
	_in: [date!]
	_is_null: Boolean
	_lt: date
	_lte: date
	_neq: date
	_nin: [date!]
}

"expression to compare columns of type item_publishing_status. All fields are combined with logical 'AND'."
input item_publishing_status_comparison_exp {
	_eq: item_publishing_status
	_gt: item_publishing_status
	_gte: item_publishing_status
	_in: [item_publishing_status!]
	_is_null: Boolean
	_lt: item_publishing_status
	_lte: item_publishing_status
	_neq: item_publishing_status
	_nin: [item_publishing_status!]
}

"expression to compare columns of type jsonb. All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
	"is the column contained in the given json value"
	_contained_in: jsonb
	"does the column contain the given json value at the top level"
	_contains: jsonb
	_eq: jsonb
	_gt: jsonb
	_gte: jsonb
	"does the string exist as a top-level key in the column"
	_has_key: String
	"do all of these strings exist as top-level keys in the column"
	_has_keys_all: [String!]
	"do any of these strings exist as top-level keys in the column"
	_has_keys_any: [String!]
	_in: [jsonb!]
	_is_null: Boolean
	_lt: jsonb
	_lte: jsonb
	_neq: jsonb
	_nin: [jsonb!]
}

"order by aggregate values of table \"lookup.enum_assignment_content_labels\""
input lookup_enum_assignment_content_labels_aggregate_order_by {
	count: order_by
	max: lookup_enum_assignment_content_labels_max_order_by
	min: lookup_enum_assignment_content_labels_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_assignment_content_labels\""
input lookup_enum_assignment_content_labels_arr_rel_insert_input {
	data: [lookup_enum_assignment_content_labels_insert_input!]!
	on_conflict: lookup_enum_assignment_content_labels_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_assignment_content_labels\". All fields are combined with a logical 'AND'."
input lookup_enum_assignment_content_labels_bool_exp {
	_and: [lookup_enum_assignment_content_labels_bool_exp]
	_not: lookup_enum_assignment_content_labels_bool_exp
	_or: [lookup_enum_assignment_content_labels_bool_exp]
	label: String_comparison_exp
	value: String_comparison_exp
}

"expression to compare columns of type lookup_enum_assignment_content_labels_enum. All fields are combined with logical 'AND'."
input lookup_enum_assignment_content_labels_enum_comparison_exp {
	_eq: lookup_enum_assignment_content_labels_enum
	_in: [lookup_enum_assignment_content_labels_enum!]
	_is_null: Boolean
	_neq: lookup_enum_assignment_content_labels_enum
	_nin: [lookup_enum_assignment_content_labels_enum!]
}

"input type for inserting data into table \"lookup.enum_assignment_content_labels\""
input lookup_enum_assignment_content_labels_insert_input {
	label: String
	value: String
}

"order by max() on columns of table \"lookup.enum_assignment_content_labels\""
input lookup_enum_assignment_content_labels_max_order_by {
	label: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_assignment_content_labels\""
input lookup_enum_assignment_content_labels_min_order_by {
	label: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_assignment_content_labels\""
input lookup_enum_assignment_content_labels_obj_rel_insert_input {
	data: lookup_enum_assignment_content_labels_insert_input!
	on_conflict: lookup_enum_assignment_content_labels_on_conflict
}

"on conflict condition type for table \"lookup.enum_assignment_content_labels\""
input lookup_enum_assignment_content_labels_on_conflict {
	constraint: lookup_enum_assignment_content_labels_constraint!
	update_columns: [lookup_enum_assignment_content_labels_update_column!]!
	where: lookup_enum_assignment_content_labels_bool_exp
}

"ordering options when selecting data from \"lookup.enum_assignment_content_labels\""
input lookup_enum_assignment_content_labels_order_by {
	label: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_assignment_content_labels\""
input lookup_enum_assignment_content_labels_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_assignment_content_labels\""
input lookup_enum_assignment_content_labels_set_input {
	label: String
	value: String
}

"order by aggregate values of table \"lookup.enum_assignment_types\""
input lookup_enum_assignment_types_aggregate_order_by {
	count: order_by
	max: lookup_enum_assignment_types_max_order_by
	min: lookup_enum_assignment_types_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_assignment_types\""
input lookup_enum_assignment_types_arr_rel_insert_input {
	data: [lookup_enum_assignment_types_insert_input!]!
	on_conflict: lookup_enum_assignment_types_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_assignment_types\". All fields are combined with a logical 'AND'."
input lookup_enum_assignment_types_bool_exp {
	_and: [lookup_enum_assignment_types_bool_exp]
	_not: lookup_enum_assignment_types_bool_exp
	_or: [lookup_enum_assignment_types_bool_exp]
	label: String_comparison_exp
	value: String_comparison_exp
}

"input type for inserting data into table \"lookup.enum_assignment_types\""
input lookup_enum_assignment_types_insert_input {
	label: String
	value: String
}

"order by max() on columns of table \"lookup.enum_assignment_types\""
input lookup_enum_assignment_types_max_order_by {
	label: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_assignment_types\""
input lookup_enum_assignment_types_min_order_by {
	label: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_assignment_types\""
input lookup_enum_assignment_types_obj_rel_insert_input {
	data: lookup_enum_assignment_types_insert_input!
	on_conflict: lookup_enum_assignment_types_on_conflict
}

"on conflict condition type for table \"lookup.enum_assignment_types\""
input lookup_enum_assignment_types_on_conflict {
	constraint: lookup_enum_assignment_types_constraint!
	update_columns: [lookup_enum_assignment_types_update_column!]!
	where: lookup_enum_assignment_types_bool_exp
}

"ordering options when selecting data from \"lookup.enum_assignment_types\""
input lookup_enum_assignment_types_order_by {
	label: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_assignment_types\""
input lookup_enum_assignment_types_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_assignment_types\""
input lookup_enum_assignment_types_set_input {
	label: String
	value: String
}

"order by aggregate values of table \"lookup.enum_collection_labels\""
input lookup_enum_collection_labels_aggregate_order_by {
	count: order_by
	max: lookup_enum_collection_labels_max_order_by
	min: lookup_enum_collection_labels_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_collection_labels\""
input lookup_enum_collection_labels_arr_rel_insert_input {
	data: [lookup_enum_collection_labels_insert_input!]!
	on_conflict: lookup_enum_collection_labels_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_collection_labels\". All fields are combined with a logical 'AND'."
input lookup_enum_collection_labels_bool_exp {
	_and: [lookup_enum_collection_labels_bool_exp]
	_not: lookup_enum_collection_labels_bool_exp
	_or: [lookup_enum_collection_labels_bool_exp]
	description: String_comparison_exp
	value: String_comparison_exp
}

"input type for inserting data into table \"lookup.enum_collection_labels\""
input lookup_enum_collection_labels_insert_input {
	description: String
	value: String
}

"order by max() on columns of table \"lookup.enum_collection_labels\""
input lookup_enum_collection_labels_max_order_by {
	description: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_collection_labels\""
input lookup_enum_collection_labels_min_order_by {
	description: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_collection_labels\""
input lookup_enum_collection_labels_obj_rel_insert_input {
	data: lookup_enum_collection_labels_insert_input!
	on_conflict: lookup_enum_collection_labels_on_conflict
}

"on conflict condition type for table \"lookup.enum_collection_labels\""
input lookup_enum_collection_labels_on_conflict {
	constraint: lookup_enum_collection_labels_constraint!
	update_columns: [lookup_enum_collection_labels_update_column!]!
	where: lookup_enum_collection_labels_bool_exp
}

"ordering options when selecting data from \"lookup.enum_collection_labels\""
input lookup_enum_collection_labels_order_by {
	description: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_collection_labels\""
input lookup_enum_collection_labels_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_collection_labels\""
input lookup_enum_collection_labels_set_input {
	description: String
	value: String
}

"order by aggregate values of table \"lookup.enum_collection_management_qc_label\""
input lookup_enum_collection_management_qc_label_aggregate_order_by {
	count: order_by
	max: lookup_enum_collection_management_qc_label_max_order_by
	min: lookup_enum_collection_management_qc_label_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_collection_management_qc_label\""
input lookup_enum_collection_management_qc_label_arr_rel_insert_input {
	data: [lookup_enum_collection_management_qc_label_insert_input!]!
	on_conflict: lookup_enum_collection_management_qc_label_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_collection_management_qc_label\". All fields are combined with a logical 'AND'."
input lookup_enum_collection_management_qc_label_bool_exp {
	_and: [lookup_enum_collection_management_qc_label_bool_exp]
	_not: lookup_enum_collection_management_qc_label_bool_exp
	_or: [lookup_enum_collection_management_qc_label_bool_exp]
	description: String_comparison_exp
	value: String_comparison_exp
}

"expression to compare columns of type lookup_enum_collection_management_qc_label_enum. All fields are combined with logical 'AND'."
input lookup_enum_collection_management_qc_label_enum_comparison_exp {
	_eq: lookup_enum_collection_management_qc_label_enum
	_in: [lookup_enum_collection_management_qc_label_enum!]
	_is_null: Boolean
	_neq: lookup_enum_collection_management_qc_label_enum
	_nin: [lookup_enum_collection_management_qc_label_enum!]
}

"input type for inserting data into table \"lookup.enum_collection_management_qc_label\""
input lookup_enum_collection_management_qc_label_insert_input {
	description: String
	value: String
}

"order by max() on columns of table \"lookup.enum_collection_management_qc_label\""
input lookup_enum_collection_management_qc_label_max_order_by {
	description: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_collection_management_qc_label\""
input lookup_enum_collection_management_qc_label_min_order_by {
	description: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_collection_management_qc_label\""
input lookup_enum_collection_management_qc_label_obj_rel_insert_input {
	data: lookup_enum_collection_management_qc_label_insert_input!
	on_conflict: lookup_enum_collection_management_qc_label_on_conflict
}

"on conflict condition type for table \"lookup.enum_collection_management_qc_label\""
input lookup_enum_collection_management_qc_label_on_conflict {
	constraint: lookup_enum_collection_management_qc_label_constraint!
	update_columns: [lookup_enum_collection_management_qc_label_update_column!]!
	where: lookup_enum_collection_management_qc_label_bool_exp
}

"ordering options when selecting data from \"lookup.enum_collection_management_qc_label\""
input lookup_enum_collection_management_qc_label_order_by {
	description: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_collection_management_qc_label\""
input lookup_enum_collection_management_qc_label_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_collection_management_qc_label\""
input lookup_enum_collection_management_qc_label_set_input {
	description: String
	value: String
}

"order by aggregate values of table \"lookup.enum_collection_management_status\""
input lookup_enum_collection_management_status_aggregate_order_by {
	count: order_by
	max: lookup_enum_collection_management_status_max_order_by
	min: lookup_enum_collection_management_status_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_collection_management_status\""
input lookup_enum_collection_management_status_arr_rel_insert_input {
	data: [lookup_enum_collection_management_status_insert_input!]!
	on_conflict: lookup_enum_collection_management_status_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_collection_management_status\". All fields are combined with a logical 'AND'."
input lookup_enum_collection_management_status_bool_exp {
	_and: [lookup_enum_collection_management_status_bool_exp]
	_not: lookup_enum_collection_management_status_bool_exp
	_or: [lookup_enum_collection_management_status_bool_exp]
	description: String_comparison_exp
	value: String_comparison_exp
}

"input type for inserting data into table \"lookup.enum_collection_management_status\""
input lookup_enum_collection_management_status_insert_input {
	description: String
	value: String
}

"order by max() on columns of table \"lookup.enum_collection_management_status\""
input lookup_enum_collection_management_status_max_order_by {
	description: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_collection_management_status\""
input lookup_enum_collection_management_status_min_order_by {
	description: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_collection_management_status\""
input lookup_enum_collection_management_status_obj_rel_insert_input {
	data: lookup_enum_collection_management_status_insert_input!
	on_conflict: lookup_enum_collection_management_status_on_conflict
}

"on conflict condition type for table \"lookup.enum_collection_management_status\""
input lookup_enum_collection_management_status_on_conflict {
	constraint: lookup_enum_collection_management_status_constraint!
	update_columns: [lookup_enum_collection_management_status_update_column!]!
	where: lookup_enum_collection_management_status_bool_exp
}

"ordering options when selecting data from \"lookup.enum_collection_management_status\""
input lookup_enum_collection_management_status_order_by {
	description: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_collection_management_status\""
input lookup_enum_collection_management_status_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_collection_management_status\""
input lookup_enum_collection_management_status_set_input {
	description: String
	value: String
}

"order by aggregate values of table \"lookup.enum_colors\""
input lookup_enum_colors_aggregate_order_by {
	count: order_by
	max: lookup_enum_colors_max_order_by
	min: lookup_enum_colors_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_colors\""
input lookup_enum_colors_arr_rel_insert_input {
	data: [lookup_enum_colors_insert_input!]!
	on_conflict: lookup_enum_colors_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_colors\". All fields are combined with a logical 'AND'."
input lookup_enum_colors_bool_exp {
	_and: [lookup_enum_colors_bool_exp]
	_not: lookup_enum_colors_bool_exp
	_or: [lookup_enum_colors_bool_exp]
	label: String_comparison_exp
	value: String_comparison_exp
}

"expression to compare columns of type lookup_enum_colors_enum. All fields are combined with logical 'AND'."
input lookup_enum_colors_enum_comparison_exp {
	_eq: lookup_enum_colors_enum
	_in: [lookup_enum_colors_enum!]
	_is_null: Boolean
	_neq: lookup_enum_colors_enum
	_nin: [lookup_enum_colors_enum!]
}

"input type for inserting data into table \"lookup.enum_colors\""
input lookup_enum_colors_insert_input {
	label: String
	value: String
}

"order by max() on columns of table \"lookup.enum_colors\""
input lookup_enum_colors_max_order_by {
	label: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_colors\""
input lookup_enum_colors_min_order_by {
	label: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_colors\""
input lookup_enum_colors_obj_rel_insert_input {
	data: lookup_enum_colors_insert_input!
	on_conflict: lookup_enum_colors_on_conflict
}

"on conflict condition type for table \"lookup.enum_colors\""
input lookup_enum_colors_on_conflict {
	constraint: lookup_enum_colors_constraint!
	update_columns: [lookup_enum_colors_update_column!]!
	where: lookup_enum_colors_bool_exp
}

"ordering options when selecting data from \"lookup.enum_colors\""
input lookup_enum_colors_order_by {
	label: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_colors\""
input lookup_enum_colors_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_colors\""
input lookup_enum_colors_set_input {
	label: String
	value: String
}

"order by aggregate values of table \"lookup.enum_content_block_types\""
input lookup_enum_content_block_types_aggregate_order_by {
	count: order_by
	max: lookup_enum_content_block_types_max_order_by
	min: lookup_enum_content_block_types_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_content_block_types\""
input lookup_enum_content_block_types_arr_rel_insert_input {
	data: [lookup_enum_content_block_types_insert_input!]!
	on_conflict: lookup_enum_content_block_types_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_content_block_types\". All fields are combined with a logical 'AND'."
input lookup_enum_content_block_types_bool_exp {
	_and: [lookup_enum_content_block_types_bool_exp]
	_not: lookup_enum_content_block_types_bool_exp
	_or: [lookup_enum_content_block_types_bool_exp]
	description: String_comparison_exp
	value: String_comparison_exp
}

"expression to compare columns of type lookup_enum_content_block_types_enum. All fields are combined with logical 'AND'."
input lookup_enum_content_block_types_enum_comparison_exp {
	_eq: lookup_enum_content_block_types_enum
	_in: [lookup_enum_content_block_types_enum!]
	_is_null: Boolean
	_neq: lookup_enum_content_block_types_enum
	_nin: [lookup_enum_content_block_types_enum!]
}

"input type for inserting data into table \"lookup.enum_content_block_types\""
input lookup_enum_content_block_types_insert_input {
	description: String
	value: String
}

"order by max() on columns of table \"lookup.enum_content_block_types\""
input lookup_enum_content_block_types_max_order_by {
	description: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_content_block_types\""
input lookup_enum_content_block_types_min_order_by {
	description: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_content_block_types\""
input lookup_enum_content_block_types_obj_rel_insert_input {
	data: lookup_enum_content_block_types_insert_input!
	on_conflict: lookup_enum_content_block_types_on_conflict
}

"on conflict condition type for table \"lookup.enum_content_block_types\""
input lookup_enum_content_block_types_on_conflict {
	constraint: lookup_enum_content_block_types_constraint!
	update_columns: [lookup_enum_content_block_types_update_column!]!
	where: lookup_enum_content_block_types_bool_exp
}

"ordering options when selecting data from \"lookup.enum_content_block_types\""
input lookup_enum_content_block_types_order_by {
	description: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_content_block_types\""
input lookup_enum_content_block_types_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_content_block_types\""
input lookup_enum_content_block_types_set_input {
	description: String
	value: String
}

"order by aggregate values of table \"lookup.enum_content_types\""
input lookup_enum_content_types_aggregate_order_by {
	count: order_by
	max: lookup_enum_content_types_max_order_by
	min: lookup_enum_content_types_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_content_types\""
input lookup_enum_content_types_arr_rel_insert_input {
	data: [lookup_enum_content_types_insert_input!]!
	on_conflict: lookup_enum_content_types_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_content_types\". All fields are combined with a logical 'AND'."
input lookup_enum_content_types_bool_exp {
	_and: [lookup_enum_content_types_bool_exp]
	_not: lookup_enum_content_types_bool_exp
	_or: [lookup_enum_content_types_bool_exp]
	description: String_comparison_exp
	value: String_comparison_exp
}

"expression to compare columns of type lookup_enum_content_types_enum. All fields are combined with logical 'AND'."
input lookup_enum_content_types_enum_comparison_exp {
	_eq: lookup_enum_content_types_enum
	_in: [lookup_enum_content_types_enum!]
	_is_null: Boolean
	_neq: lookup_enum_content_types_enum
	_nin: [lookup_enum_content_types_enum!]
}

"input type for inserting data into table \"lookup.enum_content_types\""
input lookup_enum_content_types_insert_input {
	description: String
	value: String
}

"order by max() on columns of table \"lookup.enum_content_types\""
input lookup_enum_content_types_max_order_by {
	description: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_content_types\""
input lookup_enum_content_types_min_order_by {
	description: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_content_types\""
input lookup_enum_content_types_obj_rel_insert_input {
	data: lookup_enum_content_types_insert_input!
	on_conflict: lookup_enum_content_types_on_conflict
}

"on conflict condition type for table \"lookup.enum_content_types\""
input lookup_enum_content_types_on_conflict {
	constraint: lookup_enum_content_types_constraint!
	update_columns: [lookup_enum_content_types_update_column!]!
	where: lookup_enum_content_types_bool_exp
}

"ordering options when selecting data from \"lookup.enum_content_types\""
input lookup_enum_content_types_order_by {
	description: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_content_types\""
input lookup_enum_content_types_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_content_types\""
input lookup_enum_content_types_set_input {
	description: String
	value: String
}

"order by aggregate values of table \"lookup.enum_input_types\""
input lookup_enum_input_types_aggregate_order_by {
	count: order_by
	max: lookup_enum_input_types_max_order_by
	min: lookup_enum_input_types_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_input_types\""
input lookup_enum_input_types_arr_rel_insert_input {
	data: [lookup_enum_input_types_insert_input!]!
	on_conflict: lookup_enum_input_types_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_input_types\". All fields are combined with a logical 'AND'."
input lookup_enum_input_types_bool_exp {
	_and: [lookup_enum_input_types_bool_exp]
	_not: lookup_enum_input_types_bool_exp
	_or: [lookup_enum_input_types_bool_exp]
	description: String_comparison_exp
	value: String_comparison_exp
}

"input type for inserting data into table \"lookup.enum_input_types\""
input lookup_enum_input_types_insert_input {
	description: String
	value: String
}

"order by max() on columns of table \"lookup.enum_input_types\""
input lookup_enum_input_types_max_order_by {
	description: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_input_types\""
input lookup_enum_input_types_min_order_by {
	description: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_input_types\""
input lookup_enum_input_types_obj_rel_insert_input {
	data: lookup_enum_input_types_insert_input!
	on_conflict: lookup_enum_input_types_on_conflict
}

"on conflict condition type for table \"lookup.enum_input_types\""
input lookup_enum_input_types_on_conflict {
	constraint: lookup_enum_input_types_constraint!
	update_columns: [lookup_enum_input_types_update_column!]!
	where: lookup_enum_input_types_bool_exp
}

"ordering options when selecting data from \"lookup.enum_input_types\""
input lookup_enum_input_types_order_by {
	description: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_input_types\""
input lookup_enum_input_types_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_input_types\""
input lookup_enum_input_types_set_input {
	description: String
	value: String
}

"order by aggregate values of table \"lookup.enum_lom_classification\""
input lookup_enum_lom_classification_aggregate_order_by {
	count: order_by
	max: lookup_enum_lom_classification_max_order_by
	min: lookup_enum_lom_classification_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_lom_classification\""
input lookup_enum_lom_classification_arr_rel_insert_input {
	data: [lookup_enum_lom_classification_insert_input!]!
	on_conflict: lookup_enum_lom_classification_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_lom_classification\". All fields are combined with a logical 'AND'."
input lookup_enum_lom_classification_bool_exp {
	_and: [lookup_enum_lom_classification_bool_exp]
	_not: lookup_enum_lom_classification_bool_exp
	_or: [lookup_enum_lom_classification_bool_exp]
	description: String_comparison_exp
	value: String_comparison_exp
}

"input type for inserting data into table \"lookup.enum_lom_classification\""
input lookup_enum_lom_classification_insert_input {
	description: String
	value: String
}

"order by max() on columns of table \"lookup.enum_lom_classification\""
input lookup_enum_lom_classification_max_order_by {
	description: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_lom_classification\""
input lookup_enum_lom_classification_min_order_by {
	description: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_lom_classification\""
input lookup_enum_lom_classification_obj_rel_insert_input {
	data: lookup_enum_lom_classification_insert_input!
	on_conflict: lookup_enum_lom_classification_on_conflict
}

"on conflict condition type for table \"lookup.enum_lom_classification\""
input lookup_enum_lom_classification_on_conflict {
	constraint: lookup_enum_lom_classification_constraint!
	update_columns: [lookup_enum_lom_classification_update_column!]!
	where: lookup_enum_lom_classification_bool_exp
}

"ordering options when selecting data from \"lookup.enum_lom_classification\""
input lookup_enum_lom_classification_order_by {
	description: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_lom_classification\""
input lookup_enum_lom_classification_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_lom_classification\""
input lookup_enum_lom_classification_set_input {
	description: String
	value: String
}

"order by aggregate values of table \"lookup.enum_lom_context\""
input lookup_enum_lom_context_aggregate_order_by {
	count: order_by
	max: lookup_enum_lom_context_max_order_by
	min: lookup_enum_lom_context_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_lom_context\""
input lookup_enum_lom_context_arr_rel_insert_input {
	data: [lookup_enum_lom_context_insert_input!]!
	on_conflict: lookup_enum_lom_context_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_lom_context\". All fields are combined with a logical 'AND'."
input lookup_enum_lom_context_bool_exp {
	_and: [lookup_enum_lom_context_bool_exp]
	_not: lookup_enum_lom_context_bool_exp
	_or: [lookup_enum_lom_context_bool_exp]
	description: String_comparison_exp
	value: String_comparison_exp
}

"input type for inserting data into table \"lookup.enum_lom_context\""
input lookup_enum_lom_context_insert_input {
	description: String
	value: String
}

"order by max() on columns of table \"lookup.enum_lom_context\""
input lookup_enum_lom_context_max_order_by {
	description: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_lom_context\""
input lookup_enum_lom_context_min_order_by {
	description: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_lom_context\""
input lookup_enum_lom_context_obj_rel_insert_input {
	data: lookup_enum_lom_context_insert_input!
	on_conflict: lookup_enum_lom_context_on_conflict
}

"on conflict condition type for table \"lookup.enum_lom_context\""
input lookup_enum_lom_context_on_conflict {
	constraint: lookup_enum_lom_context_constraint!
	update_columns: [lookup_enum_lom_context_update_column!]!
	where: lookup_enum_lom_context_bool_exp
}

"ordering options when selecting data from \"lookup.enum_lom_context\""
input lookup_enum_lom_context_order_by {
	description: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_lom_context\""
input lookup_enum_lom_context_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_lom_context\""
input lookup_enum_lom_context_set_input {
	description: String
	value: String
}

"order by aggregate values of table \"lookup.enum_profile_flags\""
input lookup_enum_profile_flags_aggregate_order_by {
	count: order_by
	max: lookup_enum_profile_flags_max_order_by
	min: lookup_enum_profile_flags_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_profile_flags\""
input lookup_enum_profile_flags_arr_rel_insert_input {
	data: [lookup_enum_profile_flags_insert_input!]!
	on_conflict: lookup_enum_profile_flags_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_profile_flags\". All fields are combined with a logical 'AND'."
input lookup_enum_profile_flags_bool_exp {
	_and: [lookup_enum_profile_flags_bool_exp]
	_not: lookup_enum_profile_flags_bool_exp
	_or: [lookup_enum_profile_flags_bool_exp]
	description: String_comparison_exp
	value: String_comparison_exp
}

"expression to compare columns of type lookup_enum_profile_flags_enum. All fields are combined with logical 'AND'."
input lookup_enum_profile_flags_enum_comparison_exp {
	_eq: lookup_enum_profile_flags_enum
	_in: [lookup_enum_profile_flags_enum!]
	_is_null: Boolean
	_neq: lookup_enum_profile_flags_enum
	_nin: [lookup_enum_profile_flags_enum!]
}

"input type for inserting data into table \"lookup.enum_profile_flags\""
input lookup_enum_profile_flags_insert_input {
	description: String
	value: String
}

"order by max() on columns of table \"lookup.enum_profile_flags\""
input lookup_enum_profile_flags_max_order_by {
	description: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_profile_flags\""
input lookup_enum_profile_flags_min_order_by {
	description: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_profile_flags\""
input lookup_enum_profile_flags_obj_rel_insert_input {
	data: lookup_enum_profile_flags_insert_input!
	on_conflict: lookup_enum_profile_flags_on_conflict
}

"on conflict condition type for table \"lookup.enum_profile_flags\""
input lookup_enum_profile_flags_on_conflict {
	constraint: lookup_enum_profile_flags_constraint!
	update_columns: [lookup_enum_profile_flags_update_column!]!
	where: lookup_enum_profile_flags_bool_exp
}

"ordering options when selecting data from \"lookup.enum_profile_flags\""
input lookup_enum_profile_flags_order_by {
	description: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_profile_flags\""
input lookup_enum_profile_flags_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_profile_flags\""
input lookup_enum_profile_flags_set_input {
	description: String
	value: String
}

"order by aggregate values of table \"lookup.enum_profile_preferences_keys\""
input lookup_enum_profile_preferences_keys_aggregate_order_by {
	count: order_by
	max: lookup_enum_profile_preferences_keys_max_order_by
	min: lookup_enum_profile_preferences_keys_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_profile_preferences_keys\""
input lookup_enum_profile_preferences_keys_arr_rel_insert_input {
	data: [lookup_enum_profile_preferences_keys_insert_input!]!
	on_conflict: lookup_enum_profile_preferences_keys_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_profile_preferences_keys\". All fields are combined with a logical 'AND'."
input lookup_enum_profile_preferences_keys_bool_exp {
	_and: [lookup_enum_profile_preferences_keys_bool_exp]
	_not: lookup_enum_profile_preferences_keys_bool_exp
	_or: [lookup_enum_profile_preferences_keys_bool_exp]
	description: String_comparison_exp
	value: String_comparison_exp
}

"expression to compare columns of type lookup_enum_profile_preferences_keys_enum. All fields are combined with logical 'AND'."
input lookup_enum_profile_preferences_keys_enum_comparison_exp {
	_eq: lookup_enum_profile_preferences_keys_enum
	_in: [lookup_enum_profile_preferences_keys_enum!]
	_is_null: Boolean
	_neq: lookup_enum_profile_preferences_keys_enum
	_nin: [lookup_enum_profile_preferences_keys_enum!]
}

"input type for inserting data into table \"lookup.enum_profile_preferences_keys\""
input lookup_enum_profile_preferences_keys_insert_input {
	description: String
	value: String
}

"order by max() on columns of table \"lookup.enum_profile_preferences_keys\""
input lookup_enum_profile_preferences_keys_max_order_by {
	description: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_profile_preferences_keys\""
input lookup_enum_profile_preferences_keys_min_order_by {
	description: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_profile_preferences_keys\""
input lookup_enum_profile_preferences_keys_obj_rel_insert_input {
	data: lookup_enum_profile_preferences_keys_insert_input!
	on_conflict: lookup_enum_profile_preferences_keys_on_conflict
}

"on conflict condition type for table \"lookup.enum_profile_preferences_keys\""
input lookup_enum_profile_preferences_keys_on_conflict {
	constraint: lookup_enum_profile_preferences_keys_constraint!
	update_columns: [lookup_enum_profile_preferences_keys_update_column!]!
	where: lookup_enum_profile_preferences_keys_bool_exp
}

"ordering options when selecting data from \"lookup.enum_profile_preferences_keys\""
input lookup_enum_profile_preferences_keys_order_by {
	description: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_profile_preferences_keys\""
input lookup_enum_profile_preferences_keys_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_profile_preferences_keys\""
input lookup_enum_profile_preferences_keys_set_input {
	description: String
	value: String
}

"order by aggregate values of table \"lookup.enum_relation_types\""
input lookup_enum_relation_types_aggregate_order_by {
	count: order_by
	max: lookup_enum_relation_types_max_order_by
	min: lookup_enum_relation_types_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_relation_types\""
input lookup_enum_relation_types_arr_rel_insert_input {
	data: [lookup_enum_relation_types_insert_input!]!
	on_conflict: lookup_enum_relation_types_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_relation_types\". All fields are combined with a logical 'AND'."
input lookup_enum_relation_types_bool_exp {
	_and: [lookup_enum_relation_types_bool_exp]
	_not: lookup_enum_relation_types_bool_exp
	_or: [lookup_enum_relation_types_bool_exp]
	description: String_comparison_exp
	value: String_comparison_exp
}

"expression to compare columns of type lookup_enum_relation_types_enum. All fields are combined with logical 'AND'."
input lookup_enum_relation_types_enum_comparison_exp {
	_eq: lookup_enum_relation_types_enum
	_in: [lookup_enum_relation_types_enum!]
	_is_null: Boolean
	_neq: lookup_enum_relation_types_enum
	_nin: [lookup_enum_relation_types_enum!]
}

"input type for inserting data into table \"lookup.enum_relation_types\""
input lookup_enum_relation_types_insert_input {
	description: String
	value: String
}

"order by max() on columns of table \"lookup.enum_relation_types\""
input lookup_enum_relation_types_max_order_by {
	description: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_relation_types\""
input lookup_enum_relation_types_min_order_by {
	description: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_relation_types\""
input lookup_enum_relation_types_obj_rel_insert_input {
	data: lookup_enum_relation_types_insert_input!
	on_conflict: lookup_enum_relation_types_on_conflict
}

"on conflict condition type for table \"lookup.enum_relation_types\""
input lookup_enum_relation_types_on_conflict {
	constraint: lookup_enum_relation_types_constraint!
	update_columns: [lookup_enum_relation_types_update_column!]!
	where: lookup_enum_relation_types_bool_exp
}

"ordering options when selecting data from \"lookup.enum_relation_types\""
input lookup_enum_relation_types_order_by {
	description: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_relation_types\""
input lookup_enum_relation_types_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_relation_types\""
input lookup_enum_relation_types_set_input {
	description: String
	value: String
}

"order by aggregate values of table \"lookup.enum_search_bookmark_types\""
input lookup_enum_search_bookmark_types_aggregate_order_by {
	count: order_by
	max: lookup_enum_search_bookmark_types_max_order_by
	min: lookup_enum_search_bookmark_types_min_order_by
}

"input type for inserting array relation for remote table \"lookup.enum_search_bookmark_types\""
input lookup_enum_search_bookmark_types_arr_rel_insert_input {
	data: [lookup_enum_search_bookmark_types_insert_input!]!
	on_conflict: lookup_enum_search_bookmark_types_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.enum_search_bookmark_types\". All fields are combined with a logical 'AND'."
input lookup_enum_search_bookmark_types_bool_exp {
	_and: [lookup_enum_search_bookmark_types_bool_exp]
	_not: lookup_enum_search_bookmark_types_bool_exp
	_or: [lookup_enum_search_bookmark_types_bool_exp]
	label: String_comparison_exp
	value: String_comparison_exp
}

"input type for inserting data into table \"lookup.enum_search_bookmark_types\""
input lookup_enum_search_bookmark_types_insert_input {
	label: String
	value: String
}

"order by max() on columns of table \"lookup.enum_search_bookmark_types\""
input lookup_enum_search_bookmark_types_max_order_by {
	label: order_by
	value: order_by
}

"order by min() on columns of table \"lookup.enum_search_bookmark_types\""
input lookup_enum_search_bookmark_types_min_order_by {
	label: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"lookup.enum_search_bookmark_types\""
input lookup_enum_search_bookmark_types_obj_rel_insert_input {
	data: lookup_enum_search_bookmark_types_insert_input!
	on_conflict: lookup_enum_search_bookmark_types_on_conflict
}

"on conflict condition type for table \"lookup.enum_search_bookmark_types\""
input lookup_enum_search_bookmark_types_on_conflict {
	constraint: lookup_enum_search_bookmark_types_constraint!
	update_columns: [lookup_enum_search_bookmark_types_update_column!]!
	where: lookup_enum_search_bookmark_types_bool_exp
}

"ordering options when selecting data from \"lookup.enum_search_bookmark_types\""
input lookup_enum_search_bookmark_types_order_by {
	label: order_by
	value: order_by
}

"primary key columns input for table: \"lookup.enum_search_bookmark_types\""
input lookup_enum_search_bookmark_types_pk_columns_input {
	value: String!
}

"input type for updating data in table \"lookup.enum_search_bookmark_types\""
input lookup_enum_search_bookmark_types_set_input {
	label: String
	value: String
}

"order by aggregate values of table \"lookup.thesaurus\""
input lookup_thesaurus_aggregate_order_by {
	count: order_by
	max: lookup_thesaurus_max_order_by
	min: lookup_thesaurus_min_order_by
}

"input type for inserting array relation for remote table \"lookup.thesaurus\""
input lookup_thesaurus_arr_rel_insert_input {
	data: [lookup_thesaurus_insert_input!]!
	on_conflict: lookup_thesaurus_on_conflict
}

"Boolean expression to filter rows from the table \"lookup.thesaurus\". All fields are combined with a logical 'AND'."
input lookup_thesaurus_bool_exp {
	_and: [lookup_thesaurus_bool_exp]
	_not: lookup_thesaurus_bool_exp
	_or: [lookup_thesaurus_bool_exp]
	id: String_comparison_exp
	label: String_comparison_exp
	scheme: String_comparison_exp
}

"input type for inserting data into table \"lookup.thesaurus\""
input lookup_thesaurus_insert_input {
	id: String
	label: String
	scheme: String
}

"order by max() on columns of table \"lookup.thesaurus\""
input lookup_thesaurus_max_order_by {
	id: order_by
	label: order_by
	scheme: order_by
}

"order by min() on columns of table \"lookup.thesaurus\""
input lookup_thesaurus_min_order_by {
	id: order_by
	label: order_by
	scheme: order_by
}

"input type for inserting object relation for remote table \"lookup.thesaurus\""
input lookup_thesaurus_obj_rel_insert_input {
	data: lookup_thesaurus_insert_input!
	on_conflict: lookup_thesaurus_on_conflict
}

"on conflict condition type for table \"lookup.thesaurus\""
input lookup_thesaurus_on_conflict {
	constraint: lookup_thesaurus_constraint!
	update_columns: [lookup_thesaurus_update_column!]!
	where: lookup_thesaurus_bool_exp
}

"ordering options when selecting data from \"lookup.thesaurus\""
input lookup_thesaurus_order_by {
	id: order_by
	label: order_by
	scheme: order_by
}

"primary key columns input for table: \"lookup.thesaurus\""
input lookup_thesaurus_pk_columns_input {
	id: String!
}

"input type for updating data in table \"lookup.thesaurus\""
input lookup_thesaurus_set_input {
	id: String
	label: String
	scheme: String
}

"order by aggregate values of table \"migrate.original_publishdate\""
input migrate_original_publishdate_aggregate_order_by {
	count: order_by
	max: migrate_original_publishdate_max_order_by
	min: migrate_original_publishdate_min_order_by
}

"input type for inserting array relation for remote table \"migrate.original_publishdate\""
input migrate_original_publishdate_arr_rel_insert_input {
	data: [migrate_original_publishdate_insert_input!]!
	on_conflict: migrate_original_publishdate_on_conflict
}

"Boolean expression to filter rows from the table \"migrate.original_publishdate\". All fields are combined with a logical 'AND'."
input migrate_original_publishdate_bool_exp {
	_and: [migrate_original_publishdate_bool_exp]
	_not: migrate_original_publishdate_bool_exp
	_or: [migrate_original_publishdate_bool_exp]
	created_at: timestamptz_comparison_exp
	external_id: String_comparison_exp
	mediamosa_id: String_comparison_exp
}

"input type for inserting data into table \"migrate.original_publishdate\""
input migrate_original_publishdate_insert_input {
	created_at: timestamptz
	external_id: String
	mediamosa_id: String
}

"order by max() on columns of table \"migrate.original_publishdate\""
input migrate_original_publishdate_max_order_by {
	created_at: order_by
	external_id: order_by
	mediamosa_id: order_by
}

"order by min() on columns of table \"migrate.original_publishdate\""
input migrate_original_publishdate_min_order_by {
	created_at: order_by
	external_id: order_by
	mediamosa_id: order_by
}

"input type for inserting object relation for remote table \"migrate.original_publishdate\""
input migrate_original_publishdate_obj_rel_insert_input {
	data: migrate_original_publishdate_insert_input!
	on_conflict: migrate_original_publishdate_on_conflict
}

"on conflict condition type for table \"migrate.original_publishdate\""
input migrate_original_publishdate_on_conflict {
	constraint: migrate_original_publishdate_constraint!
	update_columns: [migrate_original_publishdate_update_column!]!
	where: migrate_original_publishdate_bool_exp
}

"ordering options when selecting data from \"migrate.original_publishdate\""
input migrate_original_publishdate_order_by {
	created_at: order_by
	external_id: order_by
	mediamosa_id: order_by
}

"primary key columns input for table: \"migrate.original_publishdate\""
input migrate_original_publishdate_pk_columns_input {
	mediamosa_id: String!
}

"input type for updating data in table \"migrate.original_publishdate\""
input migrate_original_publishdate_set_input {
	created_at: timestamptz
	external_id: String
	mediamosa_id: String
}

"order by aggregate values of table \"migrate.reference_ids\""
input migrate_reference_ids_aggregate_order_by {
	avg: migrate_reference_ids_avg_order_by
	count: order_by
	max: migrate_reference_ids_max_order_by
	min: migrate_reference_ids_min_order_by
	stddev: migrate_reference_ids_stddev_order_by
	stddev_pop: migrate_reference_ids_stddev_pop_order_by
	stddev_samp: migrate_reference_ids_stddev_samp_order_by
	sum: migrate_reference_ids_sum_order_by
	var_pop: migrate_reference_ids_var_pop_order_by
	var_samp: migrate_reference_ids_var_samp_order_by
	variance: migrate_reference_ids_variance_order_by
}

"input type for inserting array relation for remote table \"migrate.reference_ids\""
input migrate_reference_ids_arr_rel_insert_input {
	data: [migrate_reference_ids_insert_input!]!
	on_conflict: migrate_reference_ids_on_conflict
}

"order by avg() on columns of table \"migrate.reference_ids\""
input migrate_reference_ids_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"migrate.reference_ids\". All fields are combined with a logical 'AND'."
input migrate_reference_ids_bool_exp {
	_and: [migrate_reference_ids_bool_exp]
	_not: migrate_reference_ids_bool_exp
	_or: [migrate_reference_ids_bool_exp]
	created_at: timestamptz_comparison_exp
	external_id: String_comparison_exp
	id: Int_comparison_exp
	mediamosa_id: String_comparison_exp
	type_label: String_comparison_exp
}

"input type for incrementing integer column in table \"migrate.reference_ids\""
input migrate_reference_ids_inc_input {
	id: Int
}

"input type for inserting data into table \"migrate.reference_ids\""
input migrate_reference_ids_insert_input {
	created_at: timestamptz
	external_id: String
	id: Int
	mediamosa_id: String
	type_label: String
}

"order by max() on columns of table \"migrate.reference_ids\""
input migrate_reference_ids_max_order_by {
	created_at: order_by
	external_id: order_by
	id: order_by
	mediamosa_id: order_by
	type_label: order_by
}

"order by min() on columns of table \"migrate.reference_ids\""
input migrate_reference_ids_min_order_by {
	created_at: order_by
	external_id: order_by
	id: order_by
	mediamosa_id: order_by
	type_label: order_by
}

"input type for inserting object relation for remote table \"migrate.reference_ids\""
input migrate_reference_ids_obj_rel_insert_input {
	data: migrate_reference_ids_insert_input!
	on_conflict: migrate_reference_ids_on_conflict
}

"on conflict condition type for table \"migrate.reference_ids\""
input migrate_reference_ids_on_conflict {
	constraint: migrate_reference_ids_constraint!
	update_columns: [migrate_reference_ids_update_column!]!
	where: migrate_reference_ids_bool_exp
}

"ordering options when selecting data from \"migrate.reference_ids\""
input migrate_reference_ids_order_by {
	created_at: order_by
	external_id: order_by
	id: order_by
	mediamosa_id: order_by
	type_label: order_by
}

"primary key columns input for table: \"migrate.reference_ids\""
input migrate_reference_ids_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"migrate.reference_ids\""
input migrate_reference_ids_set_input {
	created_at: timestamptz
	external_id: String
	id: Int
	mediamosa_id: String
	type_label: String
}

"order by stddev() on columns of table \"migrate.reference_ids\""
input migrate_reference_ids_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"migrate.reference_ids\""
input migrate_reference_ids_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"migrate.reference_ids\""
input migrate_reference_ids_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"migrate.reference_ids\""
input migrate_reference_ids_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"migrate.reference_ids\""
input migrate_reference_ids_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"migrate.reference_ids\""
input migrate_reference_ids_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"migrate.reference_ids\""
input migrate_reference_ids_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"shared.collateral\""
input shared_collateral_aggregate_order_by {
	avg: shared_collateral_avg_order_by
	count: order_by
	max: shared_collateral_max_order_by
	min: shared_collateral_min_order_by
	stddev: shared_collateral_stddev_order_by
	stddev_pop: shared_collateral_stddev_pop_order_by
	stddev_samp: shared_collateral_stddev_samp_order_by
	sum: shared_collateral_sum_order_by
	var_pop: shared_collateral_var_pop_order_by
	var_samp: shared_collateral_var_samp_order_by
	variance: shared_collateral_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input shared_collateral_append_input {
	json: jsonb
}

"input type for inserting array relation for remote table \"shared.collateral\""
input shared_collateral_arr_rel_insert_input {
	data: [shared_collateral_insert_input!]!
	on_conflict: shared_collateral_on_conflict
}

"order by avg() on columns of table \"shared.collateral\""
input shared_collateral_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"shared.collateral\". All fields are combined with a logical 'AND'."
input shared_collateral_bool_exp {
	_and: [shared_collateral_bool_exp]
	_not: shared_collateral_bool_exp
	_or: [shared_collateral_bool_exp]
	created_at: timestamptz_comparison_exp
	external_id: String_comparison_exp
	id: Int_comparison_exp
	json: jsonb_comparison_exp
	pid: String_comparison_exp
	status: item_publishing_status_comparison_exp
	title: String_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input shared_collateral_delete_at_path_input {
	json: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input shared_collateral_delete_elem_input {
	json: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input shared_collateral_delete_key_input {
	json: String
}

"input type for incrementing integer column in table \"shared.collateral\""
input shared_collateral_inc_input {
	id: Int
}

"input type for inserting data into table \"shared.collateral\""
input shared_collateral_insert_input {
	created_at: timestamptz
	external_id: String
	id: Int
	json: jsonb
	pid: String
	status: item_publishing_status
	title: String
	updated_at: timestamptz
}

"order by max() on columns of table \"shared.collateral\""
input shared_collateral_max_order_by {
	created_at: order_by
	external_id: order_by
	id: order_by
	pid: order_by
	title: order_by
	updated_at: order_by
}

"order by min() on columns of table \"shared.collateral\""
input shared_collateral_min_order_by {
	created_at: order_by
	external_id: order_by
	id: order_by
	pid: order_by
	title: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"shared.collateral\""
input shared_collateral_obj_rel_insert_input {
	data: shared_collateral_insert_input!
	on_conflict: shared_collateral_on_conflict
}

"on conflict condition type for table \"shared.collateral\""
input shared_collateral_on_conflict {
	constraint: shared_collateral_constraint!
	update_columns: [shared_collateral_update_column!]!
	where: shared_collateral_bool_exp
}

"ordering options when selecting data from \"shared.collateral\""
input shared_collateral_order_by {
	created_at: order_by
	external_id: order_by
	id: order_by
	json: order_by
	pid: order_by
	status: order_by
	title: order_by
	updated_at: order_by
}

"primary key columns input for table: \"shared.collateral\""
input shared_collateral_pk_columns_input {
	id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input shared_collateral_prepend_input {
	json: jsonb
}

"input type for updating data in table \"shared.collateral\""
input shared_collateral_set_input {
	created_at: timestamptz
	external_id: String
	id: Int
	json: jsonb
	pid: String
	status: item_publishing_status
	title: String
	updated_at: timestamptz
}

"order by stddev() on columns of table \"shared.collateral\""
input shared_collateral_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"shared.collateral\""
input shared_collateral_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"shared.collateral\""
input shared_collateral_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"shared.collateral\""
input shared_collateral_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"shared.collateral\""
input shared_collateral_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"shared.collateral\""
input shared_collateral_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"shared.collateral\""
input shared_collateral_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"shared.items\""
input shared_items_aggregate_order_by {
	avg: shared_items_avg_order_by
	count: order_by
	max: shared_items_max_order_by
	min: shared_items_min_order_by
	stddev: shared_items_stddev_order_by
	stddev_pop: shared_items_stddev_pop_order_by
	stddev_samp: shared_items_stddev_samp_order_by
	sum: shared_items_sum_order_by
	var_pop: shared_items_var_pop_order_by
	var_samp: shared_items_var_samp_order_by
	variance: shared_items_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input shared_items_append_input {
	json: jsonb
}

"input type for inserting array relation for remote table \"shared.items\""
input shared_items_arr_rel_insert_input {
	data: [shared_items_insert_input!]!
	on_conflict: shared_items_on_conflict
}

"order by avg() on columns of table \"shared.items\""
input shared_items_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"shared.items\". All fields are combined with a logical 'AND'."
input shared_items_bool_exp {
	_and: [shared_items_bool_exp]
	_not: shared_items_bool_exp
	_or: [shared_items_bool_exp]
	created_at: timestamptz_comparison_exp
	external_id: String_comparison_exp
	id: Int_comparison_exp
	item_meta: app_item_meta_bool_exp
	json: jsonb_comparison_exp
	pid: String_comparison_exp
	status: item_publishing_status_comparison_exp
	title: String_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input shared_items_delete_at_path_input {
	json: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input shared_items_delete_elem_input {
	json: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input shared_items_delete_key_input {
	json: String
}

"input type for incrementing integer column in table \"shared.items\""
input shared_items_inc_input {
	id: Int
}

"input type for inserting data into table \"shared.items\""
input shared_items_insert_input {
	created_at: timestamptz
	external_id: String
	id: Int
	item_meta: app_item_meta_obj_rel_insert_input
	json: jsonb
	pid: String
	status: item_publishing_status
	title: String
	updated_at: timestamptz
}

"order by max() on columns of table \"shared.items\""
input shared_items_max_order_by {
	created_at: order_by
	external_id: order_by
	id: order_by
	pid: order_by
	title: order_by
	updated_at: order_by
}

"order by min() on columns of table \"shared.items\""
input shared_items_min_order_by {
	created_at: order_by
	external_id: order_by
	id: order_by
	pid: order_by
	title: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"shared.items\""
input shared_items_obj_rel_insert_input {
	data: shared_items_insert_input!
	on_conflict: shared_items_on_conflict
}

"on conflict condition type for table \"shared.items\""
input shared_items_on_conflict {
	constraint: shared_items_constraint!
	update_columns: [shared_items_update_column!]!
	where: shared_items_bool_exp
}

"ordering options when selecting data from \"shared.items\""
input shared_items_order_by {
	created_at: order_by
	external_id: order_by
	id: order_by
	item_meta: app_item_meta_order_by
	json: order_by
	pid: order_by
	status: order_by
	title: order_by
	updated_at: order_by
}

"primary key columns input for table: \"shared.items\""
input shared_items_pk_columns_input {
	id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input shared_items_prepend_input {
	json: jsonb
}

"input type for updating data in table \"shared.items\""
input shared_items_set_input {
	created_at: timestamptz
	external_id: String
	id: Int
	json: jsonb
	pid: String
	status: item_publishing_status
	title: String
	updated_at: timestamptz
}

"order by stddev() on columns of table \"shared.items\""
input shared_items_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"shared.items\""
input shared_items_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"shared.items\""
input shared_items_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"shared.items\""
input shared_items_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"shared.items\""
input shared_items_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"shared.items\""
input shared_items_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"shared.items\""
input shared_items_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"shared.ldap_organizations\""
input shared_ldap_organizations_aggregate_order_by {
	avg: shared_ldap_organizations_avg_order_by
	count: order_by
	max: shared_ldap_organizations_max_order_by
	min: shared_ldap_organizations_min_order_by
	stddev: shared_ldap_organizations_stddev_order_by
	stddev_pop: shared_ldap_organizations_stddev_pop_order_by
	stddev_samp: shared_ldap_organizations_stddev_samp_order_by
	sum: shared_ldap_organizations_sum_order_by
	var_pop: shared_ldap_organizations_var_pop_order_by
	var_samp: shared_ldap_organizations_var_samp_order_by
	variance: shared_ldap_organizations_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input shared_ldap_organizations_append_input {
	ldap_content: jsonb
}

"input type for inserting array relation for remote table \"shared.ldap_organizations\""
input shared_ldap_organizations_arr_rel_insert_input {
	data: [shared_ldap_organizations_insert_input!]!
	on_conflict: shared_ldap_organizations_on_conflict
}

"order by avg() on columns of table \"shared.ldap_organizations\""
input shared_ldap_organizations_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"shared.ldap_organizations\". All fields are combined with a logical 'AND'."
input shared_ldap_organizations_bool_exp {
	_and: [shared_ldap_organizations_bool_exp]
	_not: shared_ldap_organizations_bool_exp
	_or: [shared_ldap_organizations_bool_exp]
	created_at: timestamptz_comparison_exp
	id: Int_comparison_exp
	ldap_content: jsonb_comparison_exp
	ldap_description: String_comparison_exp
	ldap_entryuuid: uuid_comparison_exp
	ldap_modifytimestamp: timestamptz_comparison_exp
	organization_id: String_comparison_exp
	type: String_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input shared_ldap_organizations_delete_at_path_input {
	ldap_content: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input shared_ldap_organizations_delete_elem_input {
	ldap_content: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input shared_ldap_organizations_delete_key_input {
	ldap_content: String
}

"input type for incrementing integer column in table \"shared.ldap_organizations\""
input shared_ldap_organizations_inc_input {
	id: Int
}

"input type for inserting data into table \"shared.ldap_organizations\""
input shared_ldap_organizations_insert_input {
	created_at: timestamptz
	id: Int
	ldap_content: jsonb
	ldap_description: String
	ldap_entryuuid: uuid
	ldap_modifytimestamp: timestamptz
	organization_id: String
	type: String
	updated_at: timestamptz
}

"order by max() on columns of table \"shared.ldap_organizations\""
input shared_ldap_organizations_max_order_by {
	created_at: order_by
	id: order_by
	ldap_description: order_by
	ldap_entryuuid: order_by
	ldap_modifytimestamp: order_by
	organization_id: order_by
	type: order_by
	updated_at: order_by
}

"order by min() on columns of table \"shared.ldap_organizations\""
input shared_ldap_organizations_min_order_by {
	created_at: order_by
	id: order_by
	ldap_description: order_by
	ldap_entryuuid: order_by
	ldap_modifytimestamp: order_by
	organization_id: order_by
	type: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"shared.ldap_organizations\""
input shared_ldap_organizations_obj_rel_insert_input {
	data: shared_ldap_organizations_insert_input!
	on_conflict: shared_ldap_organizations_on_conflict
}

"on conflict condition type for table \"shared.ldap_organizations\""
input shared_ldap_organizations_on_conflict {
	constraint: shared_ldap_organizations_constraint!
	update_columns: [shared_ldap_organizations_update_column!]!
	where: shared_ldap_organizations_bool_exp
}

"ordering options when selecting data from \"shared.ldap_organizations\""
input shared_ldap_organizations_order_by {
	created_at: order_by
	id: order_by
	ldap_content: order_by
	ldap_description: order_by
	ldap_entryuuid: order_by
	ldap_modifytimestamp: order_by
	organization_id: order_by
	type: order_by
	updated_at: order_by
}

"primary key columns input for table: \"shared.ldap_organizations\""
input shared_ldap_organizations_pk_columns_input {
	id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input shared_ldap_organizations_prepend_input {
	ldap_content: jsonb
}

"input type for updating data in table \"shared.ldap_organizations\""
input shared_ldap_organizations_set_input {
	created_at: timestamptz
	id: Int
	ldap_content: jsonb
	ldap_description: String
	ldap_entryuuid: uuid
	ldap_modifytimestamp: timestamptz
	organization_id: String
	type: String
	updated_at: timestamptz
}

"order by stddev() on columns of table \"shared.ldap_organizations\""
input shared_ldap_organizations_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"shared.ldap_organizations\""
input shared_ldap_organizations_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"shared.ldap_organizations\""
input shared_ldap_organizations_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"shared.ldap_organizations\""
input shared_ldap_organizations_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"shared.ldap_organizations\""
input shared_ldap_organizations_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"shared.ldap_organizations\""
input shared_ldap_organizations_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"shared.ldap_organizations\""
input shared_ldap_organizations_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"shared.organisations\""
input shared_organisations_aggregate_order_by {
	count: order_by
	max: shared_organisations_max_order_by
	min: shared_organisations_min_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input shared_organisations_append_input {
	data: jsonb
}

"input type for inserting array relation for remote table \"shared.organisations\""
input shared_organisations_arr_rel_insert_input {
	data: [shared_organisations_insert_input!]!
	on_conflict: shared_organisations_on_conflict
}

"Boolean expression to filter rows from the table \"shared.organisations\". All fields are combined with a logical 'AND'."
input shared_organisations_bool_exp {
	_and: [shared_organisations_bool_exp]
	_not: shared_organisations_bool_exp
	_or: [shared_organisations_bool_exp]
	data: jsonb_comparison_exp
	description: String_comparison_exp
	logo_url: String_comparison_exp
	name: String_comparison_exp
	or_id: String_comparison_exp
	website: String_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input shared_organisations_delete_at_path_input {
	data: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input shared_organisations_delete_elem_input {
	data: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input shared_organisations_delete_key_input {
	data: String
}

"input type for inserting data into table \"shared.organisations\""
input shared_organisations_insert_input {
	data: jsonb
	description: String
	logo_url: String
	name: String
	or_id: String
	website: String
}

"order by max() on columns of table \"shared.organisations\""
input shared_organisations_max_order_by {
	description: order_by
	logo_url: order_by
	name: order_by
	or_id: order_by
	website: order_by
}

"order by min() on columns of table \"shared.organisations\""
input shared_organisations_min_order_by {
	description: order_by
	logo_url: order_by
	name: order_by
	or_id: order_by
	website: order_by
}

"input type for inserting object relation for remote table \"shared.organisations\""
input shared_organisations_obj_rel_insert_input {
	data: shared_organisations_insert_input!
	on_conflict: shared_organisations_on_conflict
}

"on conflict condition type for table \"shared.organisations\""
input shared_organisations_on_conflict {
	constraint: shared_organisations_constraint!
	update_columns: [shared_organisations_update_column!]!
	where: shared_organisations_bool_exp
}

"ordering options when selecting data from \"shared.organisations\""
input shared_organisations_order_by {
	data: order_by
	description: order_by
	logo_url: order_by
	name: order_by
	or_id: order_by
	website: order_by
}

"primary key columns input for table: \"shared.organisations\""
input shared_organisations_pk_columns_input {
	or_id: String!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input shared_organisations_prepend_input {
	data: jsonb
}

"input type for updating data in table \"shared.organisations\""
input shared_organisations_set_input {
	data: jsonb
	description: String
	logo_url: String
	name: String
	or_id: String
	website: String
}

"order by aggregate values of table \"shared.organisations_with_users\""
input shared_organisations_with_users_aggregate_order_by {
	count: order_by
	max: shared_organisations_with_users_max_order_by
	min: shared_organisations_with_users_min_order_by
}

"Boolean expression to filter rows from the table \"shared.organisations_with_users\". All fields are combined with a logical 'AND'."
input shared_organisations_with_users_bool_exp {
	_and: [shared_organisations_with_users_bool_exp]
	_not: shared_organisations_with_users_bool_exp
	_or: [shared_organisations_with_users_bool_exp]
	company_id: String_comparison_exp
	name: String_comparison_exp
}

"order by max() on columns of table \"shared.organisations_with_users\""
input shared_organisations_with_users_max_order_by {
	company_id: order_by
	name: order_by
}

"order by min() on columns of table \"shared.organisations_with_users\""
input shared_organisations_with_users_min_order_by {
	company_id: order_by
	name: order_by
}

"ordering options when selecting data from \"shared.organisations_with_users\""
input shared_organisations_with_users_order_by {
	company_id: order_by
	name: order_by
}

"order by aggregate values of table \"shared.types\""
input shared_types_aggregate_order_by {
	avg: shared_types_avg_order_by
	count: order_by
	max: shared_types_max_order_by
	min: shared_types_min_order_by
	stddev: shared_types_stddev_order_by
	stddev_pop: shared_types_stddev_pop_order_by
	stddev_samp: shared_types_stddev_samp_order_by
	sum: shared_types_sum_order_by
	var_pop: shared_types_var_pop_order_by
	var_samp: shared_types_var_samp_order_by
	variance: shared_types_variance_order_by
}

"input type for inserting array relation for remote table \"shared.types\""
input shared_types_arr_rel_insert_input {
	data: [shared_types_insert_input!]!
	on_conflict: shared_types_on_conflict
}

"order by avg() on columns of table \"shared.types\""
input shared_types_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"shared.types\". All fields are combined with a logical 'AND'."
input shared_types_bool_exp {
	_and: [shared_types_bool_exp]
	_not: shared_types_bool_exp
	_or: [shared_types_bool_exp]
	id: Int_comparison_exp
	label: String_comparison_exp
}

"input type for incrementing integer column in table \"shared.types\""
input shared_types_inc_input {
	id: Int
}

"input type for inserting data into table \"shared.types\""
input shared_types_insert_input {
	id: Int
	label: String
}

"order by max() on columns of table \"shared.types\""
input shared_types_max_order_by {
	id: order_by
	label: order_by
}

"order by min() on columns of table \"shared.types\""
input shared_types_min_order_by {
	id: order_by
	label: order_by
}

"input type for inserting object relation for remote table \"shared.types\""
input shared_types_obj_rel_insert_input {
	data: shared_types_insert_input!
	on_conflict: shared_types_on_conflict
}

"on conflict condition type for table \"shared.types\""
input shared_types_on_conflict {
	constraint: shared_types_constraint!
	update_columns: [shared_types_update_column!]!
	where: shared_types_bool_exp
}

"ordering options when selecting data from \"shared.types\""
input shared_types_order_by {
	id: order_by
	label: order_by
}

"primary key columns input for table: \"shared.types\""
input shared_types_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"shared.types\""
input shared_types_set_input {
	id: Int
	label: String
}

"order by stddev() on columns of table \"shared.types\""
input shared_types_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"shared.types\""
input shared_types_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"shared.types\""
input shared_types_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"shared.types\""
input shared_types_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"shared.types\""
input shared_types_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"shared.types\""
input shared_types_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"shared.types\""
input shared_types_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"shared.user_last_blocked\""
input shared_user_last_blocked_aggregate_order_by {
	count: order_by
	max: shared_user_last_blocked_max_order_by
	min: shared_user_last_blocked_min_order_by
}

"Boolean expression to filter rows from the table \"shared.user_last_blocked\". All fields are combined with a logical 'AND'."
input shared_user_last_blocked_bool_exp {
	_and: [shared_user_last_blocked_bool_exp]
	_not: shared_user_last_blocked_bool_exp
	_or: [shared_user_last_blocked_bool_exp]
	event: String_comparison_exp
	max: timestamptz_comparison_exp
	user_id: uuid_comparison_exp
}

"order by max() on columns of table \"shared.user_last_blocked\""
input shared_user_last_blocked_max_order_by {
	event: order_by
	max: order_by
	user_id: order_by
}

"order by min() on columns of table \"shared.user_last_blocked\""
input shared_user_last_blocked_min_order_by {
	event: order_by
	max: order_by
	user_id: order_by
}

"ordering options when selecting data from \"shared.user_last_blocked\""
input shared_user_last_blocked_order_by {
	event: order_by
	max: order_by
	user_id: order_by
}

"order by aggregate values of table \"shared.user_last_unblocked\""
input shared_user_last_unblocked_aggregate_order_by {
	count: order_by
	max: shared_user_last_unblocked_max_order_by
	min: shared_user_last_unblocked_min_order_by
}

"Boolean expression to filter rows from the table \"shared.user_last_unblocked\". All fields are combined with a logical 'AND'."
input shared_user_last_unblocked_bool_exp {
	_and: [shared_user_last_unblocked_bool_exp]
	_not: shared_user_last_unblocked_bool_exp
	_or: [shared_user_last_unblocked_bool_exp]
	event: String_comparison_exp
	max: timestamptz_comparison_exp
	user_id: uuid_comparison_exp
}

"order by max() on columns of table \"shared.user_last_unblocked\""
input shared_user_last_unblocked_max_order_by {
	event: order_by
	max: order_by
	user_id: order_by
}

"order by min() on columns of table \"shared.user_last_unblocked\""
input shared_user_last_unblocked_min_order_by {
	event: order_by
	max: order_by
	user_id: order_by
}

"ordering options when selecting data from \"shared.user_last_unblocked\""
input shared_user_last_unblocked_order_by {
	event: order_by
	max: order_by
	user_id: order_by
}

"order by aggregate values of table \"shared.user_names\""
input shared_user_names_aggregate_order_by {
	count: order_by
	max: shared_user_names_max_order_by
	min: shared_user_names_min_order_by
}

"Boolean expression to filter rows from the table \"shared.user_names\". All fields are combined with a logical 'AND'."
input shared_user_names_bool_exp {
	_and: [shared_user_names_bool_exp]
	_not: shared_user_names_bool_exp
	_or: [shared_user_names_bool_exp]
	first_name: String_comparison_exp
	full_name: String_comparison_exp
	full_name_lower: String_comparison_exp
	last_name: String_comparison_exp
	mail: String_comparison_exp
	profile_id: uuid_comparison_exp
	user_id: uuid_comparison_exp
}

"order by max() on columns of table \"shared.user_names\""
input shared_user_names_max_order_by {
	first_name: order_by
	full_name: order_by
	full_name_lower: order_by
	last_name: order_by
	mail: order_by
	profile_id: order_by
	user_id: order_by
}

"order by min() on columns of table \"shared.user_names\""
input shared_user_names_min_order_by {
	first_name: order_by
	full_name: order_by
	full_name_lower: order_by
	last_name: order_by
	mail: order_by
	profile_id: order_by
	user_id: order_by
}

"ordering options when selecting data from \"shared.user_names\""
input shared_user_names_order_by {
	first_name: order_by
	full_name: order_by
	full_name_lower: order_by
	last_name: order_by
	mail: order_by
	profile_id: order_by
	user_id: order_by
}

"order by aggregate values of table \"shared.user_roles\""
input shared_user_roles_aggregate_order_by {
	avg: shared_user_roles_avg_order_by
	count: order_by
	max: shared_user_roles_max_order_by
	min: shared_user_roles_min_order_by
	stddev: shared_user_roles_stddev_order_by
	stddev_pop: shared_user_roles_stddev_pop_order_by
	stddev_samp: shared_user_roles_stddev_samp_order_by
	sum: shared_user_roles_sum_order_by
	var_pop: shared_user_roles_var_pop_order_by
	var_samp: shared_user_roles_var_samp_order_by
	variance: shared_user_roles_variance_order_by
}

"input type for inserting array relation for remote table \"shared.user_roles\""
input shared_user_roles_arr_rel_insert_input {
	data: [shared_user_roles_insert_input!]!
	on_conflict: shared_user_roles_on_conflict
}

"order by avg() on columns of table \"shared.user_roles\""
input shared_user_roles_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"shared.user_roles\". All fields are combined with a logical 'AND'."
input shared_user_roles_bool_exp {
	_and: [shared_user_roles_bool_exp]
	_not: shared_user_roles_bool_exp
	_or: [shared_user_roles_bool_exp]
	id: Int_comparison_exp
	label: String_comparison_exp
	name: String_comparison_exp
	users: shared_users_bool_exp
}

"input type for incrementing integer column in table \"shared.user_roles\""
input shared_user_roles_inc_input {
	id: Int
}

"input type for inserting data into table \"shared.user_roles\""
input shared_user_roles_insert_input {
	id: Int
	label: String
	name: String
	users: shared_users_arr_rel_insert_input
}

"order by max() on columns of table \"shared.user_roles\""
input shared_user_roles_max_order_by {
	id: order_by
	label: order_by
	name: order_by
}

"order by min() on columns of table \"shared.user_roles\""
input shared_user_roles_min_order_by {
	id: order_by
	label: order_by
	name: order_by
}

"input type for inserting object relation for remote table \"shared.user_roles\""
input shared_user_roles_obj_rel_insert_input {
	data: shared_user_roles_insert_input!
	on_conflict: shared_user_roles_on_conflict
}

"on conflict condition type for table \"shared.user_roles\""
input shared_user_roles_on_conflict {
	constraint: shared_user_roles_constraint!
	update_columns: [shared_user_roles_update_column!]!
	where: shared_user_roles_bool_exp
}

"ordering options when selecting data from \"shared.user_roles\""
input shared_user_roles_order_by {
	id: order_by
	label: order_by
	name: order_by
	users_aggregate: shared_users_aggregate_order_by
}

"primary key columns input for table: \"shared.user_roles\""
input shared_user_roles_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"shared.user_roles\""
input shared_user_roles_set_input {
	id: Int
	label: String
	name: String
}

"order by stddev() on columns of table \"shared.user_roles\""
input shared_user_roles_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"shared.user_roles\""
input shared_user_roles_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"shared.user_roles\""
input shared_user_roles_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"shared.user_roles\""
input shared_user_roles_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"shared.user_roles\""
input shared_user_roles_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"shared.user_roles\""
input shared_user_roles_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"shared.user_roles\""
input shared_user_roles_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"shared.user_temp_access\""
input shared_user_temp_access_aggregate_order_by {
	count: order_by
	max: shared_user_temp_access_max_order_by
	min: shared_user_temp_access_min_order_by
}

"input type for inserting array relation for remote table \"shared.user_temp_access\""
input shared_user_temp_access_arr_rel_insert_input {
	data: [shared_user_temp_access_insert_input!]!
	on_conflict: shared_user_temp_access_on_conflict
}

"Boolean expression to filter rows from the table \"shared.user_temp_access\". All fields are combined with a logical 'AND'."
input shared_user_temp_access_bool_exp {
	_and: [shared_user_temp_access_bool_exp]
	_not: shared_user_temp_access_bool_exp
	_or: [shared_user_temp_access_bool_exp]
	created_at: timestamptz_comparison_exp
	current: shared_user_temp_access_status_bool_exp
	from: date_comparison_exp
	until: date_comparison_exp
	updated_at: timestamptz_comparison_exp
	user: shared_users_bool_exp
	user_id: uuid_comparison_exp
}

"input type for inserting data into table \"shared.user_temp_access\""
input shared_user_temp_access_insert_input {
	created_at: timestamptz
	from: date
	until: date
	updated_at: timestamptz
	user: shared_users_obj_rel_insert_input
	user_id: uuid
}

"order by max() on columns of table \"shared.user_temp_access\""
input shared_user_temp_access_max_order_by {
	created_at: order_by
	from: order_by
	until: order_by
	updated_at: order_by
	user_id: order_by
}

"order by min() on columns of table \"shared.user_temp_access\""
input shared_user_temp_access_min_order_by {
	created_at: order_by
	from: order_by
	until: order_by
	updated_at: order_by
	user_id: order_by
}

"input type for inserting object relation for remote table \"shared.user_temp_access\""
input shared_user_temp_access_obj_rel_insert_input {
	data: shared_user_temp_access_insert_input!
	on_conflict: shared_user_temp_access_on_conflict
}

"on conflict condition type for table \"shared.user_temp_access\""
input shared_user_temp_access_on_conflict {
	constraint: shared_user_temp_access_constraint!
	update_columns: [shared_user_temp_access_update_column!]!
	where: shared_user_temp_access_bool_exp
}

"ordering options when selecting data from \"shared.user_temp_access\""
input shared_user_temp_access_order_by {
	created_at: order_by
	current: shared_user_temp_access_status_order_by
	from: order_by
	until: order_by
	updated_at: order_by
	user: shared_users_order_by
	user_id: order_by
}

"primary key columns input for table: \"shared.user_temp_access\""
input shared_user_temp_access_pk_columns_input {
	user_id: uuid!
}

"input type for updating data in table \"shared.user_temp_access\""
input shared_user_temp_access_set_input {
	created_at: timestamptz
	from: date
	until: date
	updated_at: timestamptz
	user_id: uuid
}

"order by aggregate values of table \"shared.user_temp_access_status\""
input shared_user_temp_access_status_aggregate_order_by {
	avg: shared_user_temp_access_status_avg_order_by
	count: order_by
	max: shared_user_temp_access_status_max_order_by
	min: shared_user_temp_access_status_min_order_by
	stddev: shared_user_temp_access_status_stddev_order_by
	stddev_pop: shared_user_temp_access_status_stddev_pop_order_by
	stddev_samp: shared_user_temp_access_status_stddev_samp_order_by
	sum: shared_user_temp_access_status_sum_order_by
	var_pop: shared_user_temp_access_status_var_pop_order_by
	var_samp: shared_user_temp_access_status_var_samp_order_by
	variance: shared_user_temp_access_status_variance_order_by
}

"order by avg() on columns of table \"shared.user_temp_access_status\""
input shared_user_temp_access_status_avg_order_by {
	status: order_by
}

"Boolean expression to filter rows from the table \"shared.user_temp_access_status\". All fields are combined with a logical 'AND'."
input shared_user_temp_access_status_bool_exp {
	_and: [shared_user_temp_access_status_bool_exp]
	_not: shared_user_temp_access_status_bool_exp
	_or: [shared_user_temp_access_status_bool_exp]
	status: Int_comparison_exp
	uid: uuid_comparison_exp
}

"order by max() on columns of table \"shared.user_temp_access_status\""
input shared_user_temp_access_status_max_order_by {
	status: order_by
	uid: order_by
}

"order by min() on columns of table \"shared.user_temp_access_status\""
input shared_user_temp_access_status_min_order_by {
	status: order_by
	uid: order_by
}

"ordering options when selecting data from \"shared.user_temp_access_status\""
input shared_user_temp_access_status_order_by {
	status: order_by
	uid: order_by
}

"order by stddev() on columns of table \"shared.user_temp_access_status\""
input shared_user_temp_access_status_stddev_order_by {
	status: order_by
}

"order by stddev_pop() on columns of table \"shared.user_temp_access_status\""
input shared_user_temp_access_status_stddev_pop_order_by {
	status: order_by
}

"order by stddev_samp() on columns of table \"shared.user_temp_access_status\""
input shared_user_temp_access_status_stddev_samp_order_by {
	status: order_by
}

"order by sum() on columns of table \"shared.user_temp_access_status\""
input shared_user_temp_access_status_sum_order_by {
	status: order_by
}

"order by var_pop() on columns of table \"shared.user_temp_access_status\""
input shared_user_temp_access_status_var_pop_order_by {
	status: order_by
}

"order by var_samp() on columns of table \"shared.user_temp_access_status\""
input shared_user_temp_access_status_var_samp_order_by {
	status: order_by
}

"order by variance() on columns of table \"shared.user_temp_access_status\""
input shared_user_temp_access_status_variance_order_by {
	status: order_by
}

"order by aggregate values of table \"shared.users\""
input shared_users_aggregate_order_by {
	avg: shared_users_avg_order_by
	count: order_by
	max: shared_users_max_order_by
	min: shared_users_min_order_by
	stddev: shared_users_stddev_order_by
	stddev_pop: shared_users_stddev_pop_order_by
	stddev_samp: shared_users_stddev_samp_order_by
	sum: shared_users_sum_order_by
	var_pop: shared_users_var_pop_order_by
	var_samp: shared_users_var_samp_order_by
	variance: shared_users_variance_order_by
}

"input type for inserting array relation for remote table \"shared.users\""
input shared_users_arr_rel_insert_input {
	data: [shared_users_insert_input!]!
	on_conflict: shared_users_on_conflict
}

"order by avg() on columns of table \"shared.users\""
input shared_users_avg_order_by {
	external_uid: order_by
	id: order_by
	role_id: order_by
}

"Boolean expression to filter rows from the table \"shared.users\". All fields are combined with a logical 'AND'."
input shared_users_bool_exp {
	_and: [shared_users_bool_exp]
	_not: shared_users_bool_exp
	_or: [shared_users_bool_exp]
	audit: users_audit_log_bool_exp
	created_at: timestamptz_comparison_exp
	expires_at: timestamptz_comparison_exp
	external_uid: Int_comparison_exp
	first_name: String_comparison_exp
	id: Int_comparison_exp
	idpmaps: users_idp_map_bool_exp
	is_blocked: Boolean_comparison_exp
	last_access_at: timestamptz_comparison_exp
	last_block: shared_user_last_blocked_bool_exp
	last_name: String_comparison_exp
	last_unblock: shared_user_last_unblocked_bool_exp
	mail: String_comparison_exp
	profile: users_profiles_bool_exp
	profiles: users_profiles_bool_exp
	role: shared_user_roles_bool_exp
	role_id: Int_comparison_exp
	temp_access: shared_user_temp_access_bool_exp
	type_label: String_comparison_exp
	uid: uuid_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"shared.users\""
input shared_users_inc_input {
	external_uid: Int
	id: Int
	role_id: Int
}

"input type for inserting data into table \"shared.users\""
input shared_users_insert_input {
	audit: users_audit_log_arr_rel_insert_input
	created_at: timestamptz
	expires_at: timestamptz
	external_uid: Int
	first_name: String
	id: Int
	idpmaps: users_idp_map_arr_rel_insert_input
	is_blocked: Boolean
	last_access_at: timestamptz
	last_name: String
	mail: String
	profile: users_profiles_obj_rel_insert_input
	profiles: users_profiles_arr_rel_insert_input
	role: shared_user_roles_obj_rel_insert_input
	role_id: Int
	temp_access: shared_user_temp_access_obj_rel_insert_input
	type_label: String
	uid: uuid
	updated_at: timestamptz
}

"order by max() on columns of table \"shared.users\""
input shared_users_max_order_by {
	created_at: order_by
	expires_at: order_by
	external_uid: order_by
	first_name: order_by
	id: order_by
	last_access_at: order_by
	last_name: order_by
	mail: order_by
	role_id: order_by
	type_label: order_by
	uid: order_by
	updated_at: order_by
}

"order by min() on columns of table \"shared.users\""
input shared_users_min_order_by {
	created_at: order_by
	expires_at: order_by
	external_uid: order_by
	first_name: order_by
	id: order_by
	last_access_at: order_by
	last_name: order_by
	mail: order_by
	role_id: order_by
	type_label: order_by
	uid: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"shared.users\""
input shared_users_obj_rel_insert_input {
	data: shared_users_insert_input!
	on_conflict: shared_users_on_conflict
}

"on conflict condition type for table \"shared.users\""
input shared_users_on_conflict {
	constraint: shared_users_constraint!
	update_columns: [shared_users_update_column!]!
	where: shared_users_bool_exp
}

"ordering options when selecting data from \"shared.users\""
input shared_users_order_by {
	audit_aggregate: users_audit_log_aggregate_order_by
	created_at: order_by
	expires_at: order_by
	external_uid: order_by
	first_name: order_by
	id: order_by
	idpmaps_aggregate: users_idp_map_aggregate_order_by
	is_blocked: order_by
	last_access_at: order_by
	last_block: shared_user_last_blocked_order_by
	last_name: order_by
	last_unblock: shared_user_last_unblocked_order_by
	mail: order_by
	profile: users_profiles_order_by
	profiles_aggregate: users_profiles_aggregate_order_by
	role: shared_user_roles_order_by
	role_id: order_by
	temp_access: shared_user_temp_access_order_by
	type_label: order_by
	uid: order_by
	updated_at: order_by
}

"primary key columns input for table: \"shared.users\""
input shared_users_pk_columns_input {
	uid: uuid!
}

"input type for updating data in table \"shared.users\""
input shared_users_set_input {
	created_at: timestamptz
	expires_at: timestamptz
	external_uid: Int
	first_name: String
	id: Int
	is_blocked: Boolean
	last_access_at: timestamptz
	last_name: String
	mail: String
	role_id: Int
	type_label: String
	uid: uuid
	updated_at: timestamptz
}

"order by stddev() on columns of table \"shared.users\""
input shared_users_stddev_order_by {
	external_uid: order_by
	id: order_by
	role_id: order_by
}

"order by stddev_pop() on columns of table \"shared.users\""
input shared_users_stddev_pop_order_by {
	external_uid: order_by
	id: order_by
	role_id: order_by
}

"order by stddev_samp() on columns of table \"shared.users\""
input shared_users_stddev_samp_order_by {
	external_uid: order_by
	id: order_by
	role_id: order_by
}

"order by sum() on columns of table \"shared.users\""
input shared_users_sum_order_by {
	external_uid: order_by
	id: order_by
	role_id: order_by
}

"order by var_pop() on columns of table \"shared.users\""
input shared_users_var_pop_order_by {
	external_uid: order_by
	id: order_by
	role_id: order_by
}

"order by var_samp() on columns of table \"shared.users\""
input shared_users_var_samp_order_by {
	external_uid: order_by
	id: order_by
	role_id: order_by
}

"order by variance() on columns of table \"shared.users\""
input shared_users_variance_order_by {
	external_uid: order_by
	id: order_by
	role_id: order_by
}

"expression to compare columns of type time. All fields are combined with logical 'AND'."
input time_comparison_exp {
	_eq: time
	_gt: time
	_gte: time
	_in: [time!]
	_is_null: Boolean
	_lt: time
	_lte: time
	_neq: time
	_nin: [time!]
}

"expression to compare columns of type timestamp. All fields are combined with logical 'AND'."
input timestamp_comparison_exp {
	_eq: timestamp
	_gt: timestamp
	_gte: timestamp
	_in: [timestamp!]
	_is_null: Boolean
	_lt: timestamp
	_lte: timestamp
	_neq: timestamp
	_nin: [timestamp!]
}

"expression to compare columns of type timestamptz. All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
	_eq: timestamptz
	_gt: timestamptz
	_gte: timestamptz
	_in: [timestamptz!]
	_is_null: Boolean
	_lt: timestamptz
	_lte: timestamptz
	_neq: timestamptz
	_nin: [timestamptz!]
}

"order by aggregate values of table \"users.audit_log\""
input users_audit_log_aggregate_order_by {
	avg: users_audit_log_avg_order_by
	count: order_by
	max: users_audit_log_max_order_by
	min: users_audit_log_min_order_by
	stddev: users_audit_log_stddev_order_by
	stddev_pop: users_audit_log_stddev_pop_order_by
	stddev_samp: users_audit_log_stddev_samp_order_by
	sum: users_audit_log_sum_order_by
	var_pop: users_audit_log_var_pop_order_by
	var_samp: users_audit_log_var_samp_order_by
	variance: users_audit_log_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input users_audit_log_append_input {
	message: jsonb
}

"input type for inserting array relation for remote table \"users.audit_log\""
input users_audit_log_arr_rel_insert_input {
	data: [users_audit_log_insert_input!]!
	on_conflict: users_audit_log_on_conflict
}

"order by avg() on columns of table \"users.audit_log\""
input users_audit_log_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"users.audit_log\". All fields are combined with a logical 'AND'."
input users_audit_log_bool_exp {
	_and: [users_audit_log_bool_exp]
	_not: users_audit_log_bool_exp
	_or: [users_audit_log_bool_exp]
	created_at: timestamptz_comparison_exp
	event: String_comparison_exp
	id: Int_comparison_exp
	message: jsonb_comparison_exp
	user: shared_users_bool_exp
	user_id: uuid_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input users_audit_log_delete_at_path_input {
	message: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input users_audit_log_delete_elem_input {
	message: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input users_audit_log_delete_key_input {
	message: String
}

"input type for incrementing integer column in table \"users.audit_log\""
input users_audit_log_inc_input {
	id: Int
}

"input type for inserting data into table \"users.audit_log\""
input users_audit_log_insert_input {
	created_at: timestamptz
	event: String
	id: Int
	message: jsonb
	user: shared_users_obj_rel_insert_input
	user_id: uuid
}

"order by max() on columns of table \"users.audit_log\""
input users_audit_log_max_order_by {
	created_at: order_by
	event: order_by
	id: order_by
	user_id: order_by
}

"order by min() on columns of table \"users.audit_log\""
input users_audit_log_min_order_by {
	created_at: order_by
	event: order_by
	id: order_by
	user_id: order_by
}

"input type for inserting object relation for remote table \"users.audit_log\""
input users_audit_log_obj_rel_insert_input {
	data: users_audit_log_insert_input!
	on_conflict: users_audit_log_on_conflict
}

"on conflict condition type for table \"users.audit_log\""
input users_audit_log_on_conflict {
	constraint: users_audit_log_constraint!
	update_columns: [users_audit_log_update_column!]!
	where: users_audit_log_bool_exp
}

"ordering options when selecting data from \"users.audit_log\""
input users_audit_log_order_by {
	created_at: order_by
	event: order_by
	id: order_by
	message: order_by
	user: shared_users_order_by
	user_id: order_by
}

"primary key columns input for table: \"users.audit_log\""
input users_audit_log_pk_columns_input {
	id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input users_audit_log_prepend_input {
	message: jsonb
}

"input type for updating data in table \"users.audit_log\""
input users_audit_log_set_input {
	created_at: timestamptz
	event: String
	id: Int
	message: jsonb
	user_id: uuid
}

"order by stddev() on columns of table \"users.audit_log\""
input users_audit_log_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"users.audit_log\""
input users_audit_log_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"users.audit_log\""
input users_audit_log_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"users.audit_log\""
input users_audit_log_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"users.audit_log\""
input users_audit_log_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"users.audit_log\""
input users_audit_log_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"users.audit_log\""
input users_audit_log_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"users.email_preferences\""
input users_email_preferences_aggregate_order_by {
	count: order_by
	max: users_email_preferences_max_order_by
	min: users_email_preferences_min_order_by
}

"input type for inserting array relation for remote table \"users.email_preferences\""
input users_email_preferences_arr_rel_insert_input {
	data: [users_email_preferences_insert_input!]!
	on_conflict: users_email_preferences_on_conflict
}

"Boolean expression to filter rows from the table \"users.email_preferences\". All fields are combined with a logical 'AND'."
input users_email_preferences_bool_exp {
	_and: [users_email_preferences_bool_exp]
	_not: users_email_preferences_bool_exp
	_or: [users_email_preferences_bool_exp]
	checked: Boolean_comparison_exp
	id: uuid_comparison_exp
	key: String_comparison_exp
	profile: users_profiles_bool_exp
	profile_id: uuid_comparison_exp
}

"input type for inserting data into table \"users.email_preferences\""
input users_email_preferences_insert_input {
	checked: Boolean
	id: uuid
	key: String
	profile: users_profiles_obj_rel_insert_input
	profile_id: uuid
}

"order by max() on columns of table \"users.email_preferences\""
input users_email_preferences_max_order_by {
	id: order_by
	key: order_by
	profile_id: order_by
}

"order by min() on columns of table \"users.email_preferences\""
input users_email_preferences_min_order_by {
	id: order_by
	key: order_by
	profile_id: order_by
}

"input type for inserting object relation for remote table \"users.email_preferences\""
input users_email_preferences_obj_rel_insert_input {
	data: users_email_preferences_insert_input!
	on_conflict: users_email_preferences_on_conflict
}

"on conflict condition type for table \"users.email_preferences\""
input users_email_preferences_on_conflict {
	constraint: users_email_preferences_constraint!
	update_columns: [users_email_preferences_update_column!]!
	where: users_email_preferences_bool_exp
}

"ordering options when selecting data from \"users.email_preferences\""
input users_email_preferences_order_by {
	checked: order_by
	id: order_by
	key: order_by
	profile: users_profiles_order_by
	profile_id: order_by
}

"primary key columns input for table: \"users.email_preferences\""
input users_email_preferences_pk_columns_input {
	id: uuid!
}

"input type for updating data in table \"users.email_preferences\""
input users_email_preferences_set_input {
	checked: Boolean
	id: uuid
	key: String
	profile_id: uuid
}

"order by aggregate values of table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_aggregate_order_by {
	avg: users_group_user_permission_groups_avg_order_by
	count: order_by
	max: users_group_user_permission_groups_max_order_by
	min: users_group_user_permission_groups_min_order_by
	stddev: users_group_user_permission_groups_stddev_order_by
	stddev_pop: users_group_user_permission_groups_stddev_pop_order_by
	stddev_samp: users_group_user_permission_groups_stddev_samp_order_by
	sum: users_group_user_permission_groups_sum_order_by
	var_pop: users_group_user_permission_groups_var_pop_order_by
	var_samp: users_group_user_permission_groups_var_samp_order_by
	variance: users_group_user_permission_groups_variance_order_by
}

"input type for inserting array relation for remote table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_arr_rel_insert_input {
	data: [users_group_user_permission_groups_insert_input!]!
	on_conflict: users_group_user_permission_groups_on_conflict
}

"order by avg() on columns of table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_avg_order_by {
	id: order_by
	user_group_id: order_by
	user_permission_group_id: order_by
}

"Boolean expression to filter rows from the table \"users.group_user_permission_groups\". All fields are combined with a logical 'AND'."
input users_group_user_permission_groups_bool_exp {
	_and: [users_group_user_permission_groups_bool_exp]
	_not: users_group_user_permission_groups_bool_exp
	_or: [users_group_user_permission_groups_bool_exp]
	group: users_groups_bool_exp
	id: Int_comparison_exp
	permission_group: users_permission_groups_bool_exp
	user_group_id: Int_comparison_exp
	user_permission_group_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_inc_input {
	id: Int
	user_group_id: Int
	user_permission_group_id: Int
}

"input type for inserting data into table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_insert_input {
	group: users_groups_obj_rel_insert_input
	id: Int
	permission_group: users_permission_groups_obj_rel_insert_input
	user_group_id: Int
	user_permission_group_id: Int
}

"order by max() on columns of table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_max_order_by {
	id: order_by
	user_group_id: order_by
	user_permission_group_id: order_by
}

"order by min() on columns of table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_min_order_by {
	id: order_by
	user_group_id: order_by
	user_permission_group_id: order_by
}

"input type for inserting object relation for remote table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_obj_rel_insert_input {
	data: users_group_user_permission_groups_insert_input!
	on_conflict: users_group_user_permission_groups_on_conflict
}

"on conflict condition type for table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_on_conflict {
	constraint: users_group_user_permission_groups_constraint!
	update_columns: [users_group_user_permission_groups_update_column!]!
	where: users_group_user_permission_groups_bool_exp
}

"ordering options when selecting data from \"users.group_user_permission_groups\""
input users_group_user_permission_groups_order_by {
	group: users_groups_order_by
	id: order_by
	permission_group: users_permission_groups_order_by
	user_group_id: order_by
	user_permission_group_id: order_by
}

"primary key columns input for table: \"users.group_user_permission_groups\""
input users_group_user_permission_groups_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_set_input {
	id: Int
	user_group_id: Int
	user_permission_group_id: Int
}

"order by stddev() on columns of table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_stddev_order_by {
	id: order_by
	user_group_id: order_by
	user_permission_group_id: order_by
}

"order by stddev_pop() on columns of table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_stddev_pop_order_by {
	id: order_by
	user_group_id: order_by
	user_permission_group_id: order_by
}

"order by stddev_samp() on columns of table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_stddev_samp_order_by {
	id: order_by
	user_group_id: order_by
	user_permission_group_id: order_by
}

"order by sum() on columns of table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_sum_order_by {
	id: order_by
	user_group_id: order_by
	user_permission_group_id: order_by
}

"order by var_pop() on columns of table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_var_pop_order_by {
	id: order_by
	user_group_id: order_by
	user_permission_group_id: order_by
}

"order by var_samp() on columns of table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_var_samp_order_by {
	id: order_by
	user_group_id: order_by
	user_permission_group_id: order_by
}

"order by variance() on columns of table \"users.group_user_permission_groups\""
input users_group_user_permission_groups_variance_order_by {
	id: order_by
	user_group_id: order_by
	user_permission_group_id: order_by
}

"order by aggregate values of table \"users.groups\""
input users_groups_aggregate_order_by {
	avg: users_groups_avg_order_by
	count: order_by
	max: users_groups_max_order_by
	min: users_groups_min_order_by
	stddev: users_groups_stddev_order_by
	stddev_pop: users_groups_stddev_pop_order_by
	stddev_samp: users_groups_stddev_samp_order_by
	sum: users_groups_sum_order_by
	var_pop: users_groups_var_pop_order_by
	var_samp: users_groups_var_samp_order_by
	variance: users_groups_variance_order_by
}

"input type for inserting array relation for remote table \"users.groups\""
input users_groups_arr_rel_insert_input {
	data: [users_groups_insert_input!]!
	on_conflict: users_groups_on_conflict
}

"order by avg() on columns of table \"users.groups\""
input users_groups_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"users.groups\". All fields are combined with a logical 'AND'."
input users_groups_bool_exp {
	_and: [users_groups_bool_exp]
	_not: users_groups_bool_exp
	_or: [users_groups_bool_exp]
	created_at: timestamptz_comparison_exp
	description: String_comparison_exp
	group_user_permission_groups: users_group_user_permission_groups_bool_exp
	id: Int_comparison_exp
	label: String_comparison_exp
	ldap_role: String_comparison_exp
	profile_user_groups: users_profile_user_groups_bool_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"users.groups\""
input users_groups_inc_input {
	id: Int
}

"input type for inserting data into table \"users.groups\""
input users_groups_insert_input {
	created_at: timestamptz
	description: String
	group_user_permission_groups: users_group_user_permission_groups_arr_rel_insert_input
	id: Int
	label: String
	ldap_role: String
	profile_user_groups: users_profile_user_groups_arr_rel_insert_input
	updated_at: timestamptz
}

"order by max() on columns of table \"users.groups\""
input users_groups_max_order_by {
	created_at: order_by
	description: order_by
	id: order_by
	label: order_by
	ldap_role: order_by
	updated_at: order_by
}

"order by min() on columns of table \"users.groups\""
input users_groups_min_order_by {
	created_at: order_by
	description: order_by
	id: order_by
	label: order_by
	ldap_role: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"users.groups\""
input users_groups_obj_rel_insert_input {
	data: users_groups_insert_input!
	on_conflict: users_groups_on_conflict
}

"on conflict condition type for table \"users.groups\""
input users_groups_on_conflict {
	constraint: users_groups_constraint!
	update_columns: [users_groups_update_column!]!
	where: users_groups_bool_exp
}

"ordering options when selecting data from \"users.groups\""
input users_groups_order_by {
	created_at: order_by
	description: order_by
	group_user_permission_groups_aggregate: users_group_user_permission_groups_aggregate_order_by
	id: order_by
	label: order_by
	ldap_role: order_by
	profile_user_groups_aggregate: users_profile_user_groups_aggregate_order_by
	updated_at: order_by
}

"primary key columns input for table: \"users.groups\""
input users_groups_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"users.groups\""
input users_groups_set_input {
	created_at: timestamptz
	description: String
	id: Int
	label: String
	ldap_role: String
	updated_at: timestamptz
}

"order by stddev() on columns of table \"users.groups\""
input users_groups_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"users.groups\""
input users_groups_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"users.groups\""
input users_groups_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"users.groups\""
input users_groups_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"users.groups\""
input users_groups_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"users.groups\""
input users_groups_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"users.groups\""
input users_groups_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"users.idp_map\""
input users_idp_map_aggregate_order_by {
	avg: users_idp_map_avg_order_by
	count: order_by
	max: users_idp_map_max_order_by
	min: users_idp_map_min_order_by
	stddev: users_idp_map_stddev_order_by
	stddev_pop: users_idp_map_stddev_pop_order_by
	stddev_samp: users_idp_map_stddev_samp_order_by
	sum: users_idp_map_sum_order_by
	var_pop: users_idp_map_var_pop_order_by
	var_samp: users_idp_map_var_samp_order_by
	variance: users_idp_map_variance_order_by
}

"input type for inserting array relation for remote table \"users.idp_map\""
input users_idp_map_arr_rel_insert_input {
	data: [users_idp_map_insert_input!]!
	on_conflict: users_idp_map_on_conflict
}

"order by avg() on columns of table \"users.idp_map\""
input users_idp_map_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"users.idp_map\". All fields are combined with a logical 'AND'."
input users_idp_map_bool_exp {
	_and: [users_idp_map_bool_exp]
	_not: users_idp_map_bool_exp
	_or: [users_idp_map_bool_exp]
	id: Int_comparison_exp
	idp: users_idps_enum_comparison_exp
	idpByIdp: users_idps_bool_exp
	idp_user_id: String_comparison_exp
	local_user: shared_users_bool_exp
	local_user_id: uuid_comparison_exp
}

"input type for incrementing integer column in table \"users.idp_map\""
input users_idp_map_inc_input {
	id: Int
}

"input type for inserting data into table \"users.idp_map\""
input users_idp_map_insert_input {
	id: Int
	idp: users_idps_enum
	idpByIdp: users_idps_obj_rel_insert_input
	idp_user_id: String
	local_user: shared_users_obj_rel_insert_input
	local_user_id: uuid
}

"order by max() on columns of table \"users.idp_map\""
input users_idp_map_max_order_by {
	id: order_by
	idp_user_id: order_by
	local_user_id: order_by
}

"order by min() on columns of table \"users.idp_map\""
input users_idp_map_min_order_by {
	id: order_by
	idp_user_id: order_by
	local_user_id: order_by
}

"input type for inserting object relation for remote table \"users.idp_map\""
input users_idp_map_obj_rel_insert_input {
	data: users_idp_map_insert_input!
	on_conflict: users_idp_map_on_conflict
}

"on conflict condition type for table \"users.idp_map\""
input users_idp_map_on_conflict {
	constraint: users_idp_map_constraint!
	update_columns: [users_idp_map_update_column!]!
	where: users_idp_map_bool_exp
}

"ordering options when selecting data from \"users.idp_map\""
input users_idp_map_order_by {
	id: order_by
	idp: order_by
	idpByIdp: users_idps_order_by
	idp_user_id: order_by
	local_user: shared_users_order_by
	local_user_id: order_by
}

"primary key columns input for table: \"users.idp_map\""
input users_idp_map_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"users.idp_map\""
input users_idp_map_set_input {
	id: Int
	idp: users_idps_enum
	idp_user_id: String
	local_user_id: uuid
}

"order by stddev() on columns of table \"users.idp_map\""
input users_idp_map_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"users.idp_map\""
input users_idp_map_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"users.idp_map\""
input users_idp_map_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"users.idp_map\""
input users_idp_map_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"users.idp_map\""
input users_idp_map_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"users.idp_map\""
input users_idp_map_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"users.idp_map\""
input users_idp_map_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"users.idps\""
input users_idps_aggregate_order_by {
	count: order_by
	max: users_idps_max_order_by
	min: users_idps_min_order_by
}

"input type for inserting array relation for remote table \"users.idps\""
input users_idps_arr_rel_insert_input {
	data: [users_idps_insert_input!]!
	on_conflict: users_idps_on_conflict
}

"Boolean expression to filter rows from the table \"users.idps\". All fields are combined with a logical 'AND'."
input users_idps_bool_exp {
	_and: [users_idps_bool_exp]
	_not: users_idps_bool_exp
	_or: [users_idps_bool_exp]
	description: String_comparison_exp
	value: String_comparison_exp
}

"expression to compare columns of type users_idps_enum. All fields are combined with logical 'AND'."
input users_idps_enum_comparison_exp {
	_eq: users_idps_enum
	_in: [users_idps_enum!]
	_is_null: Boolean
	_neq: users_idps_enum
	_nin: [users_idps_enum!]
}

"input type for inserting data into table \"users.idps\""
input users_idps_insert_input {
	description: String
	value: String
}

"order by max() on columns of table \"users.idps\""
input users_idps_max_order_by {
	description: order_by
	value: order_by
}

"order by min() on columns of table \"users.idps\""
input users_idps_min_order_by {
	description: order_by
	value: order_by
}

"input type for inserting object relation for remote table \"users.idps\""
input users_idps_obj_rel_insert_input {
	data: users_idps_insert_input!
	on_conflict: users_idps_on_conflict
}

"on conflict condition type for table \"users.idps\""
input users_idps_on_conflict {
	constraint: users_idps_constraint!
	update_columns: [users_idps_update_column!]!
	where: users_idps_bool_exp
}

"ordering options when selecting data from \"users.idps\""
input users_idps_order_by {
	description: order_by
	value: order_by
}

"primary key columns input for table: \"users.idps\""
input users_idps_pk_columns_input {
	value: String!
}

"input type for updating data in table \"users.idps\""
input users_idps_set_input {
	description: String
	value: String
}

"order by aggregate values of table \"users.notifications\""
input users_notifications_aggregate_order_by {
	count: order_by
	max: users_notifications_max_order_by
	min: users_notifications_min_order_by
}

"input type for inserting array relation for remote table \"users.notifications\""
input users_notifications_arr_rel_insert_input {
	data: [users_notifications_insert_input!]!
	on_conflict: users_notifications_on_conflict
}

"Boolean expression to filter rows from the table \"users.notifications\". All fields are combined with a logical 'AND'."
input users_notifications_bool_exp {
	_and: [users_notifications_bool_exp]
	_not: users_notifications_bool_exp
	_or: [users_notifications_bool_exp]
	id: uuid_comparison_exp
	key: String_comparison_exp
	profile: users_profiles_bool_exp
	profile_id: uuid_comparison_exp
	through_email: Boolean_comparison_exp
	through_platform: Boolean_comparison_exp
}

"input type for inserting data into table \"users.notifications\""
input users_notifications_insert_input {
	id: uuid
	key: String
	profile: users_profiles_obj_rel_insert_input
	profile_id: uuid
	through_email: Boolean
	through_platform: Boolean
}

"order by max() on columns of table \"users.notifications\""
input users_notifications_max_order_by {
	id: order_by
	key: order_by
	profile_id: order_by
}

"order by min() on columns of table \"users.notifications\""
input users_notifications_min_order_by {
	id: order_by
	key: order_by
	profile_id: order_by
}

"input type for inserting object relation for remote table \"users.notifications\""
input users_notifications_obj_rel_insert_input {
	data: users_notifications_insert_input!
	on_conflict: users_notifications_on_conflict
}

"on conflict condition type for table \"users.notifications\""
input users_notifications_on_conflict {
	constraint: users_notifications_constraint!
	update_columns: [users_notifications_update_column!]!
	where: users_notifications_bool_exp
}

"ordering options when selecting data from \"users.notifications\""
input users_notifications_order_by {
	id: order_by
	key: order_by
	profile: users_profiles_order_by
	profile_id: order_by
	through_email: order_by
	through_platform: order_by
}

"primary key columns input for table: \"users.notifications\""
input users_notifications_pk_columns_input {
	id: uuid!
}

"input type for updating data in table \"users.notifications\""
input users_notifications_set_input {
	id: uuid
	key: String
	profile_id: uuid
	through_email: Boolean
	through_platform: Boolean
}

"order by aggregate values of table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_aggregate_order_by {
	avg: users_permission_group_user_permissions_avg_order_by
	count: order_by
	max: users_permission_group_user_permissions_max_order_by
	min: users_permission_group_user_permissions_min_order_by
	stddev: users_permission_group_user_permissions_stddev_order_by
	stddev_pop: users_permission_group_user_permissions_stddev_pop_order_by
	stddev_samp: users_permission_group_user_permissions_stddev_samp_order_by
	sum: users_permission_group_user_permissions_sum_order_by
	var_pop: users_permission_group_user_permissions_var_pop_order_by
	var_samp: users_permission_group_user_permissions_var_samp_order_by
	variance: users_permission_group_user_permissions_variance_order_by
}

"input type for inserting array relation for remote table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_arr_rel_insert_input {
	data: [users_permission_group_user_permissions_insert_input!]!
	on_conflict: users_permission_group_user_permissions_on_conflict
}

"order by avg() on columns of table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_avg_order_by {
	id: order_by
	user_permission_group_id: order_by
	user_permission_id: order_by
}

"Boolean expression to filter rows from the table \"users.permission_group_user_permissions\". All fields are combined with a logical 'AND'."
input users_permission_group_user_permissions_bool_exp {
	_and: [users_permission_group_user_permissions_bool_exp]
	_not: users_permission_group_user_permissions_bool_exp
	_or: [users_permission_group_user_permissions_bool_exp]
	id: Int_comparison_exp
	permission: users_permissions_bool_exp
	permission_group: users_permission_groups_bool_exp
	permissions: users_permissions_bool_exp
	user_permission_group_id: Int_comparison_exp
	user_permission_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_inc_input {
	id: Int
	user_permission_group_id: Int
	user_permission_id: Int
}

"input type for inserting data into table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_insert_input {
	id: Int
	permission: users_permissions_obj_rel_insert_input
	permission_group: users_permission_groups_obj_rel_insert_input
	permissions: users_permissions_arr_rel_insert_input
	user_permission_group_id: Int
	user_permission_id: Int
}

"order by max() on columns of table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_max_order_by {
	id: order_by
	user_permission_group_id: order_by
	user_permission_id: order_by
}

"order by min() on columns of table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_min_order_by {
	id: order_by
	user_permission_group_id: order_by
	user_permission_id: order_by
}

"input type for inserting object relation for remote table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_obj_rel_insert_input {
	data: users_permission_group_user_permissions_insert_input!
	on_conflict: users_permission_group_user_permissions_on_conflict
}

"on conflict condition type for table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_on_conflict {
	constraint: users_permission_group_user_permissions_constraint!
	update_columns: [users_permission_group_user_permissions_update_column!]!
	where: users_permission_group_user_permissions_bool_exp
}

"ordering options when selecting data from \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_order_by {
	id: order_by
	permission: users_permissions_order_by
	permission_group: users_permission_groups_order_by
	permissions_aggregate: users_permissions_aggregate_order_by
	user_permission_group_id: order_by
	user_permission_id: order_by
}

"primary key columns input for table: \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_set_input {
	id: Int
	user_permission_group_id: Int
	user_permission_id: Int
}

"order by stddev() on columns of table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_stddev_order_by {
	id: order_by
	user_permission_group_id: order_by
	user_permission_id: order_by
}

"order by stddev_pop() on columns of table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_stddev_pop_order_by {
	id: order_by
	user_permission_group_id: order_by
	user_permission_id: order_by
}

"order by stddev_samp() on columns of table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_stddev_samp_order_by {
	id: order_by
	user_permission_group_id: order_by
	user_permission_id: order_by
}

"order by sum() on columns of table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_sum_order_by {
	id: order_by
	user_permission_group_id: order_by
	user_permission_id: order_by
}

"order by var_pop() on columns of table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_var_pop_order_by {
	id: order_by
	user_permission_group_id: order_by
	user_permission_id: order_by
}

"order by var_samp() on columns of table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_var_samp_order_by {
	id: order_by
	user_permission_group_id: order_by
	user_permission_id: order_by
}

"order by variance() on columns of table \"users.permission_group_user_permissions\""
input users_permission_group_user_permissions_variance_order_by {
	id: order_by
	user_permission_group_id: order_by
	user_permission_id: order_by
}

"order by aggregate values of table \"users.permission_groups\""
input users_permission_groups_aggregate_order_by {
	avg: users_permission_groups_avg_order_by
	count: order_by
	max: users_permission_groups_max_order_by
	min: users_permission_groups_min_order_by
	stddev: users_permission_groups_stddev_order_by
	stddev_pop: users_permission_groups_stddev_pop_order_by
	stddev_samp: users_permission_groups_stddev_samp_order_by
	sum: users_permission_groups_sum_order_by
	var_pop: users_permission_groups_var_pop_order_by
	var_samp: users_permission_groups_var_samp_order_by
	variance: users_permission_groups_variance_order_by
}

"input type for inserting array relation for remote table \"users.permission_groups\""
input users_permission_groups_arr_rel_insert_input {
	data: [users_permission_groups_insert_input!]!
	on_conflict: users_permission_groups_on_conflict
}

"order by avg() on columns of table \"users.permission_groups\""
input users_permission_groups_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"users.permission_groups\". All fields are combined with a logical 'AND'."
input users_permission_groups_bool_exp {
	_and: [users_permission_groups_bool_exp]
	_not: users_permission_groups_bool_exp
	_or: [users_permission_groups_bool_exp]
	created_at: timestamptz_comparison_exp
	description: String_comparison_exp
	group_user_permission_groups: users_group_user_permission_groups_bool_exp
	id: Int_comparison_exp
	label: String_comparison_exp
	permission_group_user_permissions: users_permission_group_user_permissions_bool_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"users.permission_groups\""
input users_permission_groups_inc_input {
	id: Int
}

"input type for inserting data into table \"users.permission_groups\""
input users_permission_groups_insert_input {
	created_at: timestamptz
	description: String
	group_user_permission_groups: users_group_user_permission_groups_arr_rel_insert_input
	id: Int
	label: String
	permission_group_user_permissions: users_permission_group_user_permissions_arr_rel_insert_input
	updated_at: timestamptz
}

"order by max() on columns of table \"users.permission_groups\""
input users_permission_groups_max_order_by {
	created_at: order_by
	description: order_by
	id: order_by
	label: order_by
	updated_at: order_by
}

"order by min() on columns of table \"users.permission_groups\""
input users_permission_groups_min_order_by {
	created_at: order_by
	description: order_by
	id: order_by
	label: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"users.permission_groups\""
input users_permission_groups_obj_rel_insert_input {
	data: users_permission_groups_insert_input!
	on_conflict: users_permission_groups_on_conflict
}

"on conflict condition type for table \"users.permission_groups\""
input users_permission_groups_on_conflict {
	constraint: users_permission_groups_constraint!
	update_columns: [users_permission_groups_update_column!]!
	where: users_permission_groups_bool_exp
}

"ordering options when selecting data from \"users.permission_groups\""
input users_permission_groups_order_by {
	created_at: order_by
	description: order_by
	group_user_permission_groups_aggregate: users_group_user_permission_groups_aggregate_order_by
	id: order_by
	label: order_by
	permission_group_user_permissions_aggregate: users_permission_group_user_permissions_aggregate_order_by
	updated_at: order_by
}

"primary key columns input for table: \"users.permission_groups\""
input users_permission_groups_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"users.permission_groups\""
input users_permission_groups_set_input {
	created_at: timestamptz
	description: String
	id: Int
	label: String
	updated_at: timestamptz
}

"order by stddev() on columns of table \"users.permission_groups\""
input users_permission_groups_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"users.permission_groups\""
input users_permission_groups_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"users.permission_groups\""
input users_permission_groups_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"users.permission_groups\""
input users_permission_groups_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"users.permission_groups\""
input users_permission_groups_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"users.permission_groups\""
input users_permission_groups_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"users.permission_groups\""
input users_permission_groups_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"users.permission_matrix_view\""
input users_permission_matrix_view_aggregate_order_by {
	avg: users_permission_matrix_view_avg_order_by
	count: order_by
	max: users_permission_matrix_view_max_order_by
	min: users_permission_matrix_view_min_order_by
	stddev: users_permission_matrix_view_stddev_order_by
	stddev_pop: users_permission_matrix_view_stddev_pop_order_by
	stddev_samp: users_permission_matrix_view_stddev_samp_order_by
	sum: users_permission_matrix_view_sum_order_by
	var_pop: users_permission_matrix_view_var_pop_order_by
	var_samp: users_permission_matrix_view_var_samp_order_by
	variance: users_permission_matrix_view_variance_order_by
}

"input type for inserting array relation for remote table \"users.permission_matrix_view\""
input users_permission_matrix_view_arr_rel_insert_input {
	data: [users_permission_matrix_view_insert_input!]!
}

"order by avg() on columns of table \"users.permission_matrix_view\""
input users_permission_matrix_view_avg_order_by {
	group_id: order_by
	permission_group_id: order_by
	permission_id: order_by
}

"Boolean expression to filter rows from the table \"users.permission_matrix_view\". All fields are combined with a logical 'AND'."
input users_permission_matrix_view_bool_exp {
	_and: [users_permission_matrix_view_bool_exp]
	_not: users_permission_matrix_view_bool_exp
	_or: [users_permission_matrix_view_bool_exp]
	group_id: Int_comparison_exp
	permission_group_id: Int_comparison_exp
	permission_group_label: String_comparison_exp
	permission_id: Int_comparison_exp
	permission_label: String_comparison_exp
}

"input type for incrementing integer column in table \"users.permission_matrix_view\""
input users_permission_matrix_view_inc_input {
	group_id: Int
	permission_group_id: Int
	permission_id: Int
}

"input type for inserting data into table \"users.permission_matrix_view\""
input users_permission_matrix_view_insert_input {
	group_id: Int
	permission_group_id: Int
	permission_group_label: String
	permission_id: Int
	permission_label: String
}

"order by max() on columns of table \"users.permission_matrix_view\""
input users_permission_matrix_view_max_order_by {
	group_id: order_by
	permission_group_id: order_by
	permission_group_label: order_by
	permission_id: order_by
	permission_label: order_by
}

"order by min() on columns of table \"users.permission_matrix_view\""
input users_permission_matrix_view_min_order_by {
	group_id: order_by
	permission_group_id: order_by
	permission_group_label: order_by
	permission_id: order_by
	permission_label: order_by
}

"input type for inserting object relation for remote table \"users.permission_matrix_view\""
input users_permission_matrix_view_obj_rel_insert_input {
	data: users_permission_matrix_view_insert_input!
}

"ordering options when selecting data from \"users.permission_matrix_view\""
input users_permission_matrix_view_order_by {
	group_id: order_by
	permission_group_id: order_by
	permission_group_label: order_by
	permission_id: order_by
	permission_label: order_by
}

"input type for updating data in table \"users.permission_matrix_view\""
input users_permission_matrix_view_set_input {
	group_id: Int
	permission_group_id: Int
	permission_group_label: String
	permission_id: Int
	permission_label: String
}

"order by stddev() on columns of table \"users.permission_matrix_view\""
input users_permission_matrix_view_stddev_order_by {
	group_id: order_by
	permission_group_id: order_by
	permission_id: order_by
}

"order by stddev_pop() on columns of table \"users.permission_matrix_view\""
input users_permission_matrix_view_stddev_pop_order_by {
	group_id: order_by
	permission_group_id: order_by
	permission_id: order_by
}

"order by stddev_samp() on columns of table \"users.permission_matrix_view\""
input users_permission_matrix_view_stddev_samp_order_by {
	group_id: order_by
	permission_group_id: order_by
	permission_id: order_by
}

"order by sum() on columns of table \"users.permission_matrix_view\""
input users_permission_matrix_view_sum_order_by {
	group_id: order_by
	permission_group_id: order_by
	permission_id: order_by
}

"order by var_pop() on columns of table \"users.permission_matrix_view\""
input users_permission_matrix_view_var_pop_order_by {
	group_id: order_by
	permission_group_id: order_by
	permission_id: order_by
}

"order by var_samp() on columns of table \"users.permission_matrix_view\""
input users_permission_matrix_view_var_samp_order_by {
	group_id: order_by
	permission_group_id: order_by
	permission_id: order_by
}

"order by variance() on columns of table \"users.permission_matrix_view\""
input users_permission_matrix_view_variance_order_by {
	group_id: order_by
	permission_group_id: order_by
	permission_id: order_by
}

"order by aggregate values of table \"users.permissions\""
input users_permissions_aggregate_order_by {
	avg: users_permissions_avg_order_by
	count: order_by
	max: users_permissions_max_order_by
	min: users_permissions_min_order_by
	stddev: users_permissions_stddev_order_by
	stddev_pop: users_permissions_stddev_pop_order_by
	stddev_samp: users_permissions_stddev_samp_order_by
	sum: users_permissions_sum_order_by
	var_pop: users_permissions_var_pop_order_by
	var_samp: users_permissions_var_samp_order_by
	variance: users_permissions_variance_order_by
}

"input type for inserting array relation for remote table \"users.permissions\""
input users_permissions_arr_rel_insert_input {
	data: [users_permissions_insert_input!]!
	on_conflict: users_permissions_on_conflict
}

"order by avg() on columns of table \"users.permissions\""
input users_permissions_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"users.permissions\". All fields are combined with a logical 'AND'."
input users_permissions_bool_exp {
	_and: [users_permissions_bool_exp]
	_not: users_permissions_bool_exp
	_or: [users_permissions_bool_exp]
	created_at: timestamptz_comparison_exp
	description: String_comparison_exp
	id: Int_comparison_exp
	label: String_comparison_exp
	permission_group_user_permissions: users_permission_group_user_permissions_bool_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"users.permissions\""
input users_permissions_inc_input {
	id: Int
}

"input type for inserting data into table \"users.permissions\""
input users_permissions_insert_input {
	created_at: timestamptz
	description: String
	id: Int
	label: String
	permission_group_user_permissions: users_permission_group_user_permissions_arr_rel_insert_input
	updated_at: timestamptz
}

"order by max() on columns of table \"users.permissions\""
input users_permissions_max_order_by {
	created_at: order_by
	description: order_by
	id: order_by
	label: order_by
	updated_at: order_by
}

"order by min() on columns of table \"users.permissions\""
input users_permissions_min_order_by {
	created_at: order_by
	description: order_by
	id: order_by
	label: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"users.permissions\""
input users_permissions_obj_rel_insert_input {
	data: users_permissions_insert_input!
	on_conflict: users_permissions_on_conflict
}

"on conflict condition type for table \"users.permissions\""
input users_permissions_on_conflict {
	constraint: users_permissions_constraint!
	update_columns: [users_permissions_update_column!]!
	where: users_permissions_bool_exp
}

"ordering options when selecting data from \"users.permissions\""
input users_permissions_order_by {
	created_at: order_by
	description: order_by
	id: order_by
	label: order_by
	permission_group_user_permissions_aggregate: users_permission_group_user_permissions_aggregate_order_by
	updated_at: order_by
}

"primary key columns input for table: \"users.permissions\""
input users_permissions_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"users.permissions\""
input users_permissions_set_input {
	created_at: timestamptz
	description: String
	id: Int
	label: String
	updated_at: timestamptz
}

"order by stddev() on columns of table \"users.permissions\""
input users_permissions_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"users.permissions\""
input users_permissions_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"users.permissions\""
input users_permissions_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"users.permissions\""
input users_permissions_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"users.permissions\""
input users_permissions_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"users.permissions\""
input users_permissions_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"users.permissions\""
input users_permissions_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"users.profile_classifications\""
input users_profile_classifications_aggregate_order_by {
	count: order_by
	max: users_profile_classifications_max_order_by
	min: users_profile_classifications_min_order_by
}

"input type for inserting array relation for remote table \"users.profile_classifications\""
input users_profile_classifications_arr_rel_insert_input {
	data: [users_profile_classifications_insert_input!]!
	on_conflict: users_profile_classifications_on_conflict
}

"Boolean expression to filter rows from the table \"users.profile_classifications\". All fields are combined with a logical 'AND'."
input users_profile_classifications_bool_exp {
	_and: [users_profile_classifications_bool_exp]
	_not: users_profile_classifications_bool_exp
	_or: [users_profile_classifications_bool_exp]
	id: uuid_comparison_exp
	key: String_comparison_exp
	profile: users_profiles_bool_exp
	profile_id: uuid_comparison_exp
}

"input type for inserting data into table \"users.profile_classifications\""
input users_profile_classifications_insert_input {
	id: uuid
	key: String
	profile: users_profiles_obj_rel_insert_input
	profile_id: uuid
}

"order by max() on columns of table \"users.profile_classifications\""
input users_profile_classifications_max_order_by {
	id: order_by
	key: order_by
	profile_id: order_by
}

"order by min() on columns of table \"users.profile_classifications\""
input users_profile_classifications_min_order_by {
	id: order_by
	key: order_by
	profile_id: order_by
}

"input type for inserting object relation for remote table \"users.profile_classifications\""
input users_profile_classifications_obj_rel_insert_input {
	data: users_profile_classifications_insert_input!
	on_conflict: users_profile_classifications_on_conflict
}

"on conflict condition type for table \"users.profile_classifications\""
input users_profile_classifications_on_conflict {
	constraint: users_profile_classifications_constraint!
	update_columns: [users_profile_classifications_update_column!]!
	where: users_profile_classifications_bool_exp
}

"ordering options when selecting data from \"users.profile_classifications\""
input users_profile_classifications_order_by {
	id: order_by
	key: order_by
	profile: users_profiles_order_by
	profile_id: order_by
}

"primary key columns input for table: \"users.profile_classifications\""
input users_profile_classifications_pk_columns_input {
	id: uuid!
}

"input type for updating data in table \"users.profile_classifications\""
input users_profile_classifications_set_input {
	id: uuid
	key: String
	profile_id: uuid
}

"order by aggregate values of table \"users.profile_contexts\""
input users_profile_contexts_aggregate_order_by {
	count: order_by
	max: users_profile_contexts_max_order_by
	min: users_profile_contexts_min_order_by
}

"input type for inserting array relation for remote table \"users.profile_contexts\""
input users_profile_contexts_arr_rel_insert_input {
	data: [users_profile_contexts_insert_input!]!
	on_conflict: users_profile_contexts_on_conflict
}

"Boolean expression to filter rows from the table \"users.profile_contexts\". All fields are combined with a logical 'AND'."
input users_profile_contexts_bool_exp {
	_and: [users_profile_contexts_bool_exp]
	_not: users_profile_contexts_bool_exp
	_or: [users_profile_contexts_bool_exp]
	id: uuid_comparison_exp
	key: String_comparison_exp
	profile: users_profiles_bool_exp
	profile_id: uuid_comparison_exp
}

"input type for inserting data into table \"users.profile_contexts\""
input users_profile_contexts_insert_input {
	id: uuid
	key: String
	profile: users_profiles_obj_rel_insert_input
	profile_id: uuid
}

"order by max() on columns of table \"users.profile_contexts\""
input users_profile_contexts_max_order_by {
	id: order_by
	key: order_by
	profile_id: order_by
}

"order by min() on columns of table \"users.profile_contexts\""
input users_profile_contexts_min_order_by {
	id: order_by
	key: order_by
	profile_id: order_by
}

"input type for inserting object relation for remote table \"users.profile_contexts\""
input users_profile_contexts_obj_rel_insert_input {
	data: users_profile_contexts_insert_input!
	on_conflict: users_profile_contexts_on_conflict
}

"on conflict condition type for table \"users.profile_contexts\""
input users_profile_contexts_on_conflict {
	constraint: users_profile_contexts_constraint!
	update_columns: [users_profile_contexts_update_column!]!
	where: users_profile_contexts_bool_exp
}

"ordering options when selecting data from \"users.profile_contexts\""
input users_profile_contexts_order_by {
	id: order_by
	key: order_by
	profile: users_profiles_order_by
	profile_id: order_by
}

"primary key columns input for table: \"users.profile_contexts\""
input users_profile_contexts_pk_columns_input {
	id: uuid!
}

"input type for updating data in table \"users.profile_contexts\""
input users_profile_contexts_set_input {
	id: uuid
	key: String
	profile_id: uuid
}

"order by aggregate values of table \"users.profile_flags\""
input users_profile_flags_aggregate_order_by {
	avg: users_profile_flags_avg_order_by
	count: order_by
	max: users_profile_flags_max_order_by
	min: users_profile_flags_min_order_by
	stddev: users_profile_flags_stddev_order_by
	stddev_pop: users_profile_flags_stddev_pop_order_by
	stddev_samp: users_profile_flags_stddev_samp_order_by
	sum: users_profile_flags_sum_order_by
	var_pop: users_profile_flags_var_pop_order_by
	var_samp: users_profile_flags_var_samp_order_by
	variance: users_profile_flags_variance_order_by
}

"input type for inserting array relation for remote table \"users.profile_flags\""
input users_profile_flags_arr_rel_insert_input {
	data: [users_profile_flags_insert_input!]!
	on_conflict: users_profile_flags_on_conflict
}

"order by avg() on columns of table \"users.profile_flags\""
input users_profile_flags_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"users.profile_flags\". All fields are combined with a logical 'AND'."
input users_profile_flags_bool_exp {
	_and: [users_profile_flags_bool_exp]
	_not: users_profile_flags_bool_exp
	_or: [users_profile_flags_bool_exp]
	created_at: timestamptz_comparison_exp
	enum_profile_flag: lookup_enum_profile_flags_bool_exp
	id: Int_comparison_exp
	key: lookup_enum_profile_flags_enum_comparison_exp
	profile_id: uuid_comparison_exp
	updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"users.profile_flags\""
input users_profile_flags_inc_input {
	id: Int
}

"input type for inserting data into table \"users.profile_flags\""
input users_profile_flags_insert_input {
	created_at: timestamptz
	enum_profile_flag: lookup_enum_profile_flags_obj_rel_insert_input
	id: Int
	key: lookup_enum_profile_flags_enum
	profile_id: uuid
	updated_at: timestamptz
}

"order by max() on columns of table \"users.profile_flags\""
input users_profile_flags_max_order_by {
	created_at: order_by
	id: order_by
	profile_id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"users.profile_flags\""
input users_profile_flags_min_order_by {
	created_at: order_by
	id: order_by
	profile_id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"users.profile_flags\""
input users_profile_flags_obj_rel_insert_input {
	data: users_profile_flags_insert_input!
	on_conflict: users_profile_flags_on_conflict
}

"on conflict condition type for table \"users.profile_flags\""
input users_profile_flags_on_conflict {
	constraint: users_profile_flags_constraint!
	update_columns: [users_profile_flags_update_column!]!
	where: users_profile_flags_bool_exp
}

"ordering options when selecting data from \"users.profile_flags\""
input users_profile_flags_order_by {
	created_at: order_by
	enum_profile_flag: lookup_enum_profile_flags_order_by
	id: order_by
	key: order_by
	profile_id: order_by
	updated_at: order_by
}

"primary key columns input for table: \"users.profile_flags\""
input users_profile_flags_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"users.profile_flags\""
input users_profile_flags_set_input {
	created_at: timestamptz
	id: Int
	key: lookup_enum_profile_flags_enum
	profile_id: uuid
	updated_at: timestamptz
}

"order by stddev() on columns of table \"users.profile_flags\""
input users_profile_flags_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"users.profile_flags\""
input users_profile_flags_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"users.profile_flags\""
input users_profile_flags_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"users.profile_flags\""
input users_profile_flags_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"users.profile_flags\""
input users_profile_flags_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"users.profile_flags\""
input users_profile_flags_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"users.profile_flags\""
input users_profile_flags_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"users.profile_organizations\""
input users_profile_organizations_aggregate_order_by {
	count: order_by
	max: users_profile_organizations_max_order_by
	min: users_profile_organizations_min_order_by
}

"input type for inserting array relation for remote table \"users.profile_organizations\""
input users_profile_organizations_arr_rel_insert_input {
	data: [users_profile_organizations_insert_input!]!
	on_conflict: users_profile_organizations_on_conflict
}

"Boolean expression to filter rows from the table \"users.profile_organizations\". All fields are combined with a logical 'AND'."
input users_profile_organizations_bool_exp {
	_and: [users_profile_organizations_bool_exp]
	_not: users_profile_organizations_bool_exp
	_or: [users_profile_organizations_bool_exp]
	id: uuid_comparison_exp
	organization: shared_ldap_organizations_bool_exp
	organization_id: String_comparison_exp
	profile: users_profiles_bool_exp
	profile_id: uuid_comparison_exp
	unit_id: String_comparison_exp
}

"input type for inserting data into table \"users.profile_organizations\""
input users_profile_organizations_insert_input {
	id: uuid
	organization: shared_ldap_organizations_obj_rel_insert_input
	organization_id: String
	profile: users_profiles_obj_rel_insert_input
	profile_id: uuid
	unit_id: String
}

"order by max() on columns of table \"users.profile_organizations\""
input users_profile_organizations_max_order_by {
	id: order_by
	organization_id: order_by
	profile_id: order_by
	unit_id: order_by
}

"order by min() on columns of table \"users.profile_organizations\""
input users_profile_organizations_min_order_by {
	id: order_by
	organization_id: order_by
	profile_id: order_by
	unit_id: order_by
}

"input type for inserting object relation for remote table \"users.profile_organizations\""
input users_profile_organizations_obj_rel_insert_input {
	data: users_profile_organizations_insert_input!
	on_conflict: users_profile_organizations_on_conflict
}

"on conflict condition type for table \"users.profile_organizations\""
input users_profile_organizations_on_conflict {
	constraint: users_profile_organizations_constraint!
	update_columns: [users_profile_organizations_update_column!]!
	where: users_profile_organizations_bool_exp
}

"ordering options when selecting data from \"users.profile_organizations\""
input users_profile_organizations_order_by {
	id: order_by
	organization: shared_ldap_organizations_order_by
	organization_id: order_by
	profile: users_profiles_order_by
	profile_id: order_by
	unit_id: order_by
}

"primary key columns input for table: \"users.profile_organizations\""
input users_profile_organizations_pk_columns_input {
	id: uuid!
}

"input type for updating data in table \"users.profile_organizations\""
input users_profile_organizations_set_input {
	id: uuid
	organization_id: String
	profile_id: uuid
	unit_id: String
}

"order by aggregate values of table \"users.profile_preferences\""
input users_profile_preferences_aggregate_order_by {
	avg: users_profile_preferences_avg_order_by
	count: order_by
	max: users_profile_preferences_max_order_by
	min: users_profile_preferences_min_order_by
	stddev: users_profile_preferences_stddev_order_by
	stddev_pop: users_profile_preferences_stddev_pop_order_by
	stddev_samp: users_profile_preferences_stddev_samp_order_by
	sum: users_profile_preferences_sum_order_by
	var_pop: users_profile_preferences_var_pop_order_by
	var_samp: users_profile_preferences_var_samp_order_by
	variance: users_profile_preferences_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input users_profile_preferences_append_input {
	values: jsonb
}

"input type for inserting array relation for remote table \"users.profile_preferences\""
input users_profile_preferences_arr_rel_insert_input {
	data: [users_profile_preferences_insert_input!]!
	on_conflict: users_profile_preferences_on_conflict
}

"order by avg() on columns of table \"users.profile_preferences\""
input users_profile_preferences_avg_order_by {
	id: order_by
}

"Boolean expression to filter rows from the table \"users.profile_preferences\". All fields are combined with a logical 'AND'."
input users_profile_preferences_bool_exp {
	_and: [users_profile_preferences_bool_exp]
	_not: users_profile_preferences_bool_exp
	_or: [users_profile_preferences_bool_exp]
	created_at: timestamptz_comparison_exp
	enum_profile_preferences_key: lookup_enum_profile_preferences_keys_bool_exp
	id: Int_comparison_exp
	key: lookup_enum_profile_preferences_keys_enum_comparison_exp
	profile_id: uuid_comparison_exp
	updated_at: timestamptz_comparison_exp
	values: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input users_profile_preferences_delete_at_path_input {
	values: [String]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input users_profile_preferences_delete_elem_input {
	values: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input users_profile_preferences_delete_key_input {
	values: String
}

"input type for incrementing integer column in table \"users.profile_preferences\""
input users_profile_preferences_inc_input {
	id: Int
}

"input type for inserting data into table \"users.profile_preferences\""
input users_profile_preferences_insert_input {
	created_at: timestamptz
	enum_profile_preferences_key: lookup_enum_profile_preferences_keys_obj_rel_insert_input
	id: Int
	key: lookup_enum_profile_preferences_keys_enum
	profile_id: uuid
	updated_at: timestamptz
	values: jsonb
}

"order by max() on columns of table \"users.profile_preferences\""
input users_profile_preferences_max_order_by {
	created_at: order_by
	id: order_by
	profile_id: order_by
	updated_at: order_by
}

"order by min() on columns of table \"users.profile_preferences\""
input users_profile_preferences_min_order_by {
	created_at: order_by
	id: order_by
	profile_id: order_by
	updated_at: order_by
}

"input type for inserting object relation for remote table \"users.profile_preferences\""
input users_profile_preferences_obj_rel_insert_input {
	data: users_profile_preferences_insert_input!
	on_conflict: users_profile_preferences_on_conflict
}

"on conflict condition type for table \"users.profile_preferences\""
input users_profile_preferences_on_conflict {
	constraint: users_profile_preferences_constraint!
	update_columns: [users_profile_preferences_update_column!]!
	where: users_profile_preferences_bool_exp
}

"ordering options when selecting data from \"users.profile_preferences\""
input users_profile_preferences_order_by {
	created_at: order_by
	enum_profile_preferences_key: lookup_enum_profile_preferences_keys_order_by
	id: order_by
	key: order_by
	profile_id: order_by
	updated_at: order_by
	values: order_by
}

"primary key columns input for table: \"users.profile_preferences\""
input users_profile_preferences_pk_columns_input {
	id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input users_profile_preferences_prepend_input {
	values: jsonb
}

"input type for updating data in table \"users.profile_preferences\""
input users_profile_preferences_set_input {
	created_at: timestamptz
	id: Int
	key: lookup_enum_profile_preferences_keys_enum
	profile_id: uuid
	updated_at: timestamptz
	values: jsonb
}

"order by stddev() on columns of table \"users.profile_preferences\""
input users_profile_preferences_stddev_order_by {
	id: order_by
}

"order by stddev_pop() on columns of table \"users.profile_preferences\""
input users_profile_preferences_stddev_pop_order_by {
	id: order_by
}

"order by stddev_samp() on columns of table \"users.profile_preferences\""
input users_profile_preferences_stddev_samp_order_by {
	id: order_by
}

"order by sum() on columns of table \"users.profile_preferences\""
input users_profile_preferences_sum_order_by {
	id: order_by
}

"order by var_pop() on columns of table \"users.profile_preferences\""
input users_profile_preferences_var_pop_order_by {
	id: order_by
}

"order by var_samp() on columns of table \"users.profile_preferences\""
input users_profile_preferences_var_samp_order_by {
	id: order_by
}

"order by variance() on columns of table \"users.profile_preferences\""
input users_profile_preferences_variance_order_by {
	id: order_by
}

"order by aggregate values of table \"users.profile_user_groups\""
input users_profile_user_groups_aggregate_order_by {
	avg: users_profile_user_groups_avg_order_by
	count: order_by
	max: users_profile_user_groups_max_order_by
	min: users_profile_user_groups_min_order_by
	stddev: users_profile_user_groups_stddev_order_by
	stddev_pop: users_profile_user_groups_stddev_pop_order_by
	stddev_samp: users_profile_user_groups_stddev_samp_order_by
	sum: users_profile_user_groups_sum_order_by
	var_pop: users_profile_user_groups_var_pop_order_by
	var_samp: users_profile_user_groups_var_samp_order_by
	variance: users_profile_user_groups_variance_order_by
}

"input type for inserting array relation for remote table \"users.profile_user_groups\""
input users_profile_user_groups_arr_rel_insert_input {
	data: [users_profile_user_groups_insert_input!]!
	on_conflict: users_profile_user_groups_on_conflict
}

"order by avg() on columns of table \"users.profile_user_groups\""
input users_profile_user_groups_avg_order_by {
	id: order_by
	user_group_id: order_by
}

"Boolean expression to filter rows from the table \"users.profile_user_groups\". All fields are combined with a logical 'AND'."
input users_profile_user_groups_bool_exp {
	_and: [users_profile_user_groups_bool_exp]
	_not: users_profile_user_groups_bool_exp
	_or: [users_profile_user_groups_bool_exp]
	group: users_groups_bool_exp
	groups: users_groups_bool_exp
	id: Int_comparison_exp
	profile: users_profiles_bool_exp
	user_group_id: Int_comparison_exp
	user_profile_id: uuid_comparison_exp
}

"input type for incrementing integer column in table \"users.profile_user_groups\""
input users_profile_user_groups_inc_input {
	id: Int
	user_group_id: Int
}

"input type for inserting data into table \"users.profile_user_groups\""
input users_profile_user_groups_insert_input {
	group: users_groups_obj_rel_insert_input
	groups: users_groups_arr_rel_insert_input
	id: Int
	profile: users_profiles_obj_rel_insert_input
	user_group_id: Int
	user_profile_id: uuid
}

"order by max() on columns of table \"users.profile_user_groups\""
input users_profile_user_groups_max_order_by {
	id: order_by
	user_group_id: order_by
	user_profile_id: order_by
}

"order by min() on columns of table \"users.profile_user_groups\""
input users_profile_user_groups_min_order_by {
	id: order_by
	user_group_id: order_by
	user_profile_id: order_by
}

"input type for inserting object relation for remote table \"users.profile_user_groups\""
input users_profile_user_groups_obj_rel_insert_input {
	data: users_profile_user_groups_insert_input!
	on_conflict: users_profile_user_groups_on_conflict
}

"on conflict condition type for table \"users.profile_user_groups\""
input users_profile_user_groups_on_conflict {
	constraint: users_profile_user_groups_constraint!
	update_columns: [users_profile_user_groups_update_column!]!
	where: users_profile_user_groups_bool_exp
}

"ordering options when selecting data from \"users.profile_user_groups\""
input users_profile_user_groups_order_by {
	group: users_groups_order_by
	groups_aggregate: users_groups_aggregate_order_by
	id: order_by
	profile: users_profiles_order_by
	user_group_id: order_by
	user_profile_id: order_by
}

"primary key columns input for table: \"users.profile_user_groups\""
input users_profile_user_groups_pk_columns_input {
	id: Int!
}

"input type for updating data in table \"users.profile_user_groups\""
input users_profile_user_groups_set_input {
	id: Int
	user_group_id: Int
	user_profile_id: uuid
}

"order by stddev() on columns of table \"users.profile_user_groups\""
input users_profile_user_groups_stddev_order_by {
	id: order_by
	user_group_id: order_by
}

"order by stddev_pop() on columns of table \"users.profile_user_groups\""
input users_profile_user_groups_stddev_pop_order_by {
	id: order_by
	user_group_id: order_by
}

"order by stddev_samp() on columns of table \"users.profile_user_groups\""
input users_profile_user_groups_stddev_samp_order_by {
	id: order_by
	user_group_id: order_by
}

"order by sum() on columns of table \"users.profile_user_groups\""
input users_profile_user_groups_sum_order_by {
	id: order_by
	user_group_id: order_by
}

"order by var_pop() on columns of table \"users.profile_user_groups\""
input users_profile_user_groups_var_pop_order_by {
	id: order_by
	user_group_id: order_by
}

"order by var_samp() on columns of table \"users.profile_user_groups\""
input users_profile_user_groups_var_samp_order_by {
	id: order_by
	user_group_id: order_by
}

"order by variance() on columns of table \"users.profile_user_groups\""
input users_profile_user_groups_variance_order_by {
	id: order_by
	user_group_id: order_by
}

"order by aggregate values of table \"users.profiles\""
input users_profiles_aggregate_order_by {
	count: order_by
	max: users_profiles_max_order_by
	min: users_profiles_min_order_by
}

"input type for inserting array relation for remote table \"users.profiles\""
input users_profiles_arr_rel_insert_input {
	data: [users_profiles_insert_input!]!
	on_conflict: users_profiles_on_conflict
}

"Boolean expression to filter rows from the table \"users.profiles\". All fields are combined with a logical 'AND'."
input users_profiles_bool_exp {
	_and: [users_profiles_bool_exp]
	_not: users_profiles_bool_exp
	_or: [users_profiles_bool_exp]
	alias: String_comparison_exp
	alternative_email: String_comparison_exp
	assignment_labels: app_assignment_labels_v2_bool_exp
	assignment_tags: app_assignment_labels_bool_exp
	assignments: app_assignments_bool_exp
	assignments_v2: app_assignments_v2_bool_exp
	avatar: String_comparison_exp
	bio: String_comparison_exp
	bookmark_searches: app_search_bookmarks_bool_exp
	business_category: String_comparison_exp
	collection_bookmarks: app_collection_bookmarks_bool_exp
	collections: app_collections_bool_exp
	company_id: String_comparison_exp
	created_at: timestamptz_comparison_exp
	email_preferences: users_email_preferences_bool_exp
	id: uuid_comparison_exp
	is_deleted: Boolean_comparison_exp
	is_exception: Boolean_comparison_exp
	item_bookmarks: app_item_bookmarks_bool_exp
	notifications: users_notifications_bool_exp
	organisation: shared_organisations_bool_exp
	profile_classifications: users_profile_classifications_bool_exp
	profile_contexts: users_profile_contexts_bool_exp
	profile_flags: users_profile_flags_bool_exp
	profile_organizations: users_profile_organizations_bool_exp
	profile_preferences: users_profile_preferences_bool_exp
	profile_user_group: users_profile_user_groups_bool_exp
	profile_user_groups: users_profile_user_groups_bool_exp
	stamboek: String_comparison_exp
	title: String_comparison_exp
	updated_at: timestamptz_comparison_exp
	user_id: uuid_comparison_exp
	usersByuserId: shared_users_bool_exp
}

"input type for inserting data into table \"users.profiles\""
input users_profiles_insert_input {
	alias: String
	alternative_email: String
	assignment_labels: app_assignment_labels_v2_arr_rel_insert_input
	assignment_tags: app_assignment_labels_arr_rel_insert_input
	assignments: app_assignments_arr_rel_insert_input
	assignments_v2: app_assignments_v2_arr_rel_insert_input
	avatar: String
	bio: String
	bookmark_searches: app_search_bookmarks_arr_rel_insert_input
	business_category: String
	collection_bookmarks: app_collection_bookmarks_arr_rel_insert_input
	collections: app_collections_arr_rel_insert_input
	company_id: String
	created_at: timestamptz
	email_preferences: users_email_preferences_arr_rel_insert_input
	id: uuid
	is_deleted: Boolean
	is_exception: Boolean
	item_bookmarks: app_item_bookmarks_arr_rel_insert_input
	notifications: users_notifications_arr_rel_insert_input
	organisation: shared_organisations_obj_rel_insert_input
	profile_classifications: users_profile_classifications_arr_rel_insert_input
	profile_contexts: users_profile_contexts_arr_rel_insert_input
	profile_flags: users_profile_flags_arr_rel_insert_input
	profile_organizations: users_profile_organizations_arr_rel_insert_input
	profile_preferences: users_profile_preferences_arr_rel_insert_input
	profile_user_group: users_profile_user_groups_obj_rel_insert_input
	profile_user_groups: users_profile_user_groups_arr_rel_insert_input
	stamboek: String
	title: String
	updated_at: timestamptz
	user_id: uuid
	usersByuserId: shared_users_obj_rel_insert_input
}

"order by max() on columns of table \"users.profiles\""
input users_profiles_max_order_by {
	alias: order_by
	alternative_email: order_by
	avatar: order_by
	bio: order_by
	business_category: order_by
	company_id: order_by
	created_at: order_by
	id: order_by
	stamboek: order_by
	title: order_by
	updated_at: order_by
	user_id: order_by
}

"order by min() on columns of table \"users.profiles\""
input users_profiles_min_order_by {
	alias: order_by
	alternative_email: order_by
	avatar: order_by
	bio: order_by
	business_category: order_by
	company_id: order_by
	created_at: order_by
	id: order_by
	stamboek: order_by
	title: order_by
	updated_at: order_by
	user_id: order_by
}

"input type for inserting object relation for remote table \"users.profiles\""
input users_profiles_obj_rel_insert_input {
	data: users_profiles_insert_input!
	on_conflict: users_profiles_on_conflict
}

"on conflict condition type for table \"users.profiles\""
input users_profiles_on_conflict {
	constraint: users_profiles_constraint!
	update_columns: [users_profiles_update_column!]!
	where: users_profiles_bool_exp
}

"ordering options when selecting data from \"users.profiles\""
input users_profiles_order_by {
	alias: order_by
	alternative_email: order_by
	assignment_labels_aggregate: app_assignment_labels_v2_aggregate_order_by
	assignment_tags_aggregate: app_assignment_labels_aggregate_order_by
	assignments_aggregate: app_assignments_aggregate_order_by
	assignments_v2_aggregate: app_assignments_v2_aggregate_order_by
	avatar: order_by
	bio: order_by
	bookmark_searches_aggregate: app_search_bookmarks_aggregate_order_by
	business_category: order_by
	collection_bookmarks_aggregate: app_collection_bookmarks_aggregate_order_by
	collections_aggregate: app_collections_aggregate_order_by
	company_id: order_by
	created_at: order_by
	email_preferences_aggregate: users_email_preferences_aggregate_order_by
	id: order_by
	is_deleted: order_by
	is_exception: order_by
	item_bookmarks_aggregate: app_item_bookmarks_aggregate_order_by
	notifications_aggregate: users_notifications_aggregate_order_by
	organisation: shared_organisations_order_by
	profile_classifications_aggregate: users_profile_classifications_aggregate_order_by
	profile_contexts_aggregate: users_profile_contexts_aggregate_order_by
	profile_flags_aggregate: users_profile_flags_aggregate_order_by
	profile_organizations_aggregate: users_profile_organizations_aggregate_order_by
	profile_preferences_aggregate: users_profile_preferences_aggregate_order_by
	profile_user_group: users_profile_user_groups_order_by
	profile_user_groups_aggregate: users_profile_user_groups_aggregate_order_by
	stamboek: order_by
	title: order_by
	updated_at: order_by
	user_id: order_by
	usersByuserId: shared_users_order_by
}

"primary key columns input for table: \"users.profiles\""
input users_profiles_pk_columns_input {
	"Een gebruiker kan een of meer profielen hebben"
	id: uuid!
}

"input type for updating data in table \"users.profiles\""
input users_profiles_set_input {
	alias: String
	alternative_email: String
	avatar: String
	bio: String
	business_category: String
	company_id: String
	created_at: timestamptz
	id: uuid
	is_deleted: Boolean
	is_exception: Boolean
	stamboek: String
	title: String
	updated_at: timestamptz
	user_id: uuid
}

"order by aggregate values of table \"users.summary_view\""
input users_summary_view_aggregate_order_by {
	avg: users_summary_view_avg_order_by
	count: order_by
	max: users_summary_view_max_order_by
	min: users_summary_view_min_order_by
	stddev: users_summary_view_stddev_order_by
	stddev_pop: users_summary_view_stddev_pop_order_by
	stddev_samp: users_summary_view_stddev_samp_order_by
	sum: users_summary_view_sum_order_by
	var_pop: users_summary_view_var_pop_order_by
	var_samp: users_summary_view_var_samp_order_by
	variance: users_summary_view_variance_order_by
}

"order by avg() on columns of table \"users.summary_view\""
input users_summary_view_avg_order_by {
	group_id: order_by
	role_id: order_by
}

"Boolean expression to filter rows from the table \"users.summary_view\". All fields are combined with a logical 'AND'."
input users_summary_view_bool_exp {
	_and: [users_summary_view_bool_exp]
	_not: users_summary_view_bool_exp
	_or: [users_summary_view_bool_exp]
	acc_created_at: timestamptz_comparison_exp
	acc_updated_at: timestamptz_comparison_exp
	assignments: app_assignments_bool_exp
	audits: users_audit_log_bool_exp
	blocked_at: shared_user_last_blocked_bool_exp
	business_category: String_comparison_exp
	classifications: users_profile_classifications_bool_exp
	collections: app_collections_bool_exp
	company_id: String_comparison_exp
	company_name: String_comparison_exp
	contexts: users_profile_contexts_bool_exp
	first_name: String_comparison_exp
	first_name_lower: String_comparison_exp
	full_name: String_comparison_exp
	group_id: Int_comparison_exp
	group_name: String_comparison_exp
	idps: users_idp_map_bool_exp
	is_blocked: Boolean_comparison_exp
	is_deleted: Boolean_comparison_exp
	is_exception: Boolean_comparison_exp
	last_access_at: timestamptz_comparison_exp
	last_name: String_comparison_exp
	last_name_lower: String_comparison_exp
	mail: String_comparison_exp
	organisations: users_profile_organizations_bool_exp
	permissions: users_permission_matrix_view_bool_exp
	pro_created_at: timestamptz_comparison_exp
	pro_updated_at: timestamptz_comparison_exp
	profile: users_profiles_bool_exp
	profile_id: uuid_comparison_exp
	role_id: Int_comparison_exp
	role_name: String_comparison_exp
	stamboek: String_comparison_exp
	unblocked_at: shared_user_last_unblocked_bool_exp
	user: shared_users_bool_exp
	user_id: uuid_comparison_exp
}

"order by max() on columns of table \"users.summary_view\""
input users_summary_view_max_order_by {
	acc_created_at: order_by
	acc_updated_at: order_by
	business_category: order_by
	company_id: order_by
	company_name: order_by
	first_name: order_by
	first_name_lower: order_by
	full_name: order_by
	group_id: order_by
	group_name: order_by
	last_access_at: order_by
	last_name: order_by
	last_name_lower: order_by
	mail: order_by
	pro_created_at: order_by
	pro_updated_at: order_by
	profile_id: order_by
	role_id: order_by
	role_name: order_by
	stamboek: order_by
	user_id: order_by
}

"order by min() on columns of table \"users.summary_view\""
input users_summary_view_min_order_by {
	acc_created_at: order_by
	acc_updated_at: order_by
	business_category: order_by
	company_id: order_by
	company_name: order_by
	first_name: order_by
	first_name_lower: order_by
	full_name: order_by
	group_id: order_by
	group_name: order_by
	last_access_at: order_by
	last_name: order_by
	last_name_lower: order_by
	mail: order_by
	pro_created_at: order_by
	pro_updated_at: order_by
	profile_id: order_by
	role_id: order_by
	role_name: order_by
	stamboek: order_by
	user_id: order_by
}

"ordering options when selecting data from \"users.summary_view\""
input users_summary_view_order_by {
	acc_created_at: order_by
	acc_updated_at: order_by
	assignments_aggregate: app_assignments_aggregate_order_by
	audits_aggregate: users_audit_log_aggregate_order_by
	blocked_at: shared_user_last_blocked_order_by
	business_category: order_by
	classifications_aggregate: users_profile_classifications_aggregate_order_by
	collections_aggregate: app_collections_aggregate_order_by
	company_id: order_by
	company_name: order_by
	contexts_aggregate: users_profile_contexts_aggregate_order_by
	first_name: order_by
	first_name_lower: order_by
	full_name: order_by
	group_id: order_by
	group_name: order_by
	idps_aggregate: users_idp_map_aggregate_order_by
	is_blocked: order_by
	is_deleted: order_by
	is_exception: order_by
	last_access_at: order_by
	last_name: order_by
	last_name_lower: order_by
	mail: order_by
	organisations_aggregate: users_profile_organizations_aggregate_order_by
	permissions_aggregate: users_permission_matrix_view_aggregate_order_by
	pro_created_at: order_by
	pro_updated_at: order_by
	profile: users_profiles_order_by
	profile_id: order_by
	role_id: order_by
	role_name: order_by
	stamboek: order_by
	unblocked_at: shared_user_last_unblocked_order_by
	user: shared_users_order_by
	user_id: order_by
}

"order by stddev() on columns of table \"users.summary_view\""
input users_summary_view_stddev_order_by {
	group_id: order_by
	role_id: order_by
}

"order by stddev_pop() on columns of table \"users.summary_view\""
input users_summary_view_stddev_pop_order_by {
	group_id: order_by
	role_id: order_by
}

"order by stddev_samp() on columns of table \"users.summary_view\""
input users_summary_view_stddev_samp_order_by {
	group_id: order_by
	role_id: order_by
}

"order by sum() on columns of table \"users.summary_view\""
input users_summary_view_sum_order_by {
	group_id: order_by
	role_id: order_by
}

"order by var_pop() on columns of table \"users.summary_view\""
input users_summary_view_var_pop_order_by {
	group_id: order_by
	role_id: order_by
}

"order by var_samp() on columns of table \"users.summary_view\""
input users_summary_view_var_samp_order_by {
	group_id: order_by
	role_id: order_by
}

"order by variance() on columns of table \"users.summary_view\""
input users_summary_view_variance_order_by {
	group_id: order_by
	role_id: order_by
}

"expression to compare columns of type uuid. All fields are combined with logical 'AND'."
input uuid_comparison_exp {
	_eq: uuid
	_gt: uuid
	_gte: uuid
	_in: [uuid!]
	_is_null: Boolean
	_lt: uuid
	_lte: uuid
	_neq: uuid
	_nin: [uuid!]
}
